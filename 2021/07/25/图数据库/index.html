<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.rexking6.top","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#37c6c0","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"YS7HT61SEB","apiKey":"0fd1eba022e7883c76ff4a71aee2acdc","indexName":"blog_NAME","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"找不到关于 ${query} 的文章","hits_stats":"共找到 ${hits} 篇文章，花了 ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="...">
<meta property="og:type" content="article">
<meta property="og:title" content="图数据库">
<meta property="og:url" content="https://blog.rexking6.top/2021/07/25/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/">
<meta property="og:site_name" content="RexKing6&#39;s Note">
<meta property="og:description" content="...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.rexking6.top/img/v2-bdc235fbdd1825c1b67ef7d609f81adb_r.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/v2-ccefb7a678de237560cc4df80c11cca3_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/v2-f1f9c98a9fe126d0ba708dd2b7d00dc7_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/v2-0ed25b457bb8920ef3ce689ee670563e_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/v2-994932668db9b58825d169871294b05b_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/v2-3f7729740e78e3f9b17119d278184f05_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/v2-0a186ab265afad22cc261235a56d6c00_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/review01.png">
<meta property="og:image" content="https://image.rexking6.top/img/review02.png">
<meta property="og:image" content="https://nebula-blog.azureedge.net/nebula-blog/review03.png">
<meta property="og:image" content="https://nebula-blog.azureedge.net/nebula-blog/review04.png">
<meta property="og:image" content="https://image.rexking6.top/img/ebb9ee382d3e452eb50bfba932bd7946.png">
<meta property="og:image" content="https://image.rexking6.top/img/38e660a0bc1e4540a1e9e256d9e35544.png">
<meta property="og:image" content="https://image.rexking6.top/img/20200114093752633.png">
<meta property="og:image" content="https://image.rexking6.top/img/v2-5a6d53bafed69174fe6ca97e32514f36_r.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/v2-d77c2eef01d6d9a0127f26025f77e99e_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/v2-80432321be09b120760fb80da3e32e1f_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/image-20210803234709591.png">
<meta property="og:image" content="https://image.rexking6.top/img/image-20210803235853644.png">
<meta property="og:image" content="https://image.rexking6.top/img/v2-32854710d80ca7cd216691e2a51066ca_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/20180907195136475">
<meta property="og:image" content="https://image.rexking6.top/img/20180907195822566">
<meta property="og:image" content="https://image.rexking6.top/img/20180907195854615">
<meta property="og:image" content="https://image.rexking6.top/img/20180907195930730">
<meta property="og:image" content="https://image.rexking6.top/img/20180907195950993">
<meta property="og:image" content="https://image.rexking6.top/img/20180907200018876">
<meta property="og:image" content="https://image.rexking6.top/img/20180907200047417">
<meta property="og:image" content="https://image.rexking6.top/img/20180907200118210">
<meta property="og:image" content="https://image.rexking6.top/img/20180907200136225">
<meta property="og:image" content="https://image.rexking6.top/img/20180907200155515">
<meta property="og:image" content="https://image.rexking6.top/img/2018091116052712">
<meta property="og:image" content="https://image.rexking6.top/img/20180911160639743">
<meta property="og:image" content="https://image.rexking6.top/img/20180911160753461">
<meta property="og:image" content="https://image.rexking6.top/img/20180911160856516">
<meta property="og:image" content="https://image.rexking6.top/img/20180911160939434">
<meta property="og:image" content="https://image.rexking6.top/img/20180911161012374">
<meta property="og:image" content="https://image.rexking6.top/img/20180911161034710">
<meta property="og:image" content="https://image.rexking6.top/img/20180911161101540">
<meta property="og:image" content="https://image.rexking6.top/img/20180911161124284">
<meta property="og:image" content="https://image.rexking6.top/img/20180911161149939">
<meta property="og:image" content="https://image.rexking6.top/img/20180911161210422">
<meta property="og:image" content="https://image.rexking6.top/img/20180911161241934">
<meta property="og:image" content="https://image.rexking6.top/img/20180911161303128">
<meta property="og:image" content="https://image.rexking6.top/img/20180911161325589">
<meta property="og:image" content="https://image.rexking6.top/img/20180911161937302">
<meta property="og:image" content="https://image.rexking6.top/img/20180911162005804">
<meta property="og:image" content="https://image.rexking6.top/img/20180911162032342">
<meta property="og:image" content="https://image.rexking6.top/img/20180911162058307">
<meta property="og:image" content="https://image.rexking6.top/img/20180911162117651">
<meta property="og:image" content="https://image.rexking6.top/img/20180911162138124">
<meta property="og:image" content="https://image.rexking6.top/img/20180911162157182">
<meta property="og:image" content="https://image.rexking6.top/img/20180911162214700">
<meta property="og:image" content="https://image.rexking6.top/img/20180910155848821">
<meta property="og:image" content="https://image.rexking6.top/img/20180910174337986">
<meta property="og:image" content="https://image.rexking6.top/img/2018091017495537">
<meta property="og:image" content="https://image.rexking6.top/img/20180910175004443">
<meta property="og:image" content="https://image.rexking6.top/img/20180910153804741">
<meta property="og:image" content="https://image.rexking6.top/img/20180910175417697">
<meta property="og:image" content="https://image.rexking6.top/img/20180910180633892">
<meta property="og:image" content="https://image.rexking6.top/img/20191111211350679.png">
<meta property="og:image" content="https://image.rexking6.top/img/20180910201234876">
<meta property="og:image" content="https://image.rexking6.top/img/20191111211639873.png">
<meta property="og:image" content="https://image.rexking6.top/img/20180910201600266">
<meta property="og:image" content="https://image.rexking6.top/img/20180910201912889">
<meta property="og:image" content="https://image.rexking6.top/img/20180910202409370">
<meta property="og:image" content="https://image.rexking6.top/img/20180911104946543">
<meta property="og:image" content="https://image.rexking6.top/img/20180914165747392">
<meta property="og:image" content="https://image.rexking6.top/img/20180914170410152">
<meta property="og:image" content="https://image.rexking6.top/img/20180914170703114">
<meta property="og:image" content="https://image.rexking6.top/img/20180914171006576">
<meta property="og:image" content="https://image.rexking6.top/img/20180914171252997">
<meta property="og:image" content="https://image.rexking6.top/img/20180914171410556">
<meta property="og:image" content="https://image.rexking6.top/img/20180918163426159">
<meta property="og:image" content="https://image.rexking6.top/img/20180918163542598">
<meta property="og:image" content="https://image.rexking6.top/img/2018091816362690">
<meta property="og:image" content="https://image.rexking6.top/img/20180918163700965">
<meta property="og:image" content="https://image.rexking6.top/img/20180919231936478">
<meta property="og:image" content="https://image.rexking6.top/img/20180919231958436">
<meta property="og:image" content="https://image.rexking6.top/img/20180919232044890">
<meta property="og:image" content="https://image.rexking6.top/img/20180919232116289">
<meta property="og:image" content="https://image.rexking6.top/img/20180918164122888">
<meta property="og:image" content="https://image.rexking6.top/img/20180918164151957">
<meta property="og:image" content="https://image.rexking6.top/img/20180918164216591">
<meta property="og:image" content="https://image.rexking6.top/img/20180918164234868">
<meta property="og:image" content="https://image.rexking6.top/img/20180913235659479">
<meta property="og:image" content="https://image.rexking6.top/img/20180920102607644">
<meta property="og:image" content="https://image.rexking6.top/img/20180920102852111">
<meta property="og:image" content="https://image.rexking6.top/img/20180914000007337">
<meta property="og:image" content="https://image.rexking6.top/img/20180914000326841">
<meta property="og:image" content="https://image.rexking6.top/img/20180914000337605">
<meta property="og:image" content="https://image.rexking6.top/img/20180914000917427">
<meta property="og:image" content="https://image.rexking6.top/img/20180914002022118">
<meta property="og:image" content="https://image.rexking6.top/img/20180914001738694">
<meta property="og:image" content="https://image.rexking6.top/img/20180918194211861">
<meta property="og:image" content="https://image.rexking6.top/img/20180914002800566">
<meta property="og:image" content="https://image.rexking6.top/img/20180914003124363">
<meta property="og:image" content="https://image.rexking6.top/img/20180914005233286">
<meta property="og:image" content="https://image.rexking6.top/img/20180914005402551">
<meta property="og:image" content="https://image.rexking6.top/img/20180914005534854">
<meta property="og:image" content="https://image.rexking6.top/img/20190312104747884.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190312111316804.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190312155217793.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190312111235837.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190312155343293.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190312112523319.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190312111437384.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190312111501895.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190312111532331.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190312155512830.png">
<meta property="og:image" content="https://image.rexking6.top/img/2018091418071560">
<meta property="og:image" content="https://image.rexking6.top/img/20180914175727284">
<meta property="og:image" content="https://image.rexking6.top/img/20180914190112913">
<meta property="og:image" content="https://image.rexking6.top/img/20180914190346799">
<meta property="og:image" content="https://image.rexking6.top/img/20180914173735184">
<meta property="og:image" content="https://image.rexking6.top/img/20180914174148376">
<meta property="og:image" content="https://image.rexking6.top/img/20180926164146263">
<meta property="og:image" content="https://image.rexking6.top/img/2019031515421790.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190315154310641.png">
<meta property="og:image" content="https://image.rexking6.top/img/2019031515441092.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190315154446895.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190315154601645.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190315154633638.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190315154654292.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190315154713891.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190315154747246.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190315154804196.png">
<meta property="og:image" content="https://image.rexking6.top/img/20180926201415544">
<meta property="og:image" content="https://image.rexking6.top/img/20180926204743857">
<meta property="og:image" content="https://image.rexking6.top/img/20180926205130463">
<meta property="og:image" content="https://image.rexking6.top/img/20180926212157714">
<meta property="og:image" content="https://image.rexking6.top/img/20190405003231225.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190405003253956.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190405003317467.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190405003339980.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190405003408154.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190405003426322.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190405003444250.png">
<meta property="og:image" content="https://image.rexking6.top/img/2019041014391430.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190410143940543.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190410144005464.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190410144025455.png">
<meta property="og:image" content="https://image.rexking6.top/img/2019041014404436.png">
<meta property="og:image" content="https://image.rexking6.top/img/local-step.png">
<meta property="og:image" content="https://image.rexking6.top/img/20180927180036350">
<meta property="og:image" content="https://image.rexking6.top/img/20180927180230660">
<meta property="og:image" content="https://image.rexking6.top/img/201809281150255">
<meta property="og:image" content="https://image.rexking6.top/img/20180928115221627">
<meta property="og:image" content="https://image.rexking6.top/img/20180928115919197">
<meta property="og:image" content="https://image.rexking6.top/img/20180928120339915">
<meta property="og:image" content="https://image.rexking6.top/img/20180928120759516">
<meta property="og:image" content="https://image.rexking6.top/img/20180928131453914">
<meta property="og:image" content="https://image.rexking6.top/img/20180928131759140">
<meta property="og:image" content="https://image.rexking6.top/img/20190429205446664.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190429205509217.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190429205527373.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190429205541262.png">
<meta property="og:image" content="https://image.rexking6.top/img/20190429205556817.png">
<meta property="og:image" content="https://image.rexking6.top/img/20180928161628651">
<meta property="og:image" content="https://image.rexking6.top/img/20180928150731149">
<meta property="og:image" content="https://image.rexking6.top/img/20180928153220587">
<meta property="article:published_time" content="2021-07-25T13:09:58.000Z">
<meta property="article:modified_time" content="2024-07-26T13:32:52.302Z">
<meta property="article:author" content="Run-Qing Chen">
<meta property="article:tag" content="开发">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.rexking6.top/img/v2-bdc235fbdd1825c1b67ef7d609f81adb_r.jpg">

<link rel="canonical" href="https://blog.rexking6.top/2021/07/25/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>图数据库 | RexKing6's Note</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="RexKing6's Note" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RexKing6's Note</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/rexking6" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.rexking6.top/2021/07/25/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Run-Qing Chen">
      <meta itemprop="description" content="覆苍天以为衾，卧大地以为庐。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RexKing6's Note">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          图数据库
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-25 21:09:58" itemprop="dateCreated datePublished" datetime="2021-07-25T21:09:58+08:00">2021-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-26 21:32:52" itemprop="dateModified" datetime="2024-07-26T21:32:52+08:00">2024-07-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
            <span id="/2021/07/25/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-meta-item leancloud_visitors" data-flag-title="图数据库" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>77k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>1:10</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>对图数据库所涉及到的一些概念记录一下，综合转载于：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20623931">数据库与数据仓库的本质区别是什么？</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maiduiyizu/article/details/80371410">详解数据仓库和数据库的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/liangyihuai/article/details/54864952">结构化数据、半结构化数据和非结构化数据</a></li>
<li><a target="_blank" rel="noopener" href="https://my.oschina.net/u/1773689/blog/364548">关系型数据库和非关系型数据库</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fd7b422d5f93">简述关系型数据库和非关系型数据库</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/clover_lily/article/details/79991300">关系型数据库与非关系型数据库</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nebulagraph/p/12613319.html">浅谈图数据库</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sohu.com/a/441553196_633698">一文聊“图”，从图数据库到知识图谱</a></li>
<li><a target="_blank" rel="noopener" href="http://quarterback.cn/tinkerpop与janusgraph概述/">TinkerPop与JanusGraph概述</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chencas/article/details/103967797">图数据库 —- &gt; Tinkerpop (一)</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/260430189">属性图和RDF图简要介绍与比较</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/panchuangai/p/12568071.html">知识图谱里的知识表示：RDF</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44324814/article/details/104669811">一文了解各大图数据库查询语言（Gremlin vs Cypher vs nGQL）| 操作入门篇</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ttlsa.com/nosql/how-to-neo4j-cypher-query-language/">Neo4j Cypher查询语言详解</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/13824962/neo4j-cypher-vs-gremlin-query-language">Neo4j - Cypher vs Gremlin query language</a></li>
<li><a target="_blank" rel="noopener" href="https://www.gremlin.com/docs/?ref=footer">Gremlin Docs</a></li>
<li><a target="_blank" rel="noopener" href="http://tinkerpop-gremlin.cn/">Gremlin中文文档</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/javeme/article/details/82631834">深入学习图数据库语言Gremlin 系列文章链接汇总</a></li>
</ul>
<h1 id="数据库-vs-数据仓库"><a href="#数据库-vs-数据仓库" class="headerlink" title="数据库 vs 数据仓库"></a>数据库 vs 数据仓库</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>数据库 Database（Oracle，Mysql和PostgreSQL）主要用于<strong>事务处理</strong>，数据仓库 Datawarehouse（Amazon Redshift，Hive）主要用于<strong>数据分析</strong>。</p>
<p>用途上的不同决定了这两种架构的特点不同。</p>
<p>数据库（Database）的特点是：</p>
<ul>
<li>相对复杂的表格结构，存储结构相对紧致，少冗余数据。</li>
<li>读和写都有优化。</li>
<li>相对简单的read/write query，单次作用于相对的少量数据。</li>
</ul>
<p>数据仓库（Datawarehouse）的特点是：</p>
<ul>
<li>相对简单的（Denormalized）表格结构，存储结构相对松散，多冗余数据。</li>
<li>一般只是读优化。</li>
<li>相对复杂的read query，单次作用于相对大量的数据（历史数据）。</li>
</ul>
<p>数据库与数据仓库的区别实际讲的是OLTP与OLAP的区别。</p>
<ul>
<li>操作型处理，叫联机事务处理OLTP（On-Line Transaction Processing），也可以称面向交易的处理系统，它是针对具体业务在数据库联机的日常操作，通常对少数记录进行查询、修改。用户较为关心操作的响应时间、数据的安全性、完整性和并发的支持用户数等问题。传统的数据库系统作为数据管理的主要手段，主要用于操作型处理。</li>
<li>分析型处理，叫联机分析处理OLAP（On-Line Analytical Processing）一般针对某些主题历史数据进行分析，支持管理决策。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作型处理</th>
<th>分析型处理</th>
</tr>
</thead>
<tbody>
<tr>
<td>细节的</td>
<td>综合或者提炼的</td>
</tr>
<tr>
<td>实体-关系（E-R）模型</td>
<td>星型模型或雪花模型</td>
</tr>
<tr>
<td>存储瞬间数据</td>
<td>存储历史数据，不包含最近的数据</td>
</tr>
<tr>
<td>可更新的</td>
<td>只读、只追加</td>
</tr>
<tr>
<td>一次操作一个单元</td>
<td>一次操作一个集合</td>
</tr>
<tr>
<td>性能要求高，响应时间短</td>
<td>性能要求宽松</td>
</tr>
<tr>
<td>面向事务</td>
<td>面向分析</td>
</tr>
<tr>
<td>一次操作数据量小</td>
<td>支持决策需求</td>
</tr>
<tr>
<td>数据量小</td>
<td>数据量大</td>
</tr>
<tr>
<td>客户订单、库存水平和银行账户查询</td>
<td>客户收益分析、市场细分</td>
</tr>
</tbody>
</table>
</div>
<h2 id="电商例子"><a href="#电商例子" class="headerlink" title="电商例子"></a>电商例子</h2><p>举个最常见的例子，拿电商行业来说好了。</p>
<p>基本每家电商公司都会经历，从只需要业务数据库到要数据仓库的阶段。</p>
<ul>
<li><p>电商早期启动非常容易，入行门槛低。找个外包团队，做了一个可以下单的网页前端 + 几台服务器 + 一个MySQL，就能开门迎客了。这好比手工作坊时期。</p>
</li>
<li><p>第二阶段，流量来了，客户和订单都多起来了，普通查询已经有压力了，这个时候就需要升级架构变成多台服务器和多个业务数据库（量大+分库分表），这个阶段的业务数字和指标还可以勉强从业务数据库里查询。初步进入工业化。</p>
</li>
<li><p>第三个阶段，一般需要 3-5 年左右的时间，随着业务指数级的增长，数据量的会陡增，公司角色也开始多了起来，开始有了 CEO、CMO、CIO，大家需要面临的问题越来越复杂，越来越深入。高管们关心的问题，从最初非常粗放的：“昨天的收入是多少”、“上个月的 PV、UV 是多少”，逐渐演化到非常精细化和具体的用户的集群分析，特定用户在某种使用场景中，例如“20~30岁女性用户在过去五年的第一季度化妆品类商品的购买行为与公司进行的促销活动方案之间的关系”。</p>
</li>
</ul>
<p>这类非常具体，且能够对公司决策起到关键性作用的问题，基本很难从业务数据库从调取出来。原因在于：</p>
<ol>
<li>业务数据库中的数据结构是为了完成交易而设计的，不是为了而查询和分析的便利设计的。</li>
<li>业务数据库大多是读写优化的，即又要读（查看商品信息），也要写（产生订单，完成支付）。因此对于大量数据的读（查询指标，一般是复杂的只读类型查询）是支持不足的。</li>
</ol>
<p>而怎么解决这个问题，此时我们就需要建立一个数据仓库了，公司也算开始进入信息化阶段了。数据仓库的作用在于：</p>
<ol>
<li>数据结构为了分析和查询的便利；</li>
<li>只读优化的数据库，即不需要它写入速度多么快，只要做大量数据的复杂查询的速度足够快就行了。</li>
</ol>
<p>那么在这里前一种业务数据库（读写都优化）的是业务性数据库，后一种是分析性数据库，即数据仓库。这样把数据从业务性的数据库中提取、加工、导入分析性的数据库就是传统的ETL（Extract-Transform-Load）工作，即数据仓库技术。</p>
<h2 id="图书系统例子"><a href="#图书系统例子" class="headerlink" title="图书系统例子"></a>图书系统例子</h2><p>用图书表格系统举例子。如果是数据库储存的话，表单的设计如下：</p>
<p><img src="https://image.rexking6.top/img/v2-bdc235fbdd1825c1b67ef7d609f81adb_r.jpg" alt=""></p>
<p>这里有六张表，分别记录了作者，图书，图书种类，发行商以及他们之间的关系。</p>
<p>如果我们把以上数据用数据仓库来存储，表单设计需要对原始表单进行Denormalization。</p>
<blockquote>
<p><strong>Denormalization</strong> is a strategy used on a previously-normalized database to increase performance. In computing, <strong>denormalization</strong> is the process of trying to improve the read performance of a database, at the expense of losing some write performance, by adding redundant copies of data or by grouping data. - <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Denormalization">Denormalization - Wikipedia</a></p>
</blockquote>
<p>现在我们把这个数据库的五张表以Books.Title作为主键，用如下图的脚本Denormalize之后存到数据库仓库中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Denormalization Script -- </span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">b.id,</span><br><span class="line">b.title,</span><br><span class="line">b.copyright,</span><br><span class="line">b.isbn,</span><br><span class="line">g.genre,</span><br><span class="line">a.firstname <span class="keyword">as</span> AuthorFirstName,</span><br><span class="line">a.lastname <span class="keyword">as</span> AuthorLastName,</span><br><span class="line">a.dateofbirth,</span><br><span class="line">a.gender,</span><br><span class="line">p.name <span class="keyword">as</span> PublisherName</span><br><span class="line"><span class="keyword">from</span> BOOKS b</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> GENRE g <span class="keyword">on</span> b.genre <span class="operator">=</span> g.id</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> AUTHOR_BOOK_MAP abm <span class="keyword">on</span> b.id <span class="operator">=</span> abm.bookid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> AUTHORS a <span class="keyword">on</span> a.id <span class="operator">=</span> abm.authorid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> PUBLISHER_BOOK_MAP pbm <span class="keyword">on</span> b.id <span class="operator">=</span> pbm.bookid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> PUBLISHER p <span class="keyword">on</span> p.id <span class="operator">=</span> pbm.publisherid;</span><br></pre></td></tr></table></figure>
<p>那么数据仓库中就只剩下一张表，如下图所示。</p>
<p><img src="https://image.rexking6.top/img/v2-ccefb7a678de237560cc4df80c11cca3_720w.jpg" alt=""></p>
<h3 id="存储空间对比"><a href="#存储空间对比" class="headerlink" title="存储空间对比"></a>存储空间对比</h3><p>很明显，因为在denormalization的过程中，如果数据库主表和次表不是一对一的关系，那么最终数据仓库主表或者次表一定会出现重复的数据。所以从存储空间角度讲，相比于数据库紧密的存储结构，数据仓库则存在大量冗余重复的数据。</p>
<p><img src="https://image.rexking6.top/img/v2-f1f9c98a9fe126d0ba708dd2b7d00dc7_720w.jpg" alt=""></p>
<p><img src="https://image.rexking6.top/img/v2-0ed25b457bb8920ef3ce689ee670563e_720w.jpg" alt=""></p>
<h3 id="读写优化对比"><a href="#读写优化对比" class="headerlink" title="读写优化对比"></a>读写优化对比</h3><ul>
<li><p>基本读（Read）操作对比</p>
<p>下图所示的两种查询，一个是找一本书（PrimaryKey）的信息，另一个是找一位作者（Non-Key）所有的作品信息。由于数据库需要利用表之间的关联才能找到所有需要的数据，在效率上会相对低下。相比之下数据仓库把这些关联关系转化成重复数据记录到同一张表上了，查询效率相对就会较高。数据仓库相当于牺牲了空间换取了查询效率。</p>
<p><img src="https://image.rexking6.top/img/v2-994932668db9b58825d169871294b05b_720w.jpg" alt=""></p>
<p>在数据库里面写这段query的时候，<strong>需要了解表单的结构与他们之间的关系</strong>——这对于做数据报告或者数据分析非常不友好，尤其是在表单结构很复杂的时候（比如表单使用了逻辑树的储存结构）。这时候数据仓库简单明了的Denormalized表单结构就对于生成数据报告就非常有优势了。</p>
<p>除此之外，由于数据报告和数据分析常常涉及到大规模的查询，这些查询很可能会占用很高的CPU资源，从而可能影响到数据库的常规读写操作——因为数据库常常是Single-Instance的；这一点上数据仓库的Multi-instances的结构就不会有太多这个问题。</p>
</li>
<li><p>大数据读（Read）操作对比</p>
<p>当数据量非常大的时候，特定条件下的数据仓库的读优化所带来的优势就开始碾压数据库了。大部分的数据库都是Single-instance的，而数据仓库则是Multi-instances的distributed system。数据仓库在分配储存的节点的时候是根据PrimaryKey/PartitionKey来分配的，查询的时候不仅根据查询键的值来搜索对应节点位置，同时进行大量的并行查询。这使得在对大数据进行查询的时候有极大的优势。</p>
<p><img src="https://image.rexking6.top/img/v2-3f7729740e78e3f9b17119d278184f05_720w.jpg" alt=""></p>
<p>但是，并不是所有的读操作，数据仓库一直都有优势。比如在如下两种情况时，数据仓库的读表现并不如数据库：</p>
<ol>
<li>在对小量数据进行读取操作的时候，由于数据仓库要进行找Node的location之类的预运算，整体效率上反倒不如数据库；</li>
<li>如果读取操作的目标不是主键（PrimaryKey）或者分配键（PartitionKey），那么数据仓库的查询也需要进行全局扫描，效率上就不好说是否胜过数据库了。</li>
</ol>
<p>这两点也是为什么现在即使有像Amazon Redshift这般强大的Datawarehouse应用，SQL Database仍然无法被取代的一部分主要原因。</p>
</li>
<li><p>写（Write）操作对比</p>
<p>大多数情况下，数据仓库不太会进行精确的写操作。因为冗余行数太多，有时候只是改一个很小的字段，也会修改大量的行数。而对于数据库来说，由于其紧凑的表格结构，写操作就可以非常精细有效了。比如，需要修改《Java Complete》这本书的版权，从1999改到2002，数据库里面只需要该一行，而数据仓库里面需要改5行。</p>
<p><img src="https://image.rexking6.top/img/v2-0a186ab265afad22cc261235a56d6c00_720w.jpg" alt=""></p>
<p>数据仓库的写操作都是整段（表）刷新或者整段数据插入, 这也和它的用途——做数据分析有关系。由于数据仓库的整表刷新和分布式储存的特质，我们可以通过把PartitionKey设置成数据创建/更新的时间，然后记录一段时间内的历史数据。这对于数据分析以及利用数据进行决策都有重要意义。</p>
</li>
</ul>
<h1 id="结构化数据、半结构化数据和非结构化数据"><a href="#结构化数据、半结构化数据和非结构化数据" class="headerlink" title="结构化数据、半结构化数据和非结构化数据"></a>结构化数据、半结构化数据和非结构化数据</h1><h2 id="结构化数据"><a href="#结构化数据" class="headerlink" title="结构化数据"></a>结构化数据</h2><p>结构化的数据是指可以使用关系型数据库表示和存储，表现为二维形式的数据。一般特点是：数据以行为单位，一行数据表示一个实体的信息，每一行数据的属性是相同的。举一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id		name	age		gender</span><br><span class="line">1		lyh		12		male</span><br><span class="line">2		liangyh	13		female</span><br><span class="line">3		liang	18		male</span><br></pre></td></tr></table></figure>
<p>所以，结构化的数据的存储和排列是很有规律的，这对查询和修改等操作很有帮助。但是，它的扩展性不好。比如，需要增加一个字段。</p>
<h2 id="半结构化数据"><a href="#半结构化数据" class="headerlink" title="半结构化数据"></a>半结构化数据</h2><p>半结构化数据是结构化数据的一种形式，它并不符合关系型数据库或其他数据表的形式关联起来的数据模型结构，但包含相关标记，用来分隔语义元素以及对记录和字段进行分层。因此，它也被称为自描述的结构。</p>
<p>半结构化数据，属于同一类实体可以有不同的属性，即使他们被组合在一起，这些属性的顺序并不重要。</p>
<p>常见的半结构数据有XML和JSON，对于两个XML文件，第一个可能有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;person&gt;</span><br><span class="line">	&lt;name&gt;A&lt;/name&gt;</span><br><span class="line">	&lt;age&gt;13&lt;/age&gt;</span><br><span class="line">  	&lt;gender&gt;female&lt;/gender&gt;</span><br><span class="line">&lt;/person&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;person&gt;</span><br><span class="line">	&lt;name&gt;B&lt;/name&gt;</span><br><span class="line">	&lt;gender&gt;male&lt;/gender&gt;</span><br><span class="line">&lt;/person&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面的例子中，属性的顺序是不重要的，不同的半结构化数据的属性的个数是不一定一样的。有些人说半结构化数据是以树或者图的数据结构存储的数据，怎么理解呢？上面的例子中，<person>标签是树的根节点，<name>和<gender>标签是子节点。通过这样的数据格式，可以自由地表达很多有用的信息，包括自我描述信息（元数据）。所以，半结构化数据的扩展性是很好的。</p>
<h2 id="非结构化数据"><a href="#非结构化数据" class="headerlink" title="非结构化数据"></a>非结构化数据</h2><p>顾名思义，就是没有固定结构的数据。各种文档、图片、视频/音频等都属于非结构化数据。对于这类数据，我们一般直接整体进行存储，而且一般存储为二进制的数据格式。</p>
<h1 id="关系型数据库-vs-非关系型数据库"><a href="#关系型数据库-vs-非关系型数据库" class="headerlink" title="关系型数据库 vs 非关系型数据库"></a>关系型数据库 vs 非关系型数据库</h1><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p>关系型数据库，是指采用了关系模型来组织数据的数据库。</p>
<p>关系模型是在1970年由IBM的研究员E.F.Codd博士首先提出的，在之后的几十年中，关系模型的概念得到了充分的发展并逐渐成为主流数据库结构的主流模型。</p>
<p>简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。</p>
<p>关系模型中常用的概念：</p>
<ul>
<li>关系：可以理解为一张二维表，每个关系都具有一个关系名，就是通常说的表名</li>
<li>元组：可以理解为二维表中的一行，在数据库中经常被称为记录</li>
<li>属性：可以理解为二维表中的一列，在数据库中经常被称为字段</li>
<li>域：属性的取值范围，也就是数据库中某一列的取值限制</li>
<li>关键字：一组可以唯一标识元组的属性，数据库中常称为主键，由一个或多个列组成</li>
<li>关系模式：指对关系的描述。其格式为：关系名(属性1，属性2，……，属性N)，在数据库中成为表结构</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解</li>
<li>使用方便：通用的SQL语言使得操作关系型数据库非常方便</li>
<li>易于维护：丰富的完整性（实体完整性、参照完整性和用户定义的完整性）大大减低了数据冗余和数据不一致的概率</li>
</ul>
<h3 id="瓶颈"><a href="#瓶颈" class="headerlink" title="瓶颈"></a>瓶颈</h3><ul>
<li><p>高并发读写需求</p>
<p>网站的用户并发性非常高，往往达到每秒上万次读写请求，对于传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。</p>
</li>
<li><p>海量数据的高效率读写</p>
<p>网站每天产生的数据量是巨大的，对于关系型数据库来说，在一张包含海量数据的表中查询，效率是非常低的。</p>
</li>
<li><p>高扩展性和可用性</p>
<p>在基于web的结构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展 是非常痛苦的事情，往往需要停机维护和数据迁移。</p>
</li>
</ul>
<ul>
<li><p>性能欠佳</p>
<p>在关系型数据库中，导致性能欠佳的最主要原因是多表的关联查询，以及复杂的数据分析类型的复杂SQL报表查询。为了保证数据库的ACID特性，我们 必须尽量按照其要求的范式进行设计，关系型数据库中的表都是存储一个格式化的数据结构。每个元组字段的组成都是一样，即使不是每个元组都需要所有的字段， 但数据库会为每个元组分配所有的字段，这样的结构可以便于标语表之间进行链接等操作，但从另一个角度来说它也是关系型数据库性能瓶颈的一个因素。</p>
<blockquote>
<p>注：数据库事务必须具备ACID特性，ACID是Atomic原子性，Consistency一致性，Isolation隔离性，Durability持久性。</p>
<ul>
<li>Atomicity（原子性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
<li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="多余特性"><a href="#多余特性" class="headerlink" title="多余特性"></a>多余特性</h3><p>对网站来说：</p>
<ul>
<li><p>事务一致性</p>
<p>关系型数据库在对事物一致性的维护中有很大的开销，而现在很多web2.0系统对事物的读写一致性都不高。</p>
</li>
<li><p>读写实时性</p>
<p>对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比如发一条消息之后，过几秒乃至十几秒之后才看到这条动态是完全可以接受的。</p>
</li>
<li><p>复杂SQL，特别是多表关联查询</p>
<p>任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的复杂SQL报表查询，特别是SNS类型的网站。现实往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大地弱化了。</p>
</li>
</ul>
<h3 id="主流关系型数据库"><a href="#主流关系型数据库" class="headerlink" title="主流关系型数据库"></a>主流关系型数据库</h3><p><a target="_blank" rel="noopener" href="https://www.oracle.com/database/index.html">Oracle</a>，<a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/sql-server/">Microsoft SQL Server</a>，<a target="_blank" rel="noopener" href="https://www.mysql.com/">MySQL</a>，<a target="_blank" rel="noopener" href="https://www.postgresql.org/">PostgreSQL</a>，<a target="_blank" rel="noopener" href="https://www.ibm.com/analytics/us/en/db2/">DB2</a>，<a target="_blank" rel="noopener" href="https://products.office.com/zh-cn/access">Microsoft Access</a>， <a target="_blank" rel="noopener" href="https://www.sqlite.org/">SQLite</a>，<a target="_blank" rel="noopener" href="https://www.teradata.com.cn/">Teradata</a>，<a target="_blank" rel="noopener" href="https://mariadb.org/">MariaDB</a>（MySQL的一个分支），<a target="_blank" rel="noopener" href="https://www.sap.com/">SAP</a></p>
<h2 id="非关系型数据库NoSQL"><a href="#非关系型数据库NoSQL" class="headerlink" title="非关系型数据库NoSQL"></a>非关系型数据库NoSQL</h2><p>NoSQL一词首先是Carlo Strozzi在1998年提出来的，指的是他开发的一个没有SQL功能，轻量级的，开源的关系型数据库。这个定义跟我们现在对NoSQL的定义有很大的 区别，它确确实实字如其名，指的就是“没有SQL”的数据库。但是NoSQL的发展慢慢偏离了初衷，我们要的不是“no sql”，而是“no relational”，也就是我们现在常说的非关系型数据库了。</p>
<p>2009年初，Johan Oskarsson举办了一场关于开源分布式数据库的讨论，Eric Evans在这次讨论中再次提出了NoSQL一词，用于指代那些非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统。Eric Evans使用NoSQL这个词，并不是因为字面上的“没有SQL”的意思，他只是觉得很多经典的关系型数据库名字都叫“**SQL”,所以为了表示跟这些关系型数据库在定位上的截然不同，就是用了“NoSQL”一词。</p>
<p>非关系型数据库提出另一种理念，例如，以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，这样就不会局限于固定的结构，可以减少一些时间和空间的开销。使用这种方式，用户可以根据需要去添加自己需要的字段，这样，为了获取用户的不同信息，不需要 像关系型数据库中，要对多表进行关联查询。仅需要根据id取出相应的value就可以完成查询。但非关系型数据库由于很少的约束，他也不能够提供像SQL 所提供的where这种对于字段属性值情况的查询。并且难以体现设计的完整性。他只适合存储一些较为简单的数据，对于需要进行较复杂查询的数据，SQL数 据库显的更为合适。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol>
<li>性能NoSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li>
<li>可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li>
<li>成本：NoSQL数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。</li>
<li>查询速度：NoSQL数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。</li>
<li>存储数据的格式：NoSQL的存储格式是key-value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库十几年的技术同日而语。</li>
<li>不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。</li>
<li>只适合存储一些较为简单的数据，对于需要进行较复杂查询的数据，关系型数据库显的更为合适。</li>
<li>不适合持久存储海量数据。</li>
</ol>
<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>NoSQL的基本需求就是支持分布式存储，严格一致性与可用性需要互相取舍。</p>
<p>CAP理论：<strong>一个分布式系统不可能同时满足C（一致性）、A（可用性）、P（分区容错性）</strong>三个基本需求，并且最多只能满足其中的两项。对于一个分布式系统来说，分区容错是基本需求，否则不能称之为分布式系统，因此需要在C和A之间寻求平衡。</p>
<ul>
<li>C（Consistency）一致性<br>一致性是指更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。与ACID的C完全不同。</li>
<li>A（Availability）可用性<br>可用性是指服务一直可用，而且是正常响应时间。</li>
<li>P（Partition tolerance）分区容错性<br>分区容错性是指分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</li>
</ul>
<h2 id="关系型数据库-vs-非关系型数据库-1"><a href="#关系型数据库-vs-非关系型数据库-1" class="headerlink" title="关系型数据库  vs 非关系型数据库"></a>关系型数据库  vs 非关系型数据库</h2><p>关系型数据库的最大特点就是事务的一致性：传统的关系型数据库读写操作都是事务的，具有ACID的特点，这个特性使得关系型数据库可以用于几乎所有对一致性有要求的系统中，如典型的银行系统。</p>
<p>但是，在网页应用中，尤其是SNS应用中，一致性却不是显得那么重要，用户A看到的内容和用户B看到同一用户C内容更新不一致是可以容忍的，或者 说，两个人看到同一好友的数据更新的时间差那么几秒是可以容忍的，因此，关系型数据库的最大特点在这里已经无用武之地，起码不是那么重要了。</p>
<p>相反地，关系型数据库为了维护一致性所付出的巨大代价就是其读写性能比较差，而像微博、facebook这类SNS的应用，对并发读写能力要求极 高，关系型数据库已经无法应付（在读方面，传统上为了克服关系型数据库缺陷，提高性能，都是增加一级memcache来静态化网页，而在SNS中，变化太快，memchache已经无能为力了），因此，必须用新的一种数据结构存储来代替关系数据库。</p>
<p>关系数据库的另一个特点就是其具有固定的表结构，因此，其扩展性极差，而在SNS中，系统的升级，功能的增加，往往意味着数据结构巨大变动，这一点关系型数据库也难以应付，需要新的结构化数据存储。</p>
<p>于是，非关系型数据库应运而生，由于不可能用一种数据结构化存储应付所有的新的需求，因此，非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。</p>
<p>必须强调的是，数据的持久存储，尤其是海量数据的持久存储，还是需要一种关系数据库这员老将。</p>
<ol>
<li>成本：Nosql数据库简单易部署，基本都是开源软件，不需要像使用Oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。</li>
<li>查询速度：Nosql数据库将数据存储于缓存之中，而且不需要经过SQL层的解析，关系型数据库将数据存储在硬盘中，自然查询速度远不及Nosql数据库。</li>
<li>存储数据的格式：Nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。</li>
<li>扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。Nosql基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li>
<li>持久存储：Nosql不使用于持久存储，海量数据的持久存储，还是需要关系型数据库。</li>
<li>数据一致性：非关系型数据库一般强调的是数据最终一致性，不像关系型数据库一样强调数据的强一致性，从非关系型数据库中读到的有可能还是处于一个中间态的数据。Nosql不提供对事务的处理。</li>
</ol>
<h2 id="非关系型数据库分类"><a href="#非关系型数据库分类" class="headerlink" title="非关系型数据库分类"></a>非关系型数据库分类</h2><p>由于非关系型数据库本身天然的多样性，以及出现的时间较短，因此，不想关系型数据库，有几种数据库能够一统江山，非关系型数据库非常多，并且大部分都是开源的。</p>
<p>这些数据库中，其实实现大部分都比较简单，除了一些共性外，很大一部分都是针对某些特定的应用需求出现的，因此，对于该类应用，具有极高的性能。依据结构化方法以及应用场合的不同，主要分为以下几类：</p>
<h3 id="面向高性能并发读写的key-value数据库"><a href="#面向高性能并发读写的key-value数据库" class="headerlink" title="面向高性能并发读写的key-value数据库"></a>面向高性能并发读写的key-value数据库</h3><p>key-value数据库的主要特点即使具有极高的并发读写性能。Key-value数据库是一种以键值对存储数据的一种数据库，类似Java中的map。可以将整个数据库理解为一个大的map，每个键都会对应一个唯一的值。</p>
<p>主流代表为<a target="_blank" rel="noopener" href="https://redis.io/">Redis</a>， <a target="_blank" rel="noopener" href="https://aws.amazon.com/cn/dynamodb/">Amazon DynamoDB</a>， <a target="_blank" rel="noopener" href="https://memcached.org/">Memcached</a>，<a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/cosmos-db/">Microsoft Azure Cosmos DB</a>和<a target="_blank" rel="noopener" href="https://hazelcast.com/">Hazelcast</a>。</p>
<p>虽然它的速度非常快，但基本上只能通过键的完全一致查询获取数据，根据数据的保存方式可以分为临时性、永久性和两者兼具三种。</p>
<ol>
<li><p>临时性</p>
<p>所谓临时性就是数据有可能丢失，memcached把所有数据都保存在内存中，这样保存和读取的速度非常快，但是当memcached停止时，数据就不存在了。由于数据保存在内存中，所以无法操作超出内存容量的数据，旧数据会丢失。总结来说：</p>
<ol>
<li>在内存中保存数据</li>
<li>可以进行非常快速的保存和读取处理</li>
<li>数据有可能丢失</li>
</ol>
</li>
<li><p>永久性</p>
<p>所谓永久性就是数据不会丢失，这里的键值存储是把数据保存在硬盘上，与临时性比起来，由于必然要发生对硬盘的IO操作，所以性能上还是有差距的，但数据不会丢失是它最大的优势。总结来说：</p>
<ol>
<li>在硬盘上保存数据</li>
<li>可以进行非常快速的保存和读取处理（但无法与memcached相比）</li>
<li>数据不会丢失</li>
</ol>
</li>
<li><p>两者兼备</p>
<p>Redis属于这种类型。Redis有些特殊，临时性和永久性兼具。Redis首先把数据保存在内存中，在满足特定条件（默认是 15分钟一次以上，5分钟内10个以上，1分钟内10000个以上的键发生变更）的时候将数据写入到硬盘中，这样既确保了内存中数据的处理速度，又可以通过写入硬盘来保证数据的永久性，这种类型的数据库特别适合处理数组类型的数据。总结来说：</p>
<ol>
<li>同时在内存和硬盘上保存数据</li>
<li>可以进行非常快速的保存和读取处理</li>
<li>保存在硬盘上的数据不会消失（可以恢复）</li>
<li>适合于处理数组类型的数据</li>
</ol>
</li>
</ol>
<h3 id="面向海量数据访问的面向文档数据库"><a href="#面向海量数据访问的面向文档数据库" class="headerlink" title="面向海量数据访问的面向文档数据库"></a>面向海量数据访问的面向文档数据库</h3><p>这类数据库的特点是，可以在海量的数据中快速的查询数据。文档存储通常使用内部表示法，可以直接在应用程序中处理，主要是JSON。JSON文档也可以作为纯文本存储在键值存储或关系数据库系统中。</p>
<ol>
<li><p>不定义表结构</p>
<p>即使不定义表结构，也可以像定义了表结构一样使用，还省去了变更表结构的麻烦。</p>
</li>
<li><p>可以使用复杂的查询条件</p>
<p>跟键值存储不同的是，面向文档的数据库可以通过复杂的查询条件来获取数据，虽然不具备事务处理和Join这些关系型数据库所具有的处理能力，但初次以外的其他处理基本上都能实现。</p>
</li>
</ol>
<p>主流代表为<a target="_blank" rel="noopener" href="https://www.mongodb.com/">MongoDB</a>，<a target="_blank" rel="noopener" href="https://aws.amazon.com/cn/dynamodb/">Amazon DynamoDB</a>，<a target="_blank" rel="noopener" href="https://www.couchbase.com/">Couchbase</a>，<a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/cosmos-db/">Microsoft Azure Cosmos DB</a>和<a target="_blank" rel="noopener" href="https://couchdb.apache.org/">CouchDB</a>。</p>
<h3 id="面向搜索数据内容的搜索引擎"><a href="#面向搜索数据内容的搜索引擎" class="headerlink" title="面向搜索数据内容的搜索引擎"></a>面向搜索数据内容的搜索引擎</h3><p>搜索引擎是专门用于搜索数据内容的NoSQL数据库管理系统。主要是用于对海量数据进行近实时的处理和分析处理，可用于机器学习和数据挖掘。主流代表为<a target="_blank" rel="noopener" href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a>，<a target="_blank" rel="noopener" href="https://www.splunk.com/zh-hans_cn">Splunk</a>，<a target="_blank" rel="noopener" href="https://lucene.apache.org/solr/">Solr</a>，<a target="_blank" rel="noopener" href="https://www.marklogic.com/">MarkLogic</a>和<a target="_blank" rel="noopener" href="http://sphinxsearch.com/">Sphinx</a>。</p>
<h3 id="面向可扩展性的分布式数据库（面向列的数据库）"><a href="#面向可扩展性的分布式数据库（面向列的数据库）" class="headerlink" title="面向可扩展性的分布式数据库（面向列的数据库）"></a>面向可扩展性的分布式数据库（面向列的数据库）</h3><p>这类数据库想解决的问题就是传统数据库存在可扩展性上的缺陷，主要特点是具有很强的可拓展性。这类数据库想解决的问题就是传统数据库存在可扩展性上的缺陷，这类数据库可以适应数据量的增加以及数据结构的变化，将数据存储在记录中，能够容纳大量动态列。由于列名和记录键不是固定的，并且由于记录可能有数十亿列，因此可扩展性存储可以看作是二维键值存储。主流代表为<a target="_blank" rel="noopener" href="https://cassandra.apache.org/">Cassandra</a>，<a target="_blank" rel="noopener" href="https://hbase.apache.org/">HBase</a>，<a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/cosmos-db/">Microsoft Azure Cosmos DB</a>，<a target="_blank" rel="noopener" href="https://www.datastax.com/products/datastax-enterprise">Datastax Enterprise</a>和<a target="_blank" rel="noopener" href="https://accumulo.apache.org/">Accumulo</a>。</p>
<p>普通通的关系型数据库都是以行为单位来存储数据的，擅长以行为单位的读入处理，比如特定条件数据的获取。因此，关系型数据库也被称为面向行的数据库。相反，面向列的数据库是以列为单位来存储数据的，擅长以列为单位读入数据。</p>
<p>面向列的数据库具有高扩展性，即使数据增加也不会降低相应的处理速度（特别是写入速度），所以它主要应用于需要处理大量数据的情况。另外，把它作为批处理程序的存储器来对大量数据进行更新也是非常有用的。但由于面向列的数据库跟现行数据库存储的思维方式有很大不同，故应用起来十分困难。</p>
<h3 id="面向关系分析的图数据库"><a href="#面向关系分析的图数据库" class="headerlink" title="面向关系分析的图数据库"></a>面向关系分析的图数据库</h3><p><strong><em>不晓得为啥一堆翻译成“图形数据库”的。</em></strong></p>
<p>图数据库（Graph database）并非指存储图片的数据库，而是以图这种数据结构存储和查询数据。图数据库是一种在线数据库管理系统，具有处理图数据模型的创建，读取，更新和删除（CRUD）操作。与其他数据库不同，关系在图数据库中占首要地位。这意味着应用程序不必使用外键或带外处理（如MapReduce）来推断数据连接。</p>
<p>与关系数据库或其他NoSQL数据库相比，图数据库的数据模型也更加简单，更具表现力。图形数据库是为与事务（OLTP）系统一起使用而构建的，并且在设计时考虑了事务完整性和操作可用性。</p>
<h1 id="图数据库"><a href="#图数据库" class="headerlink" title="图数据库"></a>图数据库</h1><h2 id="从社交网络谈起"><a href="#从社交网络谈起" class="headerlink" title="从社交网络谈起"></a>从社交网络谈起</h2><p>下面这张图是一个社交网络场景，每个用户可以发微博、分享微博或评论他人的微博。这些都是最基本的增删改查，也是大多数研发人员对数据库做的常见操作。而在研发人员的日常工作中除了要把用户的基本信息录入数据库外，还需找到与该用户相关联的信息，方便去对单个的用户进行下一步的分析，比如说：我们发现张三的账户里有很多关于 AI 和音乐的内容，那么我们可以据此推测出他可能是一名程序员，从而推送他可能感兴趣的内容。</p>
<p><img src="https://image.rexking6.top/img/review01.png" alt=""></p>
<p>这些数据分析每时每刻都会发生，但有时候，一个简单的数据工作流在实现的时候可能会变得相当复杂，此外数据库性能也会随着数据量的增加而锐减，比如说获取某管理者下属三级汇报关系的员工，这种统计查询在现在的数据分析中是一种常见的操作，而这种操作往往会因为数据库选型导致性能产生巨大差异。</p>
<h2 id="传统数据库的解决思路"><a href="#传统数据库的解决思路" class="headerlink" title="传统数据库的解决思路"></a>传统数据库的解决思路</h2><h3 id="传统数据库的概念模型及查询的代码"><a href="#传统数据库的概念模型及查询的代码" class="headerlink" title="传统数据库的概念模型及查询的代码"></a>传统数据库的概念模型及查询的代码</h3><p>传统解决上述问题最简单的方法就是<strong>建立一个关系模型</strong>，我们可以把每个员工的信息录入表中，存在诸如 MySQL 之类的关系数据库，下图是最基本的关系模型：</p>
<p><img src="https://image.rexking6.top/img/review02.png" alt=""></p>
<p>但是基于上述的关系模型，要实现我们的需求，就不可避免地涉及到很多关系数据库 <code>JOIN</code> 操作，同时实现出来的查询语句也会变得相当长(有时达到上百行)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> T.directReportees <span class="keyword">AS</span> directReportees, <span class="built_in">sum</span>(T.count) <span class="keyword">AS</span> count</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> manager.pid <span class="keyword">AS</span> directReportees, <span class="number">0</span> <span class="keyword">AS</span> count</span><br><span class="line">	<span class="keyword">FROM</span> person_reportee manager</span><br><span class="line">	<span class="keyword">WHERE</span> manager.pid <span class="operator">=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;fName lName&quot;)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">	<span class="keyword">SELECT</span> manager.pid <span class="keyword">AS</span> directReportees, <span class="built_in">count</span>(manager.directly_manages) <span class="keyword">AS</span> count</span><br><span class="line"><span class="keyword">FROM</span> person_reportee manager</span><br><span class="line"><span class="keyword">WHERE</span> manager.pid <span class="operator">=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;fName lName&quot;)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> directReportees</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> manager.pid <span class="keyword">AS</span> directReportees, <span class="built_in">count</span>(reportee.directly_manages) <span class="keyword">AS</span> count</span><br><span class="line"><span class="keyword">FROM</span> person_reportee manager</span><br><span class="line"><span class="keyword">JOIN</span> person_reportee reportee</span><br><span class="line"><span class="keyword">ON</span> manager.directly_manages <span class="operator">=</span> reportee.pid</span><br><span class="line"><span class="keyword">WHERE</span> manager.pid <span class="operator">=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;fName lName&quot;)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> directReportees</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> manager.pid <span class="keyword">AS</span> directReportees, <span class="built_in">count</span>(L2Reportees.directly_manages) <span class="keyword">AS</span> count</span><br><span class="line"><span class="keyword">FROM</span> person_reportee manager</span><br><span class="line"><span class="keyword">JOIN</span> person_reportee L1Reportees</span><br><span class="line"><span class="keyword">ON</span> manager.directly_manages <span class="operator">=</span> L1Reportees.pid</span><br><span class="line"><span class="keyword">JOIN</span> person_reportee L2Reportees</span><br><span class="line"><span class="keyword">ON</span> L1Reportees.directly_manages <span class="operator">=</span> L2Reportees.pid</span><br><span class="line"><span class="keyword">WHERE</span> manager.pid <span class="operator">=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;fName lName&quot;)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> directReportees</span><br><span class="line">) <span class="keyword">AS</span> T</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> directReportees)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span> T.directReportees <span class="keyword">AS</span> directReportees, <span class="built_in">sum</span>(T.count) <span class="keyword">AS</span> count</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> manager.directly_manages <span class="keyword">AS</span> directReportees, <span class="number">0</span> <span class="keyword">AS</span> count</span><br><span class="line"><span class="keyword">FROM</span> person_reportee manager</span><br><span class="line"><span class="keyword">WHERE</span> manager.pid <span class="operator">=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;fName lName&quot;)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> reportee.pid <span class="keyword">AS</span> directReportees, <span class="built_in">count</span>(reportee.directly_manages) <span class="keyword">AS</span> count</span><br><span class="line"><span class="keyword">FROM</span> person_reportee manager</span><br><span class="line"><span class="keyword">JOIN</span> person_reportee reportee</span><br><span class="line"><span class="keyword">ON</span> manager.directly_manages <span class="operator">=</span> reportee.pid</span><br><span class="line"><span class="keyword">WHERE</span> manager.pid <span class="operator">=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;fName lName&quot;)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> directReportees</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> depth1Reportees.pid <span class="keyword">AS</span> directReportees,</span><br><span class="line"><span class="built_in">count</span>(depth2Reportees.directly_manages) <span class="keyword">AS</span> count</span><br><span class="line"><span class="keyword">FROM</span> person_reportee manager</span><br><span class="line"><span class="keyword">JOIN</span> person_reportee L1Reportees</span><br><span class="line"><span class="keyword">ON</span> manager.directly_manages <span class="operator">=</span> L1Reportees.pid</span><br><span class="line"><span class="keyword">JOIN</span> person_reportee L2Reportees</span><br><span class="line"><span class="keyword">ON</span> L1Reportees.directly_manages <span class="operator">=</span> L2Reportees.pid</span><br><span class="line"><span class="keyword">WHERE</span> manager.pid <span class="operator">=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;fName lName&quot;)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> directReportees</span><br><span class="line">) <span class="keyword">AS</span> T</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> directReportees)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span> T.directReportees <span class="keyword">AS</span> directReportees, <span class="built_in">sum</span>(T.count) <span class="keyword">AS</span> count</span><br><span class="line">	<span class="keyword">FROM</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> reportee.directly_manages <span class="keyword">AS</span> directReportees, <span class="number">0</span> <span class="keyword">AS</span> count</span><br><span class="line"><span class="keyword">FROM</span> person_reportee manager</span><br><span class="line"><span class="keyword">JOIN</span> person_reportee reportee</span><br><span class="line"><span class="keyword">ON</span> manager.directly_manages <span class="operator">=</span> reportee.pid</span><br><span class="line"><span class="keyword">WHERE</span> manager.pid <span class="operator">=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;fName lName&quot;)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> directReportees</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> L2Reportees.pid <span class="keyword">AS</span> directReportees, <span class="built_in">count</span>(L2Reportees.directly_manages) <span class="keyword">AS</span></span><br><span class="line">count</span><br><span class="line"><span class="keyword">FROM</span> person_reportee manager</span><br><span class="line"><span class="keyword">JOIN</span> person_reportee L1Reportees</span><br><span class="line"><span class="keyword">ON</span> manager.directly_manages <span class="operator">=</span> L1Reportees.pid</span><br><span class="line"><span class="keyword">JOIN</span> person_reportee L2Reportees</span><br><span class="line"><span class="keyword">ON</span> L1Reportees.directly_manages <span class="operator">=</span> L2Reportees.pid</span><br><span class="line"><span class="keyword">WHERE</span> manager.pid <span class="operator">=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;fName lName&quot;)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> directReportees</span><br><span class="line">) <span class="keyword">AS</span> T</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> directReportees)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span> L2Reportees.directly_manages <span class="keyword">AS</span> directReportees, <span class="number">0</span> <span class="keyword">AS</span> count</span><br><span class="line"><span class="keyword">FROM</span> person_reportee manager</span><br><span class="line"><span class="keyword">JOIN</span> person_reportee L1Reportees</span><br><span class="line"><span class="keyword">ON</span> manager.directly_manages <span class="operator">=</span> L1Reportees.pid</span><br><span class="line"><span class="keyword">JOIN</span> person_reportee L2Reportees</span><br><span class="line"><span class="keyword">ON</span> L1Reportees.directly_manages <span class="operator">=</span> L2Reportees.pid</span><br><span class="line"><span class="keyword">WHERE</span> manager.pid <span class="operator">=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;fName lName&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这种 glue 代码对维护人员和开发者来说就是一场灾难，没有人想写或者去调试这种代码，此外，这类代码往往伴随着严重的性能问题，这个在之后会详细讨论。</p>
<h3 id="传统关系数据库的性能问题"><a href="#传统关系数据库的性能问题" class="headerlink" title="传统关系数据库的性能问题"></a>传统关系数据库的性能问题</h3><p><strong>性能问题的本质在于数据分析面临的数据量，假如只查询几十个节点或者更少的内容，这种操作是完全不需要考虑数据库性能优化的，但当节点数据从几百个变成几百万个甚至几千万个后，数据库性能就成为了整个产品设计的过程中最需考虑的因素之一。</strong></p>
<p>随着节点的增多，用户跟用户间的关系，用户和产品间的关系，或者产品和产品间的关系都会呈指数增长。</p>
<p>以下是一些公开的数据，可以反映数据、数据和数据间关系的一些实际情况：</p>
<ul>
<li>推特：用户量为 5 亿，用户之间存在关注、点赞关系</li>
<li>亚马逊：用户量 1.2 亿，用户和产品间存在购买关系</li>
<li>AT&amp;T（美国三大运营商之一）： 1 亿个号码，电话号码间可建立通话关系</li>
</ul>
<p>如下表所示，开源的图数据集往往有着上千万个节点和上亿的边的数据：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Data set name</th>
<th>nodes</th>
<th>edges</th>
</tr>
</thead>
<tbody>
<tr>
<td>YahooWeb</td>
<td>1.4 Billion</td>
<td>6 Billion</td>
</tr>
<tr>
<td>Symantec Machine-File Graph</td>
<td>1 Billion</td>
<td>37 Billion</td>
</tr>
<tr>
<td>Twitter</td>
<td>104 Million</td>
<td>3.7 Billion</td>
</tr>
<tr>
<td>Phone call network</td>
<td>30 Million</td>
<td>260 Million</td>
</tr>
</tbody>
</table>
</div>
<p>在数据量这么大的场景中，使用传统 SQL 会产生很大的性能问题，原因主要有两个：</p>
<ol>
<li><strong>大量 JOIN 操作带来的开销</strong>：之前的查询语句使用了大量的 JOIN 操作来找到需要的结果。而大量的 JOIN 操作在数据量很大时会有巨大的性能损失，因为数据本身是被存放在指定的地方，查询本身只需要用到部分数据，但是 JOIN 操作本身会遍历整个数据库，这样就会导致查询效率低到让人无法接受。</li>
<li><strong>反向查询带来的开销</strong>：查询单个经理的下属不需要多少开销，但是如果我们要去反向查询一个员工的老板，使用表结构，开销就会变得非常大。表结构设计得不合理，会对后续的分析、推荐系统产生性能上的影响。比如，当关系从 老板 -&gt; 员工 变成 用户 -&gt; 产品，如果不支持反向查询，推荐系统的实时性就会大打折扣，进而带来经济损失。</li>
</ol>
<p>下表列出的是一个非官方的性能测试（社交网络测试集，一百万用户，每个大概有 50 个好友），体现了在关系数据库里，随着好友查询深度的增加而产生的性能变化：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>levels</th>
<th>RDBMS execution time(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>0.016</td>
</tr>
<tr>
<td>3</td>
<td>30.267</td>
</tr>
<tr>
<td>4</td>
<td>1543.595</td>
</tr>
</tbody>
</table>
</div>
<h3 id="传统数据库的常规优化策略"><a href="#传统数据库的常规优化策略" class="headerlink" title="传统数据库的常规优化策略"></a>传统数据库的常规优化策略</h3><h4 id="策略一：索引"><a href="#策略一：索引" class="headerlink" title="策略一：索引"></a>策略一：索引</h4><p><strong>索引</strong>：SQL 引擎通过索引来找到对应的数据。</p>
<p>常见的索引包括 B- 树索引和哈希索引，建立表的索引是比较常规的优化 SQL 性能的操作。B- 树索引简单地来说就是给每个人一个可排序的独立 ID，B- 树本身是一个平衡多叉搜索树，这个树会将每个元素按照索引 ID 进行排序，从而支持范围查找，范围查找的复杂度是 O(logN) ，其中 N 是索引的文件数目。</p>
<p>但是索引并不能解决所有的问题，如果文件更新频繁或者有很多重复的元素，就会导致很大的空间损耗，此外索引的 IO 消耗也值得考虑，索引 IO 尤其是在机械硬盘上的 IO 读写性能上来说非常不理想，常规的 B- 树索引消耗四次 IO 随机读，当 JOIN 操作变得越来越多时，硬盘查找更可能发生上百次。</p>
<h4 id="策略二：缓存"><a href="#策略二：缓存" class="headerlink" title="策略二：缓存"></a>策略二：缓存</h4><p><strong>缓存</strong>：缓存主要是为了解决有<strong>具有空间或者时间局域性</strong>数据的频繁读取带来的性能优化问题。一个比较常见的使用缓存的架构是 <strong>lookaside cache architecture</strong>。下图是之前 Facebook 用 Memcached  + MySQL 的实例（现已被 Facebook 自研的图数据库 TAO 替代）：</p>
<p><img src="https://nebula-blog.azureedge.net/nebula-blog/review03.png" alt="image"></p>
<p>在架构中，设计者假设用户创造的内容比用户读取的内容要少得多，Memcached 可以简单地理解成一个分布式的支持增删改查的哈希表，支持上亿量级的用户请求。基本的使用流程是当客户端需读数据时，先查看一下缓存，然后再去查询 SQL 数据库。而当用户需要写入数据时，客户端先删除缓存中的 key，让数据过期，再去更新数据库。但是这种架构有几个问题：</p>
<ul>
<li>首先，键值缓存对于图结构数据并不是一个好的操作语句，每次查询一条边，需要从缓存里把节点对应的边全部拿出来；此外，当更新一条边，原来的所有依赖边要被删除，继而需要重新加载所有对应边的数据，这些都是并发的性能瓶颈，毕竟实际场景中一个点往往伴随着几千条边，这种操作带来的时间、内存消耗问题不可忽视。</li>
<li>其次，数据更新到数据读取有一个过程，在上面架构中这个过程需要主从数据库跨域通信。原始模型使用了一个外部标识来记录过期的键值对，并且异步地把这些读取的请求从只读的从节点传递到主节点，这个需要跨域通信，延迟相比直接从本地读大了很多。（类似从之前需要走几百米的距离而现在需要走从北京到深圳的距离）</li>
</ul>
<h2 id="使用图结构建模"><a href="#使用图结构建模" class="headerlink" title="使用图结构建模"></a>使用图结构建模</h2><p>上述关系型数据库建模失败的主要原因在于数据间缺乏内在的关联性，针对这类问题，更好的建模方式是使用图结构。<br>假如数据本身就是表格的结构，关系数据库就可以解决问题，但如果你要展示的是数据与数据间的关系，关系数据库反而不能解决问题了，这主要是在查询的过程中不可避免的大量 JOIN 操作导致的，而每次 JOIN 操作却只用到部分数据，既然反复 JOIN 操作本身会导致大量的性能损失，如何建模才能更好的解决问题呢？答案在点和点之间的关系上。</p>
<h3 id="点、关联关系和图数据模型"><a href="#点、关联关系和图数据模型" class="headerlink" title="点、关联关系和图数据模型"></a>点、关联关系和图数据模型</h3><p>在我们之前的讨论中，传统数据库虽然运用 JOIN 操作把不同的表链接了起来，从而隐式地表达了数据之间的关系，但是当我们要通过 A 管理 B，B 管理 A 的方式查询结果时，表结构并不能直接告诉我们结果。<br>如果我们想在做查询前就知道对应的查询结果，我们必须先定义节点和关系。</p>
<p><strong>节点和关系先定义是图数据库和别的数据库的核心区别</strong>。打个比方，我们可以把经理、员工表示成不同的节点，并用一条边来代表他们之前存在的管理关系，或者把用户和商品看作节点，用购买关系建模等等。而当我们需要新的节点和关系时，只需进行几次更新就好，而不用去改变表的结构或者去迁移数据。</p>
<p>根据节点和关联关系，之前的数据可以根据下图所示建模：</p>
<p><img src="https://nebula-blog.azureedge.net/nebula-blog/review04.png" alt="image"></p>
<p>通过图数据库 Nebula Graph 原生 nGQL 图查询语言进行建模，参考如下操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Insert People</span></span><br><span class="line"><span class="keyword">INSERT</span> VERTEX person(ID, name) <span class="keyword">VALUES</span> <span class="number">1</span>:(<span class="number">2020031601</span>, ‘Jeff’);</span><br><span class="line"><span class="keyword">INSERT</span> VERTEX person(ID, name) <span class="keyword">VALUES</span> <span class="number">2</span>:(<span class="number">2020031602</span>, ‘A’);</span><br><span class="line"><span class="keyword">INSERT</span> VERTEX person(ID, name) <span class="keyword">VALUES</span> <span class="number">3</span>:(<span class="number">2020031603</span>, ‘B’);</span><br><span class="line"><span class="keyword">INSERT</span> VERTEX person(ID, name) <span class="keyword">VALUES</span> <span class="number">4</span>:(<span class="number">2020031604</span>, ‘C’);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Insert edge</span></span><br><span class="line"><span class="keyword">INSERT</span> EDGE manage (level_s, level_end) <span class="keyword">VALUES</span> <span class="number">1</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">2</span>: (<span class="string">&#x27;0&#x27;</span>， <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">INSERT</span> EDGE manage (level_s, level_end) <span class="keyword">VALUES</span> <span class="number">1</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">3</span>: (<span class="string">&#x27;0&#x27;</span>， <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">INSERT</span> EDGE manage (level_s, level_end) <span class="keyword">VALUES</span> <span class="number">1</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">4</span>: (<span class="string">&#x27;0&#x27;</span>， <span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>而之前超长的 query 语句也可以通过 Cypher / nGQL 缩减成短短的 3、4 行代码。</p>
<p>下面为 nGQL 语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GO <span class="keyword">FROM</span> <span class="number">1</span> <span class="keyword">OVER</span> manage YIELD manage.level_s <span class="keyword">as</span> start_level, manage._dst <span class="keyword">AS</span> personid</span><br><span class="line"><span class="operator">|</span> GO <span class="keyword">FROM</span> $personid <span class="keyword">OVER</span> manage <span class="keyword">where</span> manage.level_s <span class="operator">&lt;</span> start_level <span class="operator">+</span> <span class="number">3</span></span><br><span class="line">YIELD <span class="built_in">SUM</span>($$.person.id) <span class="keyword">AS</span> TOTAL, $$.person.name <span class="keyword">AS</span> list</span><br></pre></td></tr></table></figure>
<p>下面为 Cypher 版本</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MATCH</span> (boss)<span class="operator">-</span>[:MANAGES<span class="operator">*</span><span class="number">0.</span><span class="number">.3</span>]<span class="operator">-</span><span class="operator">&gt;</span>(sub),</span><br><span class="line">(sub)<span class="operator">-</span>[:MANAGES<span class="operator">*</span><span class="number">1.</span><span class="number">.3</span>]<span class="operator">-</span><span class="operator">&gt;</span>(personid)</span><br><span class="line"><span class="keyword">WHERE</span> boss.name <span class="operator">=</span> “Jeff”</span><br><span class="line"><span class="keyword">RETURN</span> sub.name <span class="keyword">AS</span> list, <span class="built_in">count</span>(personid) <span class="keyword">AS</span> Total</span><br></pre></td></tr></table></figure>
<p>从近百行代码变成 3、4 行代码可以明显地看出图数据库在数据表达能力上的优势。</p>
<h2 id="底层存储-amp-处理引擎"><a href="#底层存储-amp-处理引擎" class="headerlink" title="底层存储 &amp; 处理引擎"></a>底层存储 &amp; 处理引擎</h2><p>因此，专门用于图的存储和查询技术是非常必要的。图技术根据应用方式的不同可以分为两个方向，第一个方向是图数据库，它用于图数据的存储和联机事务查询，具备实时性，面向OLTP，支持CRUD和事务。第二个方向是图计算引擎，它用于图数据的离线查询分析，更适合海量数据的挖掘，面向OLAP。</p>
<p>图数据库有很多成熟的产品，根据底层存储和处理引擎是否原生，图数据库可以分为四类。为了便于后面理解图数据库处理图的优势，我们解释一下这两个分类维度的含义。</p>
<p><strong>底层存储</strong></p>
<ul>
<li>原生图存储：数据存储模式为存储和管理图而设计，为图进行过优化。</li>
<li>非原生图存储：将图数据序列化，采用关系型数据库、面向对象数据库、或是其他通用数据存储。</li>
</ul>
<p><strong>处理引擎</strong></p>
<ul>
<li>原生图处理：使用免索引邻接，关联节点在物理层面指向彼此，这种方式不同于传统关系型数据库的树形全局索引，为查询图的关联节点带来了巨大的性能优势。</li>
<li>非原生图处理：不采用免索引邻接保存关系。</li>
</ul>
<p>根据这两个维度，图数据库产品可以分为四类：</p>
<p><img src="https://image.rexking6.top/img/ebb9ee382d3e452eb50bfba932bd7946.png" alt=""></p>
<h2 id="知识图谱-amp-图数据库"><a href="#知识图谱-amp-图数据库" class="headerlink" title="知识图谱 &amp; 图数据库"></a>知识图谱 &amp; 图数据库</h2><p>图数据库虽然强大且易用，但是它并不是完美的适用于所有场景。图数据库可以存储海量数据，但并不适合直接用来进行海量数据的分析计算，而更适合用来进行某个实体及其关联关系的查询。因此，仅靠图数据库显然无法解决图计算领域的所有问题，在知识图谱的构建和应用方面还有很多需要利用其他图计算技术来解决的问题。</p>
<p>下图是一个典型的图计算技术架构，包括图数据建模、存储系统和图数据计算三个部分。</p>
<p><img src="https://image.rexking6.top/img/38e660a0bc1e4540a1e9e256d9e35544.png" alt=""></p>
<ul>
<li>图数据建模 ：对于关系型数据库的数据，关系和实体已知，建模成图数据相对简单。但是对于文本这样的非结构化数据，将其建模成为图数据需要应用自然语言处理、机器学习技术，来解决知识抽取、知识融合和知识推理等问题。斯坦福大学Infolab实验室开源的DeepDive提供了知识抽取的框架，是构建知识图谱的利器。</li>
<li>存储系统 ：图数据有多种存储方式，图数据库当然是最适应图的关系存储的，但在不同的应用场景下，也可以考虑将图数据以RDF三元组、关系型数据库、ES或其他NoSQL方式进行存储。</li>
<li>图数据应用 ：在构建好的图数据基础之上，通过图计算引擎对海量图数据进行离线的计算分析，针对不同的应用场景，也可以在内存处理或工作存储中对图数据进行查询分析。</li>
</ul>
<p>图数据库非常适用于图数据的存储和实时查询，是知识图谱的基石，但它并非知识图谱的全部。在应用时，我们需要针对具体的场景去进行选型，结合不同的图计算技术进行分析计算。</p>
<h2 id="图计算框架Tinkerpop"><a href="#图计算框架Tinkerpop" class="headerlink" title="图计算框架Tinkerpop"></a>图计算框架Tinkerpop</h2><h3 id="是图计算"><a href="#是图计算" class="headerlink" title="是图计算"></a>是图计算</h3><p>就如程序=数据结构+算法一样，图计算=Structure+Process。</p>
<ul>
<li>Structure，即图结构，图数据库或图计算框架常用的图形结构通常是基于属性图模型：<ul>
<li>一个图由Vertex（顶点、节点、实体）和Edge（边，线，关系）组成。顶点通过边连接，边有方向，也就是说一条边有一个起始节点和一个结束节点。</li>
<li>其中顶点和边上都可以包含属性（键值对形式，键一般是字符串，值可以是任意类型的数据）。</li>
<li>顶点和边都有标签label进行标记，用于分类，顶点可以有多个label，边通常只有一个label。</li>
</ul>
</li>
<li>Process，即处理过程，图处理过程是分析图结构的手段，图过程的典型形式称为遍历（Traversal）。</li>
</ul>
<h3 id="什么是TinkerPop"><a href="#什么是TinkerPop" class="headerlink" title="什么是TinkerPop"></a>什么是TinkerPop</h3><p>TinkerPop是一个面向实时事务处理（OLAP）以及批量、分析型（OLTP）的开源的图计算框架。TinkerPop是一个可以应用于不同图形数据库的抽象层，避免应用程序与特定数据库高度依赖。</p>
<p>TinkerPop提供通用的API和工具，使开发人员可以基于不同图数据库轻松创建图形应用程序，使图形数据库与图计算解耦，方便切换不同图形数据库，简化其工作。</p>
<p>TinkerPop是一个总称，它包含若干子项目，以及与核心TinkerPop Gremlin引擎集成的模块。在版本TinkerPop2及之前，TinkerPop分为若干子项目，而从TinkerPop3起，都合并到了Gremlin：</p>
<ul>
<li>Blueprints → Gremlin Structure API</li>
<li>Pipes → GraphTraversal</li>
<li>Frames → Traversal</li>
<li>Furnace → GraphComputer and VertexProgram</li>
<li>Rexster → GremlinServer</li>
</ul>
<h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p><img src="https://image.rexking6.top/img/20200114093752633.png" alt=""></p>
<p>TinkerPop的核心Gremlin是什么？- Gremlin is Gremlin is Gremlin</p>
<ul>
<li>这句话是官方文档中，解释Gremlin最常出现的一句话，老外总是能把技术文档搞的好似哲学问题。</li>
<li><p>理解Gremlin以及这句话的含义，可以将Gremlin大致类比为JDK，通过下面类比应该很容易理解Gremlin is Gremlin is Gremlin这句话，用户不管是通过哪种程序语言编写的Gremlin程序，不管是编写的OLTP程序还是OLAP程序，都是没有分别的，都可以通过编译为Gremlin字节码，在GTM（Gremlin Traversal Machine，Gremlin遍历机）上执行：</p>
<ul>
<li>JDK = Java语言 + JVM + Java API类库</li>
<li>Gremlin = Gremlin语言 + GTM + TinkerPop结构API/过程API</li>
</ul>
</li>
<li><p>TinkerPop不是一个完整的图数据系统，其提供了操作图数据的图形结构接口，图操作过程接口，以及编写图形操作程序的Gremlin语言，和执行图形遍历过程的GTM，但是其并不提供图数据持久化存储功能。</p>
</li>
</ul>
<h2 id="属性图-vs-RDF"><a href="#属性图-vs-RDF" class="headerlink" title="属性图 vs RDF"></a>属性图 vs RDF</h2><p>图数据结构在今天能够得到如此广泛关注，灵活性是一个强大的驱动因素:异构数据、集成新数据源和分析都需要灵活性，而图结构则很好地满足了这一点。现如今，最主要的图数据结构模型有以下两种：属性图和RDF图，下面就将分别介绍这两种图结构并进行比较。</p>
<h3 id="属性图（Property-Graphs）"><a href="#属性图（Property-Graphs）" class="headerlink" title="属性图（Property Graphs）"></a>属性图（Property Graphs）</h3><p>虽然属性图的实现中有一些核心的共性，但是没有真正标准的属性图数据模型，因此属性图的每个实现都有些不同。在下面，我们将重点讨论任何属性图数据库都常见的特征。</p>
<ul>
<li>节点（Nodes）：是图中的实体，用表示其类型的0到多个文本标签进行标记，相当于实体。</li>
<li>边（Edges）：是节点之间的定向链接，也称为关系。其中对应的“from node”称为源节点，“to node”称为目标节点。边是定向的且每条边都有一个类型，它们可以在任何方向上导航和查询。相当于实体之间的关系。</li>
<li>属性（Properties）：是一个键值对，顶点和边都具有属性。</li>
</ul>
<p>图1显示了一个属性图的部分，其中包含有关演员、导演和他们参与的电影或电视节目的数据。其中节点用椭圆表示。例如，ID为123的节点（从其属性中看出）表示Tom Hanks。节点标签以深蓝色显示。节点123的标签是人物、演员和导演。关系用灰色箭头表示，从一个节点指向另一个节点，每个关系都有一个红色显示的类型。属性显示在带有金色的圆角矩形中，并使用红色箭头连接到它们所属的节点和关系。</p>
<p><img src="https://image.rexking6.top/img/v2-5a6d53bafed69174fe6ca97e32514f36_r.jpg" alt="图1.一个关于演员、导演和影片或电视节目的属性图"></p>
<h3 id="资源描述框架图（RDF-Graphs）"><a href="#资源描述框架图（RDF-Graphs）" class="headerlink" title="资源描述框架图（RDF Graphs）"></a>资源描述框架图（RDF Graphs）</h3><p>RDF图使用标准的图数据模型，其技术栈的标准是由万维网联盟（W3C）管理的，这个组织也同时管理HTML、XML和许多其他网络标准。因此每个支持RDF的数据库都应该以同样的方式支持该模型。除此之外，RDF有一个标准的查询语言称为SPARQL。它既是一种功能齐全的查询语言，又是一种HTTP协议，可以通过HTTP将查询请求发送到端点。RDF图数据模型主要是由以下两个部分组成的：</p>
<ul>
<li>节点（Nodes）：对应图中的顶点，可以是具有唯一标识符的资源，也可以是字符串、整数等有值的内容。</li>
<li>边（Edges）：是节点之间的定向链接，也称为谓词或属性。边的入节点称为主语，出节点称为宾语，由一条边连接的两个节点形成一个主语-谓词-宾语的陈述，也称为三元组。边是定向的，它们可以在任何方向上导航和查询。</li>
</ul>
<p>RDF的英文全称为Resource Description Framework，因为在RDF图中，一切都称为源。边和节点只是给定语句中资源所扮演的角色。基本上在RDF中，扮演边角色的资源和扮演节点角色的资源没有区别，因此一条语句中的边也可以是另一条语句中的节点。RDF数据模型相较于属性图更加丰富，也在语义上保持一致性。图2展示了如何将上面的图1由属性图表示为RDF：</p>
<p><img src="https://image.rexking6.top/img/v2-d77c2eef01d6d9a0127f26025f77e99e_720w.jpg" alt="图2.图1的RDF图的形式表示"></p>
<p>图2中的图看起来比图1中的属性图大，因为图中的所有文字都被描述为节点。而在可视化RDF图数据时，通常不会这样做，以便使图看起来更干净和更简单。所有节点都用带有浅黄色背景的圆角矩形表示。也就是说，从数据结构的角度来看，它们是图的一部分，就像任何其他节点一样，唯一的区别是它们不能作为源节点，只能是目标节点或宾语。RDF图中的文字值可以有数据类型，数据类型取自XML模式（如xsd:string、xsd:integer等），文本值也可以有语言标记来支持数据国际化。例如，对于纽约市的rdfs:label，我们可以有多个值，例如：“New York City”xsd:string @en 或 “NuevaYork”xsd:string @sp。标识符也是RDF图的一个非常重要的概念。每个非文字节点都被分配一个标识符——通常是一个URI（Uniform Resource Identifier，统一资源标识符）或IRI（Internationalized Resource Identifiers，国际化资源标识符）。本地非URI标识符因为不能互操作而很少使用。而全局唯一标识符为图数据模型带来了许多好处，同时基于RDFbased的解决方案可以根据选定的URI构造规则自动生成URI。另外，在添加数据（例如加载序列化的文件）时，用户也可以提供他们想要使用的URI。标识节点的URI使用限定名（通常称为Qname表示法）显示在图中，如图2中的 rdf 就表示着：<a target="_blank" rel="noopener" href="http://w3.org/1999/02/22-rdf-syntax-ns#，而对应的也可以使用命名空间中的内置资源定义的语义，如rdf:type">http://w3.org/1999/02/22-rdf-syntax-ns#，而对应的也可以使用命名空间中的内置资源定义的语义，如rdf:type</a>. 而使用URI最大的好处之一便是可以如果不同的节点具有同样的URI，就会自动地合并，这也就使得RDF图更加简洁清晰。</p>
<blockquote>
<p>具体说一下IRI，URI，URL和URN这几个术语的区别：</p>
<ul>
<li>URI：<strong>统一资源标识符</strong>，字符集被限制为US-ASCII（英文字符），通过指定唯一名称来标识资源；</li>
<li>IRI：<strong>国际化资源标识符</strong>（Internationalized Resource Identifier），定义与URI相同，只是将字符集扩展到通用字符集（包含了非英文字符），所以它是URI的超集，同样唯一标识了一个资源；</li>
<li>URN：<strong>统一资源名称</strong>（Uniform Resource Name），由命名空间标识符（NID）和命名空间特定字符串（NSS）组成；</li>
<li>URL：<strong>统一资源定位符</strong>，即我们通常提到的网址，通常指的是不包含URN的URI子集。</li>
</ul>
<p>以及它们的<strong>集合包含关系</strong>：</p>
<ul>
<li>IRI ⊃ URI</li>
<li>URI ⊃ URL</li>
<li>URI ⊃ URN</li>
<li>URL ∩ URN = ∅</li>
</ul>
</blockquote>
<h4 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h4><p>RDF是以一种建模的方式来描述数据语义，不受具体语法表示的限制，序列化的方式有多种。数据序列化就是将对象或者转化成特定的格式，使其可在网络中传输，或者存储在文件中。</p>
<p>序列化RDF数据的方法主要有这几种：RDF/XML，N-Triples，Turtle，RDFa，JSON-LD。其中Turtle 是使用最广泛的RDF序列化方式，其<strong>格式紧凑，易于阅读</strong>。Turtle使用 @prefix 对RDF的URI前缀进行缩写，<strong>rdf:</strong>表示<strong>URI前缀</strong> <a target="_blank" rel="noopener" href="http://www.w3.org/1999/02/22-rdf-syntax-ns#，因此**rdf:type**就是http://www.w3.org/1999/02/22-rdf-syntax-ns#type的简写。">http://www.w3.org/1999/02/22-rdf-syntax-ns#，因此**rdf:type**就是http://www.w3.org/1999/02/22-rdf-syntax-ns#type的简写。</a></p>
<h3 id="二者的比较与转化"><a href="#二者的比较与转化" class="headerlink" title="二者的比较与转化"></a>二者的比较与转化</h3><h4 id="1-在表达的术语和能力上的不同"><a href="#1-在表达的术语和能力上的不同" class="headerlink" title="1. 在表达的术语和能力上的不同"></a>1. 在表达的术语和能力上的不同</h4><p>主要从标签（Labels）、类型（Types）和属性（Properties）三个关键概念上进行比较。</p>
<ol>
<li><p>标签（Labels）</p>
<ul>
<li>在RDF图中，标签是在RDFS命名空间即rdfs:label中定义出的标准谓词，用于指向任何资源的显示名称的值。尽管也可以使用另一个谓词来实现此目的，但是rdfs:label被广泛接受为属性的惟一标识符。</li>
<li>在属性图中，标签用于标识节点的类型。它被称为标签而不是类型，因为它只是一个字符串或一个文本标记，在文本之外没有任何意义，且在图中不能捕捉到关于它的任何信息。</li>
</ul>
</li>
<li><p>类型（Types）</p>
<ul>
<li>在RDF图中，节点的类型或属性的类型是资源，即通常在图中存在另一个节点带有与其关联的附加信息，以定义其预期的用途和语义。节点使用rdf:type来链接到它的类型。</li>
<li>在属性图中，属性中的边具有标识类型的标签。它被称为“类型”或“关系类型”。常被用于查询关系匹配，当图可视化显示时，它也作为边的显示名称。</li>
</ul>
</li>
</ol>
<p><img src="https://image.rexking6.top/img/v2-80432321be09b120760fb80da3e32e1f_720w.jpg" alt="图3.图2的一部分，扩展了类型和标签信息"></p>
<p>上述图3是图2中RDF图的一部分，其中节点或边周围的绿色边框表示描述数据模型的图元素。在RDF中和在属性图中一样，节点可以属于多个集合。如图中的汤姆·汉克斯既是导演也是演员。但如果一个类是另一个类的子类，则不需要在RDF中指定“父类型”。这些信息是在类级别为属于类的所有资源提供的，因为类信息也是RDF图的一部分。如我们不会在Tom Hanks增加一个类型是人，因为导演和演员本身都是人的“子类型”。在RDF图中，我们还可以捕获关于存储在图中的数据模型的任何信息。而这些信息的存储、访问和处理方式与其他数据完全相同。如图3我们给谓语ex:actedIn增加了一个标签，事实上，我们也可以定义当关系ex:actedIn用于在相反方向（从电影到演员）时，关系的显示名称显示为actors。在RDF图中，在一个语句中用作谓词的资源可以在另一个语句中用作主语或宾语。这也体现出RDF图额外的灵活性，它允许我们存储关于谓词及其用法的信息。这一点也是属性图无法比拟的。</p>
<ol>
<li><p>属性（Properties）</p>
<ul>
<li><p>在RDF图中，边也可称为属性（谓词），和属性指向的对象可以称为属性值，而所有属性值（文字或URI）都存储为节点。如图2中，ex:125到“The Post”有一条边，边为rdfs:label，在这个例子中，rdfs:label就是一个属性，而“The Post”是一个属性值。</p>
</li>
<li><p>在属性图中，属性只能有文字值。它们的存储和处理的方式与图中的节点不同。用数据建模的术语来说，就是属性图中的属性永远只能是属性。属性结构是键-值对的结构。这意味着属性键只能有一个值，如果它有多个值，则需要将单个值转换为一个由逗号分隔的值组成的数组（如图4所示）。而这也为查询带来了弊端，如查询所有人口数超过58000的城市，而图4中数组第一项表示2018年的人口，第二项表示2010年的人口，在属性图中是无法进行很好地区分。这也是属性图和知识图谱的一个很大的区别：如何从属性值中提取出额外的信息。</p>
<p><img src="https://image.rexking6.top/img/image-20210803234709591.png" alt="图4.属性图中多值用数组表示"></p>
</li>
</ul>
</li>
</ol>
<h4 id="2-在边上附加信息的差异"><a href="#2-在边上附加信息的差异" class="headerlink" title="2. 在边上附加信息的差异"></a>2. 在边上附加信息的差异</h4><ul>
<li><p>在属性图中，不同的两条边可以有相同的类型，但不同的特征。如图1中的两个不同id的ACTED_IN边，分别表示Tom Hanks和Sarah Paulson参演了电影The Post。在属性图数据模型中，边唯一地标识源点-边-目标节点组合。</p>
</li>
<li><p>在RDF中，相同类型的边都是相同的，边会被重复使用。这意味着，如果需要增加一些关于Tom Hanks和电影The Post的关系Post（例如，他在电影中扮演的角色），你不能简单地在ex:actedIn里增添一个属性，因为这样的话会在所有的参演这一谓词中增添相同的属性。为了支持在两个特定节点之间的边上附加信息的需要，RDF提供了一种方法来创建一个新的节点来唯一标识源点-边-目标节点三元组。我们就可以使用常规方法对新节点创建语句——它可以是任何语句的主语或宾语。如图5所示，我们在其中创建了一个新节点ex:126来表示语句，Tom Hanks在The Post中的表演，而扮演角色之类关于这个演出的信息都存储在ex:126引出的边中。</p>
<p><img src="https://image.rexking6.top/img/image-20210803235853644.png" alt="图5.RDF图中用新节点ex:126来唯一标识新的语句"></p>
</li>
</ul>
<p>相较于属性图，RDF增加边的方式更加方便且强大，因为能够支持以下两点：</p>
<ol>
<li>在边中添加与其他边的关系，如图5中增添扮演的角色Ben Bradlee，而这在属性图中，如果不改变原先的图是无法做到的。</li>
<li>向任何属性添加更多信息，而不仅仅是关系。这对于属性图也是不可能的。</li>
</ol>
<p><img src="https://image.rexking6.top/img/v2-32854710d80ca7cd216691e2a51066ca_720w.jpg" alt="图6.属性图中增添新的节点来与Ben Bradlee产生联系"></p>
<p>而在属性图中，想要实现上面两个功能。对于第1点，常用的做法是像图6那样增添一个新的节点130，这需要重新构造图并更改所有查询和逻辑，因为演员和电影之间的路径现在不同。对于2，属性图的解决方案是改变图的结构，把一个属性变成一个边，一个值变成一个节点。而这需要重新构造一个图，并更改其处理的所有查询和逻辑，因为属性图的存储和访问与图遍历完全不同，并且是独立的。这使得属性图的可演化性和灵活性不如RDF图。正如上述分析的结果，与RDF图相比，属性图的灵活性更弱，扩展或者根据要求进行更改也更加困难。</p>
<h4 id="3-图分析算法与图的划分"><a href="#3-图分析算法与图的划分" class="headerlink" title="3. 图分析算法与图的划分"></a>3. 图分析算法与图的划分</h4><p>图分析算法是属性图的关键应用，是指节点中心性、节点相似性、最短路径、聚类等算法。属性图以提供这些算法而闻名，且有许多应用都依赖于这些算法。话虽如此，属性图数据模型中没有任何特殊之处使这些算法成为可能，它们同样可以很好地应用于RDF图，事实上许多基于RDF的解决方案也提供类似的算法。关系数据库使用表和视图对数据进行划分。属性图和RDF图均允许用户限定特定类型的节点集。例如，一个查询可以被限制为只与参与者或只与导演一起工作。这提供了一个非常基本的、有限的分区。RDF数据也可以被划分称为命名图，命名图为我们提供了一种方法来说明三元组语句构成子图。然后我们可以给它一个唯一的标识名称，并将我们认为重要的其他信息与之关联，这种思想也与关系数据库中的视图相类似。</p>
<h4 id="4-属性图的局限性"><a href="#4-属性图的局限性" class="headerlink" title="4. 属性图的局限性"></a>4. 属性图的局限性</h4><p>在属性图的应用中，以下的需求是常见的但是却难以满足：</p>
<ul>
<li>支持对图中模式的捕获</li>
<li>支持验证和数据完整性</li>
<li>支持捕捉丰富的规则</li>
<li>支持继承和推理</li>
<li>支持全局唯一标识符</li>
<li>支持可替换的标识符</li>
<li>图之间的连通性</li>
<li>图形可进化性的更好解决方案</li>
</ul>
<p>这些是属性图设计中没有解决的基本限制，原则上，在属性图中添加其中一些这样的功能是可能的——但实现起来并不容易或便捷。</p>
<h4 id="5-RDF图与属性图到知识图谱之间的转化"><a href="#5-RDF图与属性图到知识图谱之间的转化" class="headerlink" title="5. RDF图与属性图到知识图谱之间的转化"></a>5. RDF图与属性图到知识图谱之间的转化</h4><ul>
<li>固有的语义使RDF图到知识图谱的转化很容易：正如前几节的内容，基于RDF的图捕获的信息不仅仅是数据，还有数据的含义或语义，这其中包括丰富的约束和高度表达的规则。所有的信息都存储在一个图中，可供查询和任何其他算法，以帮助我们推理和发现基于现有知识的新知识。也满足分离但可连接这一知识图谱的关键特性。</li>
<li>很容易从属性图转化成一个RDF标准序列化。事实上，Neo4J提供了这样一个库。你可以很容易地得到数据，但你不能得到数据的语义，这是因为数据模型只存在于最初的设计草图中。此外，正如我们所讨论的，图数据的结构可能会受到属性图数据模型的特定限制和由于属性图数据库的体系结构而需要的优化的影响。因此最简单的方法是按原样导出属性图数据，然后用RDF创建表示数据结构的数据模型。</li>
</ul>
<h1 id="查询语言"><a href="#查询语言" class="headerlink" title="查询语言"></a>查询语言</h1><h2 id="nGQL"><a href="#nGQL" class="headerlink" title="nGQL"></a>nGQL</h2><p><a target="_blank" rel="noopener" href="https://github.com/vesoft-inc/nebula/blob/master/docs/manual-CN/1.overview/1.concepts/2.nGQL-overview.md">nGQL</a> 是一种类 SQL 的声明型的文本查询语言，nGQL 同样是关键词大小写不敏感的查询语言，目前支持模式匹配、聚合运算、图计算，可无嵌入组合语句。它支持图数据库：Nebula Graph。</p>
<h2 id="Cypher"><a href="#Cypher" class="headerlink" title="Cypher"></a>Cypher</h2><p>Cypher 是一个描述性的图形查询语言，允许不必编写图形结构的遍历代码对图形存储有表现力和效率的查询，和 SQL 很相似，Cypher 语言的关键字不区分大小写，但是属性值，标签，关系类型和变量是区分大小写的。</p>
<p>Cypher还在继续发展和成熟，这也就意味着有可能会出现语法的变化。同时也意味着作为组件没有经历严格的性能测试。Cypher设计的目的是一个人类查询语言，适合于开发者和在数据库上做点对点模式（ad-hoc）查询的专业操作人员（我认为这个很重要）。它的构念是基于英语单词和灵巧的图解。Cyper通过一系列不同的方法和建立于确定的实践为表达查询而激发的。许多关键字如like和order by是受SQL的启发。模式匹配的表达式来自于SPARQL。正则表达式匹配实现实用Scala programming language语言。</p>
<p>它支持图数据库： Neo4j、RedisGraph、AgensGraph。</p>
<h2 id="Gremlin"><a href="#Gremlin" class="headerlink" title="Gremlin"></a>Gremlin</h2><p>Gremlin 是 Apache ThinkerPop 框架下的图遍历语言。Gremlin 可以是声明性的也可以是命令性的。虽然 Gremlin 是基于 Groovy 的，但具有许多语言变体，允许开发人员以 Java、JavaScript、Python、Scala、Clojure 和 Groovy 等许多现代编程语言原生编写 Gremlin 查询。它支持图数据库：Janus Graph、InfiniteGraph、Cosmos DB、DataStax Enterprise(5.0+) 、Amazon Neptune。</p>
<p>对于一般查询，Cypher 就足够了，而且速度可能更快。Gremlin 相对于 Cypher 的优势在于当进入高级遍历时。在 Gremlin 中，您可以更好地定义精确的遍历模式（或自己的算法），而在 Cypher 中，引擎会尝试自行寻找最佳遍历解决方案。</p>
<h3 id="图基本概念"><a href="#图基本概念" class="headerlink" title="图基本概念"></a>图基本概念</h3><ul>
<li>图Graph：指关系图。比如：同学及朋友关系图、银行转账图等。</li>
<li>顶点Vertex：一般指实体。比如：人、账户等。</li>
<li>边Edge：一般指关系。比如：朋友关系、转账动作等。</li>
<li>属性Property：顶点或边可以包含属性，比如：人的姓名、人的年龄、转账的时间。</li>
</ul>
<p>下面使用一个例子来进一步理解上面的概念。如下图片展示了一个“软件、人”之间的关系图。</p>
<p><img src="https://image.rexking6.top/img/20180907195136475" alt=""></p>
<p>其中：</p>
<ul>
<li>包括4个顶点：3个“人”顶点、一个“软件HugeGraph”顶点。</li>
<li>包括5条边：3条“创建created”边、2条“认识knows”边。</li>
<li>包括若干属性：如“HugeGraph”顶点包括“名称name”、“标签tag”、“语言lang”等属性，一个属性由</li>
<li>性名和属性值组成，如“lang:java”。</li>
</ul>
<p>此外：</p>
<ul>
<li>顶点与边有类别之分，如“HugeGraph”顶点的label是“software”、3个“人”顶点的label是“person”，在Gremlin里面称之为“label”。</li>
<li>顶点与边均由id来唯一标识，Gremlin里顶点与边必须包括id，一般图数据库的顶点id或边id均由系统自动生成。</li>
</ul>
<h3 id="图基本操作"><a href="#图基本操作" class="headerlink" title="图基本操作"></a>图基本操作</h3><p>对图基本概念有了初步了解之后，我们接下来学习如何使用Gremlin去操作它。首先准备好一些数据，这里以搭建环境文章中的<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/618cf6667381">TinkerPop关系图</a>为例。下面将要学习的Gremlin Steps包括：<code>V()</code>、<code>E()</code>、<code>id()</code>、<code>label()</code>、<code>properties()</code>、<code>valueMap()</code>、<code>values()</code>。</p>
<ol>
<li><p><code>V()</code>：查询顶点，一般作为图查询的第1步，后面可以续接的语句种类繁多（后续会一一讲解）。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 查询图中所有的顶点</span><br><span class="line">// 注意：g 代表的是整个图</span><br><span class="line">// 一切查询都是以图开始</span><br><span class="line">g.V()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180907195822566" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 根据id查询顶点</span><br><span class="line">g.V(&#x27;4:Gremlin&#x27;, &#x27;3:TinkerPop&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180907195854615" alt=""></p>
<p>请尝试执行语句<code>g.V(&#39;4:Gremlin&#39;).in(&#39;supports&#39;)</code> —— 查询支持Gremlin语言的所有图数据库。</p>
</li>
<li><p><code>E()</code>：查询边，一般作为图查询的第1步，后面可以续接的语句种类繁多。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询图中所有的边</span><br><span class="line">g.E()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180907195930730" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 根据id查询边</span><br><span class="line">g.E(&#x27;S3:TinkerPop&gt;4&gt;&gt;S4:Gremlin&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180907195950993" alt=""></p>
</li>
<li><p><code>id()</code>：获取顶点、边的id。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询所有顶点的id</span><br><span class="line">g.V().id()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180907200018876" alt=""></p>
<p>类似的，通过<code>g.E().id()</code>查询所有边的id。注意：Gremlin Step是作用在上一步产生的结果集上，如果上一步的结果是多个元素，那么这里<code>id()</code>将返回多个元素的id。</p>
</li>
<li><p><code>label()</code>：获取顶点、边的label。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询所有顶点的label</span><br><span class="line">g.V().label()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180907200047417" alt=""></p>
<p>类似的，通过<code>g.E().label()</code>查询所有边的label。</p>
</li>
<li><p><code>properties()</code>：获取顶点、边的属性。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询所有顶点的属性</span><br><span class="line">g.V().properties()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 查询所有顶点的“lang”属性</span><br><span class="line">// 如果无“lang”属性的顶点将跳过</span><br><span class="line">g.V().properties(&#x27;lang&#x27;)</span><br></pre></td></tr></table></figure>
<p>类似地，通过<code>g.E().properties()</code>查询所有边的属性。</p>
<p>此外 <code>properties()</code>还可以和 <code>key()</code>、<code>value()</code>搭配使用，以获取属性的名称或值。</p>
<p>示例 <code>key()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询所有顶点的属性名称</span><br><span class="line">g.V().properties().key()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180907200118210" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询所有顶点的属性值</span><br><span class="line">g.V().properties().value()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180907200136225" alt=""></p>
</li>
<li><p><code>valueMap()</code>：获取顶点、边的属性， <code>valueMap()</code>与 <code>properties()</code>不同的地方是：它们返回的结构不一样，后者将所有的属性扁平化到一个大列表里面，一个元素代表一个属性；前者保持一个顶点或一条边的属性作为一组，每一组由若干属性的键值对组成。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询所有顶点的属性</span><br><span class="line">g.V().valueMap()</span><br></pre></td></tr></table></figure>
<p>类似的，通过<code>g.E().valueMap()</code>查询所有边的属性。</p>
</li>
<li><p><code>values()</code>：获取顶点、边的属性值。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 查询所有顶点的属性值</span><br><span class="line">// 效果等同于：</span><br><span class="line">// g.V().properties().value()</span><br><span class="line">g.V().values()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180907200155515" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 查询所有顶点的“lang”属性</span><br><span class="line">// 效果等同于：</span><br><span class="line">// g.V().properties(&#x27;lang&#x27;).value()</span><br><span class="line">g.V().values(&#x27;lang&#x27;)</span><br></pre></td></tr></table></figure>
<p>类似地，通过<code>g.E().values()</code>查询所有边的属性值。</p>
</li>
</ol>
<h3 id="边遍历概念"><a href="#边遍历概念" class="headerlink" title="边遍历概念"></a>边遍历概念</h3><p>边遍历是指通过顶点来访问与其有关联边的邻接顶点（或者仅访问邻接边），边遍历是图数据库与图计算的核心。我们先以<a target="_blank" rel="noopener" href="http://tinkerpop.apache.org/docs/current/reference/#vertex-steps">TinkerPop官网</a>的例子来解释一下边遍历的相关Steps：</p>
<p><img src="https://image.rexking6.top/img/2018091116052712" alt=""></p>
<p>顶点为基准的Steps（如上图中的顶点“4”）：</p>
<ul>
<li><code>out(label)</code>: 根据指定的EdgeLabel来访问顶点的OUT方向邻接点（可以是零个EdgeLabel，代表所有类型边；也可以一个或多个EdgeLabel，代表任意给定EdgeLabel的边，下同）</li>
<li><code>in(label)</code>: 根据指定的EdgeLabel来访问顶点的IN方向邻接点</li>
<li><code>both(label)</code>: 根据指定的EdgeLabel来访问顶点的双向邻接点</li>
<li><code>outE(label)</code>: 根据指定的EdgeLabel来访问顶点的OUT方向邻接边</li>
<li><code>inE(label)</code>: 根据指定的EdgeLabel来访问顶点的IN方向邻接边</li>
<li><code>bothE(label)</code>: 根据指定的EdgeLabel来访问顶点的双向邻接边</li>
</ul>
<p>边为基准的Steps（如上图中的边“knows”）：</p>
<ul>
<li><code>outV()</code>: 访问边的出顶点（注意：这里是以边为基准，上述Step均以顶点为基准），出顶点是指边的起始顶点</li>
<li><code>inV()</code>: 访问边的入顶点，入顶点是指边的目标顶点，也就是箭头指向的顶点</li>
<li><code>bothV()</code>: 访问边的双向顶点</li>
<li><code>otherV()</code>: 访问边的伙伴顶点，即相对于基准顶点而言的另一端的顶点</li>
</ul>
<h4 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h4><p>下面通过实例来深入理解每一个操作。</p>
<ol>
<li><p><code>out()</code>：访问顶点的OUT方向邻接点</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 先查询图中所有的顶点</span><br><span class="line">// 然后访问顶点的OUT方向邻接点</span><br><span class="line">// 注意：out()的基准必须是顶点</span><br><span class="line">g.V().out()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911160639743" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的OUT方向邻接点</span><br><span class="line">// 注意&#x27;3:TinkerPop&#x27;是顶点的id</span><br><span class="line">// 该id是插入顶点时自动生成的</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).out()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911160753461" alt=""></p>
<p>目前讲解过的Gremlin Steps中，顶点的id可通过<code>g.V()</code>来获取，也可通过即将讲解的<code>has()</code>来获取（根据属性查询顶点）。</p>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的OUT方向邻接点</span><br><span class="line">// 且限制仅“define”类型的边相连的顶点</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).out(&#x27;define&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911160856516" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">动手比一比：</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).out()</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).out(&#x27;define&#x27;, &#x27;contains&#x27;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>in()</code>：访问顶点的IN方向邻接点</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的IN方向邻接点</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).in()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911160939434" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的IN方向邻接点</span><br><span class="line">// 且限制了关联边的类型</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).in(&#x27;implements&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911161012374" alt=""></p>
</li>
<li><p><code>both()</code>：访问顶点的双向邻接点</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的双向邻接点</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).both()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911161034710" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的双向邻接点</span><br><span class="line">// 且限制了关联边的类型</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).both(&#x27;implements&#x27;, &#x27;define&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911161101540" alt=""></p>
</li>
<li><p><code>outE()</code>: 访问顶点的OUT方向邻接边</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的OUT方向邻接边</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).outE()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911161124284" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的OUT方向邻接边</span><br><span class="line">// 且限制了关联边的类型</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).outE(&#x27;define&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911161149939" alt=""></p>
</li>
<li><p><code>inE()</code>: 访问顶点的IN方向邻接边</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的IN方向邻接边</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).inE()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911161210422" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的IN方向邻接边</span><br><span class="line">// 且限制了关联边的类型</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).inE(&#x27;implements&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911161241934" alt=""></p>
</li>
<li><p><code>bothE()</code>: 访问顶点的双向邻接边</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的双向邻接边</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).bothE()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911161303128" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的双向邻接边</span><br><span class="line">// 且限制了关联边的类型</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).bothE(&#x27;define&#x27;, &#x27;implements&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911161325589" alt=""></p>
</li>
<li><p><code>outV()</code>: 访问边的出顶点</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的IN邻接边</span><br><span class="line">// 然后获取边的出顶点</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).inE().outV()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911161937302" alt=""></p>
<p>一般情况下，<code>inE().outV()</code>等价于<code>in()</code></p>
<p>动手试一试：<code>g.V(&#39;3:TinkerPop&#39;).outE().outV()</code></p>
</li>
<li><p><code>inV()</code>: 访问边的入顶点</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的OUT邻接边</span><br><span class="line">// 然后获取边的入顶点</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).outE().inV()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911162005804" alt=""></p>
<p>一般情况下，<code>outE().inV()</code>等价于<code>out()</code></p>
<p>动手试一试：<code>g.V(&#39;3:TinkerPop&#39;).inE().inV()</code></p>
</li>
<li><p><code>bothV()</code>: 访问边的双向顶点</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的OUT邻接边</span><br><span class="line">// 然后获取边的双向顶点</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).outE().bothV()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911162032342" alt=""></p>
<p>注意：<code>bothV()</code>会把源顶点也一起返回，因此只要源顶点有多少条出边，结果集中就会出现多少次源顶点</p>
</li>
<li><p><code>otherV()</code> : 访问边的伙伴顶点</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的OUT邻接边</span><br><span class="line">// 然后获取边的伙伴顶点</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).outE().otherV()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911162058307" alt=""></p>
<p>一般情况下，<code>outE().otherV()</code>等价于<code>out()</code>，<code>inE().otherV()</code>等价于<code>in()</code>。</p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的双向邻接边</span><br><span class="line">// 然后获取边的伙伴顶点</span><br><span class="line">g.V(&#x27;3:TinkerPop&#x27;).bothE().otherV()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911162117651" alt=""></p>
<p>一般情况下，<code>bothE().otherV()</code>等价于<code>both()</code>。</p>
</li>
</ol>
<h4 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h4><ol>
<li><p>多度查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 4度out()查询</span><br><span class="line">// 通过id找到“javeme”作者顶点</span><br><span class="line">// 通过out()访问其创建的软件</span><br><span class="line">// 继续通过out()访问软件实现的框架</span><br><span class="line">// 继续通过out()访问框架包含的软件</span><br><span class="line">// 继续通过out()访问软件支持的语言</span><br><span class="line">g.V(&#x27;javeme&#x27;).out(&#x27;created&#x27;).out(&#x27;implements&#x27;).out(&#x27;contains&#x27;).out(&#x27;supports&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911162138124" alt=""></p>
</li>
<li><p>查询支持Gremlin语言的软件的作者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通过id找到“Gremlin”语言顶点</span><br><span class="line">// 通过in()访问支持Gremlin的软件</span><br><span class="line">// 继续通过in()访问软件的作者</span><br><span class="line">g.V(&#x27;4:Gremlin&#x27;).in(&#x27;supports&#x27;).in(&#x27;created&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911162157182" alt=""></p>
</li>
<li><p>查询某个作者的共同作者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通过id找到“javeme”作者顶点</span><br><span class="line">// 通过out()访问其创建的软件</span><br><span class="line">// 通过in()访问软件的所有作者</span><br><span class="line">g.V(&#x27;javeme&#x27;).out(&#x27;created&#x27;).in(&#x27;created&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180911162214700" alt=""></p>
</li>
</ol>
<h3 id="Has-Step说明"><a href="#Has-Step说明" class="headerlink" title="Has Step说明"></a>Has Step说明</h3><p>在众多Gremlin的语句中，有一大类是filter类型，顾名思义，就是对输入的对象进行条件判断，只有满足过滤条件的对象才可以通过filter进入下一步。</p>
<p>has语句是filter类型语句的代表，能够以顶点和边的属性作为过滤条件，决定哪些对象可以通过。has语句包括很多变种：</p>
<ul>
<li><code>hasLabel(labels…)</code>: object的label与labels列表中任何一个匹配就可以通过</li>
<li><code>hasId(ids…)</code>: object的id满足ids列表中的任何一个就可以通过</li>
<li><code>has(key, value)</code>: 包含属性“key=value”的object通过，作用于顶点或者边</li>
<li><code>has(label, key, value)</code>: 包含属性“key=value”且label值匹配的object通过，作用于顶点或者边</li>
<li><code>has(key, predicate)</code>: 包含键为key且对应的value满足predicate的object通过，作用于顶点或者边</li>
<li><code>hasKey(keys…)</code>: object的属性键包含所有的keys列表成员才能通过，作用于顶点属性</li>
<li><code>hasValue(values…)</code>: object的属性值包含所有的values列表成员才能通过，作用于顶点属性</li>
<li><code>has(key)</code>: 包含键为key的属性的object通过，作用于顶点或者边</li>
<li><code>hasNot(key)</code>: 不包含键为key的属性的object通过，作用于顶点或者边</li>
</ul>
<blockquote>
<p>TinkerPop规范中，也可以对Vertex Property进行has()操作，前提是图支持meta-property。HugeGraph不支持meta-property，因此本文不会有Vertex Property相关的has()示例。</p>
</blockquote>
<h4 id="实例讲解-1"><a href="#实例讲解-1" class="headerlink" title="实例讲解"></a>实例讲解</h4><p>在HugeGraph中，按property的值查询之前，应该对property建立索引，否则将无法查到结果并引发异常。（有两个例外，Vertex的PrimaryKeys和Edge的SortKeys，具体参见<a target="_blank" rel="noopener" href="https://hugegraph.github.io/hugegraph-doc/">HugeGraph官网</a>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 对‘person’的‘addr’属性建立secondary索引，可以对Text类型property按值进行查询</span><br><span class="line">graph.schema().indexLabel(&#x27;personByCity&#x27;).onV(&#x27;person&#x27;).by(&#x27;addr&#x27;).secondary().ifNotExist().create()</span><br><span class="line">// 对‘person’的‘age’属性建立range索引，可以对Number类型property进行范围查询</span><br><span class="line">graph.schema().indexLabel(&#x27;personByAge&#x27;).onV(&#x27;person&#x27;).by(&#x27;age&#x27;).range().ifNotExist().create()</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>hasLabel(label...)</code>，通过label来过滤顶点或边，满足label列表中一个即可通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询label为&quot;person&quot;的顶点</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180910155848821" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询label为&quot;person&quot;或者&quot;software&quot;的顶点</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;, &#x27;software&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180910174337986" alt=""></p>
</li>
<li><p><code>hasId(ids…)</code>，通过id来过滤顶点或者边，满足id列表中的一个即可通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询id为&quot;zhoney&quot;的顶点</span><br><span class="line">g.V().hasId(&#x27;zhoney&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/2018091017495537" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询id为“zhoney”或者“3:HugeGraph”的顶点</span><br><span class="line">g.V().hasId(&#x27;zhoney&#x27;, &#x27;3:HugeGraph&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180910175004443" alt=""></p>
</li>
<li><p><code>has(key, value)</code>，通过属性的名字和值来过滤顶点或边</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询“addr”属性值为“Beijing”的顶点</span><br><span class="line">g.V().has(&#x27;addr&#x27;, &#x27;Beijing&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180910153804741" alt=""></p>
</li>
<li><p><code>has(label, key, value)</code>，通过label和属性的名字和值过滤顶点和边</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询label为“person”且“addr”属性值为“Beijing”的顶点</span><br><span class="line">g.V().has(&#x27;person&#x27;, &#x27;addr&#x27;, &#x27;Beijing&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180910175417697" alt=""></p>
</li>
<li><p><code>has(key, predicate)</code>，通过对指定属性用条件过滤顶点和边</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询“addr”属性值为“Beijing”的顶点</span><br><span class="line">g.V().has(&#x27;age&#x27;, gt(20))</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180910180633892" alt=""></p>
</li>
<li><p><code>hasKey(keys…)</code>: properties包含所有的key才能通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询包含属性“lang”的顶点</span><br><span class="line">g.V().properties().hasKey(&#x27;lang&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20191111211350679.png" alt=""></p>
<p>特殊用法：直接将<code>hasKey()</code>作用于顶点，仅后端是<code>Cassandra</code>时支持</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询包含属性“age”的顶点</span><br><span class="line">g.V().hasKey(&#x27;age&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180910201234876" alt=""></p>
<p>HugeGraph目前不支持<code>hasKey()</code>传递多个key。</p>
</li>
<li><p><code>hasValue(values…)</code>: properties包含所有的value才能通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询包含属性值“Beijing”的顶点</span><br><span class="line">g.V().properties().hasValue(&#x27;Beijing&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20191111211639873.png" alt=""></p>
<p>特殊用法：直接将<code>hasValue()</code>作用于顶点，仅后端是<code>Cassandra</code>时支持</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询包含属性值“Beijing”的顶点</span><br><span class="line">g.V().hasValue(&#x27;Beijing&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180910201600266" alt=""></p>
</li>
<li><p><code>has(key)</code>: 有这个属性的通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询包含属性“age”的顶点</span><br><span class="line">g.V().has(&#x27;age&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180910201912889" alt=""></p>
</li>
<li><p><code>hasNot(key)</code>: 没有这个属性的通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询没有属性“age”的顶点</span><br><span class="line">g.V().hasNot(&#x27;age&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180910202409370" alt=""></p>
<p>由于<code>has()</code>语句对Vertex和Edge的用法一样，本文仅给出了Vertex的示例。Edge的大家可以自行尝试。</p>
</li>
</ol>
<h3 id="图查询返回结果数限制"><a href="#图查询返回结果数限制" class="headerlink" title="图查询返回结果数限制"></a>图查询返回结果数限制</h3><p><img src="https://image.rexking6.top/img/20180911104946543" alt=""></p>
<p>Gremlin能统计查询结果集中元素的个数，且允许从结果集中做范围截取。假设某个查询操作（如：<code>g.V()</code>）的结果集包含8个元素，我们可以从这8个元素中截取指定部分。主要包括：</p>
<ul>
<li><code>count()</code>: 统计查询结果集中元素的个数；</li>
<li><code>range(m, n)</code>: 指定下界和上界的截取，左闭右开。比如range(2, 5)能获取第2个到第4个元素（0作为首个元素，上界为-1时表示剩余全部）；</li>
<li><code>limit(n)</code>: 下界固定为0，指定上界的截取，等效于range(0, n)，语义是“获取前n个元素”。比如limit(3)能获取前3个元素；</li>
<li><code>tail(n)</code>: 上界固定为-1，指定下界的截取，等效于range(count - n, -1)，语义是“获取后n个元素”。比如tail(2)能获取最后的2个元素；</li>
<li><code>skip(n)</code>: 上界固定为-1，指定下界的截取，等效于range(n, -1)，语义是“跳过前n个元素，获取剩余的元素”。比如skip(6)能跳过前6个元素，获取最后2个元素。</li>
</ul>
<h4 id="实例讲解-2"><a href="#实例讲解-2" class="headerlink" title="实例讲解"></a>实例讲解</h4><p>下面通过实例来深入理解每一个操作。</p>
<ol>
<li><p><code>count()</code>：查询当前<code>traverser</code>中的元素的个数，元素可以是顶点、边、属性、路径等。</p>
<p>示例1：查询图中所有顶点的个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.V().count()</span><br></pre></td></tr></table></figure>
<p><code>TinkerPop关系图</code>的圆点就是顶点，总共12个。</p>
<p>示例2：查询图中类型为“人person”的顶点数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(&#x27;person&#x27;).count()</span><br></pre></td></tr></table></figure>
<p><code>TinkerPop关系图</code>的绿点就是类型为“人person”的顶点，共7个。</p>
<p>示例3：查询图中所有的 “人创建created” 的边数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(&#x27;person&#x27;).outE(&#x27;created&#x27;).count()</span><br></pre></td></tr></table></figure>
<p><code>TinkerPop关系图</code>的所有从绿点(person)出发并且连线上为“created”的边，共8个。</p>
<p>示例4：查询图中所有顶点的属性数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.V().properties().count()</span><br></pre></td></tr></table></figure>
<p><code>TinkerPop关系图</code>的所有顶点的属性共47个，其中“人person”共有28个，“软件software”共有19个，大家可以自己数一数。</p>
</li>
<li><p><code>range()</code>：限定查询返回的元素的范围，上下界表示元素的偏移量，左闭右开。下界以“0”作为第一个元素，上界为“-1”时表示取到最后的元素。</p>
<p>示例1：不加限制地查询所有类型为“人person”的顶点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(&#x27;person&#x27;).range(0, -1)</span><br></pre></td></tr></table></figure>
<p>示例2：查询类型为“人person”的顶点中的第2个到第5个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(&#x27;person&#x27;).range(2, 5)</span><br></pre></td></tr></table></figure>
<p>示例3：查询类型为“人person”的顶点中的第5个到最后一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(&#x27;person&#x27;).range(5, -1)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>limit()</code>：查询前n个元素，相当于<code>range(0, n)</code></p>
<p>示例1：查询前两个顶点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.V().limit(2)</span><br></pre></td></tr></table></figure>
<p>示例2：查询前三条边</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.E().limit(3)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>tail()</code>：与<code>limit()</code>相反，它查询的是后n个元素，相当于<code>range(count - n, -1)</code></p>
<p>示例1：查询后两个顶点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.V().tail(2)</span><br></pre></td></tr></table></figure>
<p>示例2：查询后三条边</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.E().tail(3)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>skip()</code>：跳过前n个元素，获取剩余的全部元素</p>
<blockquote>
<p><code>skip()</code>在HugeGraph中（<code>tinkerpop 3.2.5</code>）中尚不支持，下面给出代码以及预期的结果。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 跳过前5个，skip(5)等价于range(5, -1)</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).skip(5)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Path说明"><a href="#Path说明" class="headerlink" title="Path说明"></a>Path说明</h3><p>在使用Gremlin对图进行分析时，关注点有时并不仅仅在最终到达的顶点、边或者属性上，通过什么样的路径到达最终的顶点、边和属性同样重要。此时可以借助path()来获取经过的路径信息。</p>
<p><code>path()</code>返回当前遍历过的所有路径。有时需要对路径进行过滤，只选择没有环路的路径或者选择包含环路的路径，Gremlin针对这种需求提供了两种过滤路径的step：<code>simplePath()</code>和<code>cyclicPath()</code>。</p>
<h4 id="实例讲解-3"><a href="#实例讲解-3" class="headerlink" title="实例讲解"></a>实例讲解</h4><ol>
<li><p><code>path()</code>，获取当前遍历过的所有路径</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// “HugeGraph”顶点到与其有直接关联的顶点的路径（仅包含顶点）</span><br><span class="line">g.V().hasLabel(&#x27;software&#x27;).has(&#x27;name&#x27;,&#x27;HugeGraph&#x27;).both().path()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914165747392" alt=""></p>
<p>示例2：<br>如果想要同时获得经过的边的信息，可以用<code>bothE().otherV()</code>替换<code>both()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// “HugeGraph”顶点到与其有直接关联的顶点的路径（包含顶点和边）</span><br><span class="line">g.V().hasLabel(&#x27;software&#x27;).has(&#x27;name&#x27;,&#x27;HugeGraph&#x27;).bothE().otherV().path()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914170410152" alt=""></p>
<p>示例3：<br>输出路径的时候，通过by(property)语句可以指定对象的某个属性代替对象，且连续的多个by()是循环应用到路径中的对象，例如路径中有3个对象[A, B, C]，<code>by(X).by(Y)</code>语句指定两个属性[X Y]，代表用“用A的X属性代表A，用B的Y属性代表B，用C的X属性代表C”，具体可参考如下例子：</p>
<blockquote>
<p><code>by()</code>语句的用法详解可以参见<a target="_blank" rel="noopener" href="http://tinkerpop.apache.org/docs/3.3.3/reference/#by-step">TinkerPop By Step</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// “HugeGraph”顶点到与其有直接关联的顶点的路径（包含顶点和边）</span><br><span class="line">// 用“name”属性代表person和software顶点，用“weight”属性代表边</span><br><span class="line">g.V().hasLabel(&#x27;software&#x27;).has(&#x27;name&#x27;,&#x27;HugeGraph&#x27;).bothE().otherV().path().by(&#x27;name&#x27;).by(&#x27;weight&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914170703114" alt=""></p>
<p>示例4：<br>路径分为两种：有环路径和无环路径。</p>
<ul>
<li>有环路径是指路径中至少有一个对象出现的次数大于等于两次。</li>
<li>无环路径是指路径中所有的对象只出现一次。</li>
</ul>
<p><code>path()</code>返回所有路径，包含有环路径和无环路径，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// “HugeGraph”顶点到与其有两层关系的顶点的所有路径（只包含顶点）</span><br><span class="line">g.V().hasLabel(&#x27;software&#x27;).has(&#x27;name&#x27;,&#x27;HugeGraph&#x27;).both().both().path()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914171006576" alt=""></p>
<p>图中红框内的是含有环路的路径，其他的是不含有环路的路径</p>
</li>
<li><p><code>simplePath()</code>，过滤掉路径中含有环路的对象，只保留路径中不含有环路的对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// “HugeGraph”顶点到与其有两层关系的顶点的不含环路的路径（只包含顶点）</span><br><span class="line">g.V().hasLabel(&#x27;software&#x27;).has(&#x27;name&#x27;,&#x27;HugeGraph&#x27;).both().both().simplePath().path()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914171252997" alt=""></p>
</li>
<li><p><code>cyclicPath()</code>，过滤掉路径中不含有环路的对象，只保留路径中含有环路的对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// “HugeGraph”顶点到与其有两层关系的顶点的包含环路的路径（只包含顶点）</span><br><span class="line">g.V().hasLabel(&#x27;software&#x27;).has(&#x27;name&#x27;,&#x27;HugeGraph&#x27;).both().both().cyclicPath().path()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914171410556" alt=""></p>
</li>
</ol>
<h3 id="循环操作说明"><a href="#循环操作说明" class="headerlink" title="循环操作说明"></a>循环操作说明</h3><p>循环操作是指多次执行某一部分语句，用于语句需要重复运行的场景，比如“查找朋友的朋友的朋友”，可以直接使用循环操作来完成即“查找3层朋友”，下面对具体的循环相关的Step进行说明：</p>
<ul>
<li><code>repeat()</code>: 指定要重复执行的语句，如<code>repeat(out(&#39;friend&#39;))</code></li>
<li><code>times()</code>: 指定要重复执行的次数，如执行3次<code>repeat(out(&#39;friend&#39;)).times(3)</code></li>
<li><code>until()</code>: 指定循环终止的条件，如一直找到某个名字的朋友为止<code>repeat(out(&#39;friend&#39;)).until(has(&#39;name&#39;,&#39;xiaofang&#39;))</code></li>
<li><code>emit()</code>: 指定循环语句的执行过程中收集数据的条件，每一步的结果只要符合条件则被收集，不指定条件时收集所有结果</li>
<li><code>loops()</code>: 当前循环的次数，可用于控制最大循环次数等，如最多执行3次<code>repeat(out(&#39;friend&#39;)).until(loops().is(3))</code></li>
</ul>
<h4 id="实例讲解-4"><a href="#实例讲解-4" class="headerlink" title="实例讲解"></a>实例讲解</h4><p>下面通过实例来深入理解每一个操作。</p>
<ol>
<li><p><code>repeat()</code> + <code>times()</code>：按照指定的次数重复执行语句</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的OUT邻接点（1次）</span><br><span class="line">// 注意&#x27;okram&#x27;是顶点的id</span><br><span class="line">g.V(&#x27;okram&#x27;).repeat(out()).times(1)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180918163426159" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的2度双向邻接点</span><br><span class="line">// 访问第1个顶点的所有邻接点（第1层）</span><br><span class="line">// 再访问第1层结果顶点的邻接点（第2层）</span><br><span class="line">g.V(&#x27;okram&#x27;).repeat(both()).times(2)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180918163542598" alt=""></p>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 访问某个顶点的3度OUT邻接点</span><br><span class="line">// 访问第1个顶点的所有邻接点（第1层）</span><br><span class="line">// 再访问第1层结果顶点的邻接点（第2层）</span><br><span class="line">// 再访问第2层结果顶点的邻接点（第3层）</span><br><span class="line">g.V(&#x27;okram&#x27;).repeat(out()).times(3)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/2018091816362690" alt=""></p>
<p>比一比：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g.V(&#x27;okram&#x27;).out().out().out()</span><br><span class="line">g.V(&#x27;okram&#x27;).repeat(out()).times(3)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>repeat()</code> + <code>until()</code>：根据条件来重复执行语句</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查询顶点&#x27;okram&#x27;到顶点&#x27;Gremlin&#x27;之间的路径</span><br><span class="line">// 循环的终止条件是遇到名称是&#x27;Gremlin&#x27;的顶点</span><br><span class="line">g.V(&#x27;okram&#x27;)</span><br><span class="line"> .repeat(out())</span><br><span class="line"> .until(has(&#x27;name&#x27;, &#x27;Gremlin&#x27;))</span><br><span class="line"> .path()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180918163700965" alt=""></p>
<ul>
<li>注意1：这里用到了<code>path()</code>来获取经过的路径，path的讲解请参考上一期。</li>
<li>注意2：<code>until()</code>与 <code>times()</code>是互斥的，两个语句无法同时存在于同一个循环中。</li>
<li>注意3：<code>until()</code>放在<code>repeat()</code>之前或之后的顺序是会影响逻辑的，放前面表示先判断再执行，放后面表示先执行后判断。请对比如下两个语句的执行结果：<br><code>g.V(&#39;okram&#39;).repeat(out()).until(hasLabel(&#39;person&#39;)).path()</code><br><code>g.V(&#39;okram&#39;).until(hasLabel(&#39;person&#39;)).repeat(out()).path()</code></li>
</ul>
</li>
<li><p><code>repeat()</code> + <code>emit()</code>：收集执行过程中的数据</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 查询顶点&#x27;okram&#x27;的所有OUT可达点的路径</span><br><span class="line">g.V(&#x27;okram&#x27;)</span><br><span class="line"> .repeat(out())</span><br><span class="line"> .emit()</span><br><span class="line"> .path()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180919231936478" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查询顶点&#x27;okram&#x27;的所有OUT可达点的路径</span><br><span class="line">// 且必须满足是&#x27;person&#x27;类型的点</span><br><span class="line">g.V(&#x27;okram&#x27;)</span><br><span class="line"> .repeat(out())</span><br><span class="line"> .emit(hasLabel(&#x27;person&#x27;))</span><br><span class="line"> .path()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180919231958436" alt=""></p>
<p>注意：<code>emit()</code>放在<code>repeat()</code>之前或之后的顺序是会影响结果的，放前面表示先收集再执行，放后面表示先执行后收集。请对比如下两个语句的执行结果：<br><code>g.V(&#39;okram&#39;).repeat(out()).emit(hasLabel(&#39;person&#39;)).path()</code><br><code>g.V(&#39;okram&#39;).emit(hasLabel(&#39;person&#39;)).repeat(out()).path()</code><br>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 查询顶点&#x27;okram&#x27;到顶点&#x27;Gremlin&#x27;之间的路径</span><br><span class="line">// 此外还收集过程中的&#x27;person&#x27;类型的顶点</span><br><span class="line">g.V(&#x27;okram&#x27;)</span><br><span class="line"> .repeat(out())</span><br><span class="line"> .until(has(&#x27;name&#x27;, &#x27;Gremlin&#x27;))</span><br><span class="line"> .emit(hasLabel(&#x27;person&#x27;))</span><br><span class="line"> .path()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180919232044890" alt=""></p>
<p>注意：<code>emit()</code>与<code>until()</code>搭配使用时，是“或”的关系而不是“与”的关系，满足两者间任意一个即可。</p>
<p>示例4：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查询顶点&#x27;okram&#x27;的2度OUT可达点的路径</span><br><span class="line">// 此外还收集&#x27;person&#x27;类型的顶点</span><br><span class="line">g.V(&#x27;okram&#x27;)</span><br><span class="line"> .repeat(out()).times(2)</span><br><span class="line"> .emit(hasLabel(&#x27;person&#x27;))</span><br><span class="line"> .path()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180919232116289" alt=""></p>
<p>注意：<code>emit()</code>与<code>times()</code>搭配使用时，是“或”的关系而不是“与”的关系，满足两者间任意一个即可。</p>
</li>
<li><p><code>repeat()</code> + <code>loops()</code>：根据最大次数限制来重复执行语句</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 查询顶点&#x27;okram&#x27;的3度OUT可达点路径</span><br><span class="line">g.V(&#x27;okram&#x27;)</span><br><span class="line"> .repeat(out())</span><br><span class="line"> .until(loops().is(3))</span><br><span class="line"> .path()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180918164122888" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 查询顶点&#x27;okram&#x27;到顶点&#x27;Gremlin&#x27;之间的路径</span><br><span class="line">// 且之间只相差2跳的距离</span><br><span class="line">// 其中的and()是指两个条件都满足</span><br><span class="line">g.V(&#x27;okram&#x27;)</span><br><span class="line"> .repeat(out())</span><br><span class="line"> .until(has(&#x27;name&#x27;, &#x27;Gremlin&#x27;)</span><br><span class="line">        .and().loops().is(2))</span><br><span class="line"> .path()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180918164151957" alt=""></p>
</li>
</ol>
<h4 id="综合运用-1"><a href="#综合运用-1" class="headerlink" title="综合运用"></a>综合运用</h4><ol>
<li><p>查找子树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 查找从一个节点出发，到</span><br><span class="line">// 叶子节点结束的所有路径</span><br><span class="line">// 这些路径的集合为一颗子树(子图)</span><br><span class="line">g.V(&#x27;okram&#x27;)</span><br><span class="line"> .repeat(out())</span><br><span class="line"> .until(outE().count().is(0))</span><br><span class="line"> .path()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180918164216591" alt=""></p>
</li>
<li><p>查找两点之间的最短路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 已知两个顶点&#x27;okram&#x27;和&#x27;javeme&#x27;，</span><br><span class="line">// 通过任意关系来找到这两点之间的路径</span><br><span class="line">// 且限制了最大深度为3</span><br><span class="line">// 若存在那么第一条结果即是最短路径</span><br><span class="line">g.V(&#x27;okram&#x27;)</span><br><span class="line"> .repeat(bothE().otherV().simplePath())</span><br><span class="line"> .until(hasId(&#x27;javeme&#x27;).and().loops().is(lte(3)))</span><br><span class="line"> .hasId(&#x27;javeme&#x27;)</span><br><span class="line"> .path()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180918164234868" alt=""></p>
<p>注意：<code>bothE().otherV()</code>一般等价于<code>both()</code>，但是在这里有一些差别，后者仅仅返回路径中的顶点信息，前者会把路径中的边信息也返回。</p>
<p>试一试：将语句中的<code>lte(3)</code>改为<code>lte(4)</code>看看结果有什么变化</p>
</li>
</ol>
<h3 id="条件和过滤操作说明"><a href="#条件和过滤操作说明" class="headerlink" title="条件和过滤操作说明"></a>条件和过滤操作说明</h3><p>在对图进行遍历分析时，经常需要对满足一定条件的对象进行过滤。<code>where()</code>就是用来过滤遍历过程中当前阶段的对象。另一方面，<code>predicate</code>就是过滤时使用的判断条件，包括关系运算和区间判断等，只有满足判断条件的对象才能通过进入下一轮或者作为结果。</p>
<p><code>where()</code>常与<code>select()</code>或者<code>match()</code>配合使用，也可以单独使用。</p>
<p>以下是<code>predicate</code>的说明：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Predicate</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>eq(object)</td>
<td>传入的对象等于目标object?</td>
</tr>
<tr>
<td>neq(object)</td>
<td>传入的对象不等于目标object?</td>
</tr>
<tr>
<td>lt(number)</td>
<td>传入的数字小于目标number?</td>
</tr>
<tr>
<td>lte(number)</td>
<td>传入的数字小于或等于目标number?</td>
</tr>
<tr>
<td>gt(number)</td>
<td>传入的数字大于目标number?</td>
</tr>
<tr>
<td>gte(number)</td>
<td>传入的数字大于或等于目标number?</td>
</tr>
<tr>
<td>inside(low,high)</td>
<td>传入的数字大于low且小于high?</td>
</tr>
<tr>
<td>outside(low,high)</td>
<td>传入的数字小于low或者大于high?</td>
</tr>
<tr>
<td>between(low,high)</td>
<td>传入的数字大于等于low且小于high?</td>
</tr>
<tr>
<td>within(objects…)</td>
<td>传入的对象等于目标对象列表objects中的任意一个?</td>
</tr>
<tr>
<td>without(objects…)</td>
<td>传入的对象不等于目标对象列表objects中的任何一个?</td>
</tr>
</tbody>
</table>
</div>
<p>逻辑运算and()、or()或者not()作用于<code>predicate</code>会产生一个新的<code>predicate</code>。</p>
<p>在众多的Gremlin steps中，有一大类是<code>filter step</code>，通过判断是否满足<code>predicate</code>来决定对象能否通过<code>filter step</code>。<code>filter()</code>语句是<code>filter step</code>的基础，较为抽象，而更加具体的<code>where()</code>语句就是一个典型的<code>filter step</code>。</p>
<h4 id="实例讲解-5"><a href="#实例讲解-5" class="headerlink" title="实例讲解"></a>实例讲解</h4><ol>
<li><p><code>predicate</code>可以通过<code>test()</code>来获得boolean值</p>
<p>可以用<code>test()</code>测试<code>value</code>是否满足<code>predicate</code>，以下是一些例子：</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// (3 == 2)</span><br><span class="line">eq(2).test(3)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180913235659479" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// (&#x27;d&#x27; == &#x27;a&#x27; || &#x27;d&#x27; == &#x27;b&#x27; || &#x27;d&#x27; == &#x27;c&#x27;)</span><br><span class="line">within(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;).test(&#x27;d&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180920102607644" alt=""></p>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// (3 &gt; 1 &amp;&amp; 3 &lt; 4)</span><br><span class="line">inside(1,4).test(3)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180920102852111" alt=""></p>
</li>
<li><p><code>and</code>/<code>or</code>/<code>not</code>作用于<code>predicate</code>之后成为新的<code>predicate</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// not()作用于neq()，等价于eq()</span><br><span class="line">not(neq(2))</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914000007337" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// and()连接的predicate，是一个新的predicate</span><br><span class="line">within(1,2,3).and(not(eq(2))).test(3)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914000326841" alt=""></p>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// or()连接的predicate，是一个新的predicate</span><br><span class="line">inside(1,4).or(eq(5)).test(3)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914000337605" alt=""></p>
</li>
<li><p><code>where()</code>单独使用</p>
<p><code>where()</code>有三种使用方式：</p>
<ul>
<li><code>where(P)</code></li>
<li><code>where(String, P)</code></li>
<li><code>where(Traversal)</code></li>
</ul>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 查看“zhoney”的合作伙伴</span><br><span class="line">// where(P)方式</span><br><span class="line">g.V(&#x27;zhoney&#x27;).as(&#x27;a&#x27;)</span><br><span class="line"> .out(&#x27;created&#x27;).in(&#x27;created&#x27;)</span><br><span class="line"> .where(neq(&#x27;a&#x27;))</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914000917427" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 查看“zhoney”的合作伙伴</span><br><span class="line">// where(String, P)方式</span><br><span class="line">g.V(&#x27;zhoney&#x27;).as(&#x27;a&#x27;)</span><br><span class="line"> .out(&#x27;created&#x27;).in(&#x27;created&#x27;).as(&#x27;b&#x27;)</span><br><span class="line"> .where(&#x27;a&#x27;,neq(&#x27;b&#x27;))</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914002022118" alt=""></p>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// “spmallette”开发过不止一个软件的合作伙伴</span><br><span class="line">// where(Traversal)方式</span><br><span class="line">g.V(&#x27;spmallette&#x27;).out(&#x27;created&#x27;).in(&#x27;created&#x27;)</span><br><span class="line"> .where(out(&#x27;created&#x27;).count().is(gt(1)))</span><br><span class="line"> .values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914001738694" alt=""></p>
<p><code>where()</code>可以与<code>by()</code>语句配合使用，表示用<code>by(property)</code>指定的属性进行<code>predicate</code>判断，例如下面的例子。</p>
<p>示例4：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 查询”被别人认识“</span><br><span class="line">// 且认识自己的人的年龄大于自己的年龄的人</span><br><span class="line">g.V().as(&#x27;a&#x27;)</span><br><span class="line"> .out(&#x27;knows&#x27;).as(&#x27;b&#x27;)</span><br><span class="line"> .where(&#x27;a&#x27;, gt(&#x27;b&#x27;)).by(&#x27;age&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180918194211861" alt=""></p>
</li>
<li><p><code>where()</code>与<code>as()</code>+<code>select()</code>配合使用</p>
<p><code>as()</code>可以为某一阶段的对象添加标签，<code>select()</code>则可以通过标签获取对象。因此<code>as()</code>+<code>select()</code>可以在某个step处得到历史信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查看“zhoney”的合作伙伴，并将“zhoney”及其合作伙伴的名字以map输出</span><br><span class="line">// select().where()方式</span><br><span class="line">g.V(&#x27;zhoney&#x27;).as(&#x27;a&#x27;)</span><br><span class="line"> .out(&#x27;created&#x27;).in(&#x27;created&#x27;).as(&#x27;b&#x27;)</span><br><span class="line"> .select(&#x27;a&#x27;,&#x27;b&#x27;).by(&#x27;name&#x27;)</span><br><span class="line"> .where(&#x27;a&#x27;,neq(&#x27;b&#x27;))</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914002800566" alt=""></p>
</li>
<li><p><code>where()</code>与<code>match()</code>配合使用</p>
<p><code>match()</code>可以保证满足某种模式的对象通过。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查看“zhoney”的合作伙伴，并将“zhoney”及其合作伙伴的名字以map输出</span><br><span class="line">// match().where()方式</span><br><span class="line">g.V(&#x27;zhoney&#x27;).match(__.as(&#x27;a&#x27;).out(&#x27;created&#x27;).as(&#x27;b&#x27;),</span><br><span class="line">                    __.as(&#x27;b&#x27;).in(&#x27;created&#x27;).as(&#x27;c&#x27;)).</span><br><span class="line">                    where(&#x27;a&#x27;, neq(&#x27;c&#x27;))</span><br><span class="line">             .select(&#x27;a&#x27;,&#x27;c&#x27;).by(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914003124363" alt=""></p>
</li>
<li><p><code>filter()</code></p>
<p><code>filter()</code>有三种用法：</p>
<ul>
<li>lambda方式，<code>filter&#123;it.get()…&#125;</code></li>
<li>Traversal方式，<code>filter(Traversal)</code></li>
<li>特定filter step方式</li>
</ul>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 查找图中的“person”顶点</span><br><span class="line">// lambda方式</span><br><span class="line">g.V().filter &#123;it.get().label() == &#x27;person&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914005233286" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 查找图中的“person”顶点</span><br><span class="line">// Traversal方式</span><br><span class="line">g.V().filter(label().is(&#x27;person&#x27;))</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914005402551" alt=""></p>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 查找图中的“person”顶点</span><br><span class="line">// 特定filter step方式</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914005534854" alt=""></p>
</li>
</ol>
<h3 id="逻辑运算说明"><a href="#逻辑运算说明" class="headerlink" title="逻辑运算说明"></a>逻辑运算说明</h3><p>Gremlin支持在遍历器上加上逻辑运算进行过滤，只有满足该逻辑条件的元素才会进入下一个遍历器中。</p>
<p>下面讲解实现上述功能的具体Step：</p>
<ul>
<li><code>is()</code>：可以接受一个对象（能判断相等）或一个判断语句（如：<code>P.gt()</code>、<code>P.lt()</code>、<code>P.inside()</code>等），当接受的是对象时，原遍历器中的元素必须与对象相等才会保留；当接受的是判断语句时，原遍历器中的元素满足判断才会保留，其实接受一个对象相当于<code>P.eq()</code>；</li>
<li><code>and()</code>：可以接受任意数量的遍历器（traversal），原遍历器中的元素，只有在每个新遍历器中都能生成至少一个输出的情况下才会保留，相当于过滤器组合的与条件；</li>
<li><code>or()</code>：可以接受任意数量的遍历器（traversal），原遍历器中的元素，只要在全部新遍历器中能生成至少一个输出的情况下就会保留，相当于过滤器组合的或条件；</li>
<li><code>not()</code>：仅能接受一个遍历器（traversal），原遍历器中的元素，在新遍历器中能生成输出时会被移除，不能生成输出时则会保留，相当于过滤器的非条件。</li>
</ul>
<p>这四种逻辑运算Step除了像一般的Step写法以外，<code>and()</code>和<code>or()</code>还可以放在<code>where()</code>中以中缀符的形式出现。</p>
<h4 id="实例讲解-6"><a href="#实例讲解-6" class="headerlink" title="实例讲解"></a>实例讲解</h4><p>下面通过实例来深入理解每一个操作。</p>
<ol>
<li><p><code>is()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 筛选出顶点属性“age”等于28的属性值，与`is(P.eq(28))`等效</span><br><span class="line">g.V().values(&#x27;age&#x27;).is(28)</span><br></pre></td></tr></table></figure>
<p>当没有任何一个顶点的属性“age”为28时，输出为空。</p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 筛选出顶点属性“age”大于等于28的属性值</span><br><span class="line">g.V().values(&#x27;age&#x27;).is(gte(28))</span><br></pre></td></tr></table></figure>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 筛选出顶点属性“age”属于区间（27，29）的属性值</span><br><span class="line">g.V().values(&#x27;age&#x27;).is(inside(27, 29))</span><br></pre></td></tr></table></figure>
<p><code>P.inside(a, b)</code>是左开右开区间(a,b)</p>
<p>示例4：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 筛选出由两个或两个以上的人参与创建（“created”）的顶点</span><br><span class="line">// 注意：这里筛选的是顶点</span><br><span class="line">g.V().where(__.in(&#x27;created&#x27;).count().is(gt(2))).values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p><code>where()</code>Step可以接受一些过滤条件。</p>
<p>示例5：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 筛选出有创建者（“created”）的年龄（“age”）在20～29之间的顶点</span><br><span class="line">g.V().where(__.in(&#x27;created&#x27;).values(&#x27;age&#x27;).is(between(20, 29))).values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p><code>between</code>是左闭右闭区间[a,b]</p>
</li>
<li><p><code>and()</code>，逻辑与</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 所有包含出边“supports”的顶点的名字“name”</span><br><span class="line">g.V().and(outE(&#x27;supports&#x27;)).values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 所有包含出边“supports”和“implements”的顶点的名字“name”</span><br><span class="line">g.V().and(outE(&#x27;supports&#x27;), outE(&#x27;implements&#x27;)).values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 包含边“created”并且属性“age”为28的顶点的名字“name”</span><br><span class="line">g.V().and(outE(&#x27;created&#x27;), values(&#x27;age&#x27;).is(28)).values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p>示例4：“示例3”的中缀符写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 包含边“created”并且属性“age”为28的顶点的名字“name”</span><br><span class="line">g.V().where(outE(&#x27;created&#x27;)</span><br><span class="line">            .and()</span><br><span class="line">            .values(&#x27;age&#x27;).is(28))</span><br><span class="line"> .values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>or()</code>，逻辑或</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 所有包含出边“supports”的顶点的名字“name”</span><br><span class="line">g.V().or(outE(&#x27;supports&#x27;)).values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p>只有一个条件时，<code>and()</code>与<code>or()</code>的效果一样的。</p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 所有包含出边“supports”或“implements”的顶点的名字“name”</span><br><span class="line">g.V().or(outE(&#x27;supports&#x27;), outE(&#x27;implements&#x27;)).values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p>注意对比与<code>g.V().and(outE(&#39;supports&#39;), outE(&#39;implements&#39;)).values(&#39;name&#39;)</code>的差别。</p>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 包含边“created”或属性“age”为28的顶点的名字“name”</span><br><span class="line">g.V().or(outE(&#x27;created&#x27;), values(&#x27;age&#x27;).is(28)).values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p>注意对比与<code>g.V().and(outE(&#39;created&#39;), values(&#39;age&#39;).is(28)).values(&#39;name&#39;)</code>的差别。</p>
<p>示例4：“示例3”的中缀符写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 包含边“created”或属性“age”为28的顶点的名字“name”</span><br><span class="line">g.V().where(outE(&#x27;created&#x27;)</span><br><span class="line">            .or()</span><br><span class="line">            .values(&#x27;age&#x27;).is(28))</span><br><span class="line"> .values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>not()</code>，逻辑非</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 筛选出所有不是“person”的顶点的“label”</span><br><span class="line">g.V().not(hasLabel(&#x27;person&#x27;)).label()</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 筛选出所有包含不少于两条（大于等于两条）“created”边的“person”的名字“name”</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).not(out(&#x27;created&#x27;).count().is(lt(2))).values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="综合运用-2"><a href="#综合运用-2" class="headerlink" title="综合运用"></a>综合运用</h4><p>目标：获取所有最多只有一条“created”边并且年龄不等于28的“person”顶点</p>
<p>写法1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 与（含有小于等于一条“created”边，年龄不等于28）</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;)</span><br><span class="line"> .and(outE(&#x27;created&#x27;).count().is(lte(1)), </span><br><span class="line">      values(&quot;age&quot;).is(P.not(P.eq(28))))</span><br><span class="line"> .values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p>写法2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 非（或（含有多于一条“created”边，年龄等于28））</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;)</span><br><span class="line"> .not(or(out(&#x27;created&#x27;).count().is(gt(1)), </span><br><span class="line">         values(&#x27;age&#x27;).is(28)))</span><br><span class="line"> .values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="统计运算说明"><a href="#统计运算说明" class="headerlink" title="统计运算说明"></a>统计运算说明</h3><p>Gremlin可以在Number类型的流（遍历器）上做简单的统计运算，包括计算总和、最大值、最小值、均值。</p>
<p>下面讲解实现上述功能的具体Step：</p>
<ul>
<li><code>sum()</code>：将流上的所有的数字求和；</li>
<li><code>max()</code>：对流上的所有的数字求最大值；</li>
<li><code>min()</code>：对流上的所有的数字求最小值；</li>
<li><code>mean()</code>：将流上的所有的数字求均值；</li>
</ul>
<p>这四种Step只能作用在Number类型的流上，在java里就是继承自<code>java.lang.Number</code>类。</p>
<h4 id="实例讲解-7"><a href="#实例讲解-7" class="headerlink" title="实例讲解"></a>实例讲解</h4><p>下面通过实例来深入理解每一个操作。</p>
<ol>
<li><p><code>sum()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 计算所有“person”的“age”的总和</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).values(&#x27;age&#x27;).sum()</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 计算所有“person”的“created”出边数的总和</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).map(outE(&#x27;created&#x27;).count()).sum()</span><br></pre></td></tr></table></figure>
<p>试着输入<code>g.V().hasLabel(&#39;person&#39;).map(outE(&#39;created&#39;).count())</code>看看每个“person”的“created”出边数。</p>
</li>
<li><p><code>max()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 计算所有“person”的“age”中的最大值</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).values(&#x27;age&#x27;).max()</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 计算所有“person”的“created”出边数的最大值</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).map(outE(&#x27;created&#x27;).count()).max()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>min()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 计算所有“person”的“age”中的最小值</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).values(&#x27;age&#x27;).min()</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 计算所有“person”的“created”出边数的最小值</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).map(outE(&#x27;created&#x27;).count()).min()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>mean()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 计算所有“person”的“age”的均值</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).values(&#x27;age&#x27;).mean()</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 计算所有“person”的“created”出边数的均值</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).map(outE(&#x27;created&#x27;).count()).mean()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="数学运算说明"><a href="#数学运算说明" class="headerlink" title="数学运算说明"></a>数学运算说明</h3><p>在Gremlin中有一个专门负责科学计算功能的step <code>math()</code>。<code>math()</code> 不同于常见的函数组合和嵌套形式，提供了一种易于读取的基于字符串的数学处理器。</p>
<ul>
<li><code>math()</code> 支持<code>by()</code>，其中多个<code>by()</code> 按照在<code>math()</code>运算表达式中首次引用变量的顺序应用。</li>
<li>保留变量<code>_</code>是指传入<code>math()</code>的当前遍历器对象。</li>
</ul>
<p><code>math()</code>支持的运算符包括：<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>，<code>^</code>。</p>
<p><code>math()</code>支持的内嵌函数包括：</p>
<ul>
<li><code>abs</code>: absolute value，绝对值</li>
<li><code>acos</code>: arc cosine，反余弦</li>
<li><code>asin</code>: arc sine，反正弦</li>
<li><code>atan</code>: arc tangent，反正切</li>
<li><code>cbrt</code>: cubic root，立方根</li>
<li><code>ceil</code>: nearest upper integer，向上最接近的整数</li>
<li><code>cos</code>: cosine，余弦</li>
<li><code>cosh</code>: hyperbolic cosine，双曲余弦</li>
<li><code>exp</code>: euler’s number raised to the power (e^x)，以e为底的指数</li>
<li><code>floor</code>: nearest lower integer，向下最近接的整数</li>
<li><code>log</code>: logarithmus naturalis (base e)，以e为底的对数</li>
<li><code>log10</code>: logarithm (base 10)，以10为底的对数</li>
<li><code>log2</code>: logarithm (base 2)，以2为底的对数</li>
<li><code>sin</code>: sine，正弦</li>
<li><code>sinh</code>: hyperbolic sine，双曲正弦</li>
<li><code>sqrt</code>: square root，平方根</li>
<li><code>tan</code>: tangent，正切</li>
<li><code>tanh</code>: hyperbolic tangent，双曲正切</li>
<li><code>signum</code>: signum function，签名功能</li>
</ul>
<h4 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h4><ol>
<li><p><code>math</code>中的<code>floor</code>语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 比如按照年龄段进行统计</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;)</span><br><span class="line"> .groupCount().by(values(&#x27;age&#x27;).math(&#x27;floor(_/10)*10&#x27;))</span><br><span class="line"> .order(local).by(values,desc)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>更多资料可以先参考<a target="_blank" rel="noopener" href="http://tinkerpop.apache.org/docs/3.3.3/reference/#math-step">TinkerPop官网对于<code>math()</code>step的实例说明</a></p>
<h3 id="路径选取与过滤说明"><a href="#路径选取与过滤说明" class="headerlink" title="路径选取与过滤说明"></a>路径选取与过滤说明</h3><p>Gremlin支持从走过的路径里选取部分数据作为结果，并且可以在选取时进行条件过滤。</p>
<p>下面讲解实现上述功能的具体Step：</p>
<ul>
<li><code>as()+select()</code>: 对路径中结果进行选取，首先通过<code>as(label)</code>对任意步骤打上标签，然后使用<code>select(label)</code>来选取若干历史步骤的结果作为新结果。此外还可通过<code>select().by(property)</code>来指定根据什么维度进行选取。</li>
<li><code>as()+where()</code>: 以条件匹配的方式进行路径结果选取，只有符合条件的路径才能被选取出来。</li>
<li><code>as()+match()</code>: 以模式匹配的方式进行路径结果选取，只有符合模式的路径才能被选取出来。</li>
<li><code>as()+dedup()</code>: 根据路径中的若干步骤的结果进行去重，只有首次出现的路径段才能被选取出来。</li>
</ul>
<h4 id="实例讲解-8"><a href="#实例讲解-8" class="headerlink" title="实例讲解"></a>实例讲解</h4><p>下面通过实例来深入理解每一个操作。</p>
<ol>
<li><p><code>as()...select()</code>：对路径中结果进行选取</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 从路径中选取第1步和第3步的结果作为最终结果</span><br><span class="line">g.V(&#x27;2:HugeGraph&#x27;).as(&#x27;a&#x27;)</span><br><span class="line"> .out().as(&#x27;b&#x27;)</span><br><span class="line"> .out().as(&#x27;c&#x27;)</span><br><span class="line"> .select(&#x27;a&#x27;, &#x27;c&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190312104747884.png" alt=""></p>
<p>对比：不选取时获取的完整路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g.V(&#x27;2:HugeGraph&#x27;).as(&#x27;a&#x27;)</span><br><span class="line"> .out().as(&#x27;b&#x27;)</span><br><span class="line"> .out().as(&#x27;c&#x27;)</span><br><span class="line"> .path()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190312111316804.png" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 从集合中选择最后一个元素</span><br><span class="line">g.V(&#x27;2:HugeGraph&#x27;).as(&quot;a&quot;)</span><br><span class="line"> .repeat(out().as(&quot;a&quot;)).times(2)</span><br><span class="line"> .select(last, &quot;a&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190312155217793.png" alt=""></p>
<p>试一试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select(all, &quot;a&quot;)</span><br><span class="line">select(first, &quot;a&quot;)</span><br></pre></td></tr></table></figure>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 通过by()来指定选取的维度</span><br><span class="line">g.V(&#x27;2:HugeGraph&#x27;).as(&#x27;a&#x27;)</span><br><span class="line"> .out().as(&#x27;b&#x27;)</span><br><span class="line"> .out().as(&#x27;c&#x27;)</span><br><span class="line"> .select(&#x27;a&#x27;, &#x27;c&#x27;)</span><br><span class="line"> .by(&#x27;name&#x27;).by(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190312111235837.png" alt=""></p>
<p>示例4（特殊用法：map选择）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 从map中选择指定key的值</span><br><span class="line">g.V().valueMap().select(&#x27;tag&#x27;).dedup()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190312155343293.png" alt=""></p>
</li>
<li><p><code>as()...where()</code>：以条件匹配的方式进行路径结果选取</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 选取满足第1步和第3步“lang”属性相等的路径</span><br><span class="line">g.V(&#x27;2:HugeGraph&#x27;).as(&#x27;a&#x27;)</span><br><span class="line"> .out().as(&#x27;b&#x27;).out().as(&#x27;c&#x27;)</span><br><span class="line"> .where(&#x27;a&#x27;, eq(&#x27;c&#x27;)).by(&#x27;lang&#x27;)</span><br><span class="line"> .select(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;).by(id)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190312112523319.png" alt=""></p>
</li>
<li><p><code>as()+match()</code>：以模式匹配的方式进行路径结果选取</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 选取满足两个模式的路径：</span><br><span class="line">// 1.第3步有OUT节点</span><br><span class="line">// 2.第3步的OUT节点的指定路径不允许回到第二步的节点</span><br><span class="line">g.V(&#x27;2:HugeGraph&#x27;).as(&#x27;a&#x27;).out().as(&#x27;b&#x27;)</span><br><span class="line"> .match(__.as(&#x27;b&#x27;).out().as(&#x27;c&#x27;),</span><br><span class="line">        __.not(__.as(&#x27;c&#x27;).out().in(&#x27;define&#x27;).as(&#x27;b&#x27;)))</span><br><span class="line"> .select(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;).by(id)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190312111437384.png" alt=""></p>
</li>
<li><p><code>as()+debup()</code>：路径去重</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 以路径中的前3步作为去重依据，对路径进行去重</span><br><span class="line">g.V(&#x27;2:HugeGraph&#x27;).as(&#x27;a&#x27;)</span><br><span class="line"> .out().as(&#x27;b&#x27;).out().as(&#x27;c&#x27;).in()</span><br><span class="line"> .dedup(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;).path()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190312111501895.png" alt=""></p>
</li>
</ol>
<h4 id="综合运用-3"><a href="#综合运用-3" class="headerlink" title="综合运用"></a>综合运用</h4><ol>
<li><p>查询支持Gremlin语言的软件，至少由2个相互认识的且在北京的作者完成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取支持Gremlin语言的软件，</span><br><span class="line">// 并且作者是至少为2个相互认识的人，</span><br><span class="line">// 且这两个作者都在北京</span><br><span class="line">g.V(&#x27;3:Gremlin&#x27;).in(&#x27;supports&#x27;).as(&#x27;software&#x27;)</span><br><span class="line"> .match(</span><br><span class="line">  __.as(&#x27;software&#x27;).in(&#x27;created&#x27;).as(&#x27;person1&#x27;),</span><br><span class="line">  __.as(&#x27;person1&#x27;).both(&#x27;knows&#x27;).as(&#x27;person2&#x27;),</span><br><span class="line">  __.as(&#x27;person2&#x27;).out(&#x27;created&#x27;).as(&#x27;software&#x27;),</span><br><span class="line">  __.as(&#x27;person1&#x27;).has(&#x27;addr&#x27;, &#x27;Beijing&#x27;),</span><br><span class="line">  __.as(&#x27;person2&#x27;).has(&#x27;addr&#x27;, &#x27;Beijing&#x27;)</span><br><span class="line">  )</span><br><span class="line"> .select(&#x27;software&#x27;).dedup()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190312111532331.png" alt=""></p>
</li>
<li><p>查询支持Gremlin语言的软件的作者，并按边权重排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取支持Gremlin语言的软件，</span><br><span class="line">// 并查找其作者，并对中间经过的边打标签</span><br><span class="line">// 按照边的权重进行排序</span><br><span class="line">// 选取软件、权重、作者作为结果</span><br><span class="line">g.V(&#x27;3:Gremlin&#x27;).in(&#x27;supports&#x27;).as(&#x27;s&#x27;)</span><br><span class="line"> .inE(&#x27;created&#x27;).as(&#x27;e&#x27;).outV().as(&#x27;t&#x27;)</span><br><span class="line"> .order().by(select(&#x27;e&#x27;).by(&#x27;weight&#x27;), decr)</span><br><span class="line"> .select(&#x27;s&#x27;, &#x27;e&#x27;, &#x27;t&#x27;).by(&#x27;name&#x27;).by(&#x27;weight&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190312155512830.png" alt=""></p>
</li>
</ol>
<h3 id="分支操作说明"><a href="#分支操作说明" class="headerlink" title="分支操作说明"></a>分支操作说明</h3><p>在对图进行遍历分析时，有时需要根据某些条件对当前的对象集合进行不同的操作，也就是if-then-else语法结构。Gremlin中有一类step可以满足这种分支需求，这组step叫做branch step。<code>branch()</code>是这类step的基础，比较抽象，而<code>choose()</code>是典型的branch step。</p>
<p><code>choose()</code>的基本使用方法有两类：</p>
<ul>
<li>单独使用，<code>choose(predicate, true-traversal, false-traversal)</code>：根据<code>predicate</code>判断，当前对象满足时，继续<code>true-traversal</code>，否则继续<code>false-traversal</code></li>
<li>与option配合使用，<code>choose(traversal).option(value1, traversal1).option(...)...</code>：根据对象通过<code>traversal</code>的结果决定后续操作，如果结果是<code>value1</code>，则该对象继续<code>traversal1</code>，以此类推</li>
</ul>
<p><code>option()</code>不是一种Gremlin step，只是一种辅助语法，可与<code>choose()</code>配合使用。</p>
<h4 id="实例讲解-9"><a href="#实例讲解-9" class="headerlink" title="实例讲解"></a>实例讲解</h4><ol>
<li><p><code>if-then-else</code>型<code>choose()</code>语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 查找所有的“person”类型的顶点</span><br><span class="line">// 如果“age”属性小于等于20，输出他的朋友的名字</span><br><span class="line">// 如果“age”属性大于20，输出他开发的软件的名字</span><br><span class="line">// choose(condition, true-action, false-action)</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;)</span><br><span class="line"> .choose(values(&#x27;age&#x27;).is(lte(20)),</span><br><span class="line">         __.in(&#x27;knows&#x27;),</span><br><span class="line">         __.out(&#x27;created&#x27;)).values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/2018091418071560" alt=""></p>
</li>
<li><p><code>option()</code>型<code>choose()</code>语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 查找所有的“person”类型的顶点</span><br><span class="line">// 如果“age”属性等于0，输出名字</span><br><span class="line">// 如果“age”属性等于28，输出年龄</span><br><span class="line">// 如果“age”属性等于29，输出他开发的软件的名字</span><br><span class="line">// choose(predicate).option().option()...</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;)</span><br><span class="line"> .choose(values(&#x27;age&#x27;))</span><br><span class="line"> .option(0, values(&#x27;name&#x27;))</span><br><span class="line"> .option(28, values(&#x27;age&#x27;))</span><br><span class="line"> .option(29, __.out(&#x27;created&#x27;).values(&#x27;name&#x27;))</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914175727284" alt=""></p>
</li>
<li><p>如果<code>choose(predicate, true-traversal, false-traversal)</code>中<code>false-traversal</code>为空或者是<code>identity()</code>，则不满足条件的对象直接通过<code>choose()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查找所有顶点，</span><br><span class="line">// 类型为“person”的顶点输出其创建的软件的“name”属性</span><br><span class="line">// 否则输出顶点自身的“name”属性</span><br><span class="line">g.V().choose(hasLabel(&#x27;person&#x27;),  </span><br><span class="line">             out(&#x27;created&#x27;))</span><br><span class="line"> .values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914190112913" alt="img"></p>
</li>
<li><p><code>choose()</code>和<code>option()</code>配合使用时，还提供了一个<code>none</code>，不满足其他选项的对象，执行<code>none</code>选项的<code>traversal</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 查找所有类型为“person”的顶点，</span><br><span class="line">// “name”属性为“Zhoney Zhang”的输出其“age”属性</span><br><span class="line">// 否则输出顶点的“name”属性</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;)</span><br><span class="line"> .choose(values(&#x27;name&#x27;))</span><br><span class="line"> .option(&#x27;Zhoney Zhang&#x27;, values(&#x27;age&#x27;))</span><br><span class="line"> .option(none, values(&#x27;name&#x27;))</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914190346799" alt=""></p>
</li>
<li><p><code>branch()</code></p>
<p><code>branch()</code>有三种用法：</p>
<ul>
<li>lambda方式，<code>branch&#123;it.get()…&#125;</code></li>
<li>Traversal方式，<code>branch(Traversal)</code></li>
<li>特定branch step方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 查询所有顶点</span><br><span class="line">// “name”属性值为“HugeGraph”的顶点输出其“lang”属性</span><br><span class="line">// “name”属性值不为“HugeGraph”的顶点输出其“name”属性</span><br><span class="line">// lambda方式</span><br><span class="line">g.V().branch &#123;it.get().value(&#x27;name&#x27;)&#125;</span><br><span class="line">     .option(&#x27;HugeGraph&#x27;, values(&#x27;lang&#x27;))</span><br><span class="line">     .option(none, values(&#x27;name&#x27;))</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914173735184" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 查询所有顶点</span><br><span class="line">// “name”属性值为“HugeGraph”的顶点输出其“lang”属性</span><br><span class="line">// “name”属性值不为“HugeGraph”的顶点输出其“name”属性</span><br><span class="line">// traversal方式</span><br><span class="line">g.V().branch(values(&#x27;name&#x27;))</span><br><span class="line">     .option(&#x27;HugeGraph&#x27;, values(&#x27;lang&#x27;))</span><br><span class="line">     .option(none, values(&#x27;name&#x27;))</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180914174148376" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 查询所有顶点</span><br><span class="line">// “name”属性值为“HugeGraph”的顶点输出其“lang”属性</span><br><span class="line">// “name”属性值不为“HugeGraph”的顶点输出其“name”属性</span><br><span class="line">// 特定branch step方式</span><br><span class="line">g.V().choose(has(&#x27;name&#x27;,&#x27;HugeGraph&#x27;),</span><br><span class="line">             values(&#x27;lang&#x27;),</span><br><span class="line">             values(&#x27;name&#x27;))</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180926164146263" alt=""></p>
</li>
</ol>
<h3 id="合并操作说明"><a href="#合并操作说明" class="headerlink" title="合并操作说明"></a>合并操作说明</h3><ul>
<li><code>coalesce</code>: 可以接受任意数量的遍历器（traversal），按顺序执行，并返回第一个能产生输出的遍历器的结果；</li>
<li><code>optional</code>: 只能接受一个遍历器（traversal），如果该遍历器能产生一个结果，则返回该结果，否则返回调用<code>optional</code>Step的元素本身。当连续使用<code>.optional()</code>时，如果在某一步返回了调用元素本身，则后续的<code>.optional()</code>不会继续执行；</li>
<li><code>union</code>: 可以接受任意数量的遍历器（traversal），并能够将各个遍历器的输出合并到一起；</li>
</ul>
<h4 id="实例讲解-10"><a href="#实例讲解-10" class="headerlink" title="实例讲解"></a>实例讲解</h4><p>下面通过实例来深入理解每一个操作。</p>
<ol>
<li><p><code>coalesce()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 按优先级寻找到顶点“HugeGraph”的以下边和邻接点，找到一个就停止</span><br><span class="line">// 1、“implements”出边和邻接点</span><br><span class="line">// 2、“supports”出边和邻接点</span><br><span class="line">// 3、“created”入边和邻接点</span><br><span class="line">g.V(&#x27;3:HugeGraph&#x27;).coalesce(outE(&#x27;implements&#x27;), outE(&#x27;supports&#x27;), inE(&#x27;created&#x27;)).inV().path().by(&#x27;name&#x27;).by(label)</span><br></pre></td></tr></table></figure>
<p>HugeGraph这三类边都是存在的，按照优先级，返回了“implements”出边和邻接点。</p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 按优先级寻找到顶点“HugeGraph”的以下边和邻接点，找到一个就停止（调换了示例1中的1和2的顺序）</span><br><span class="line">// 1、“supports”出边和邻接点</span><br><span class="line">// 2、“implements”出边和邻接点</span><br><span class="line">// 3、“created”入边和邻接点</span><br><span class="line">g.V(&#x27;3:HugeGraph&#x27;).coalesce(outE(&#x27;supports&#x27;), outE(&#x27;implements&#x27;),  inE(&#x27;created&#x27;)).inV().path().by(&#x27;name&#x27;).by(label)</span><br></pre></td></tr></table></figure>
<p>这次由于“supports”放在了“implements”的前面，所以返回了“supports”出边和邻接点。</p>
<p>自己动手比较一下<code>outE(&#39;supports&#39;), outE(&#39;implements&#39;), inE(&#39;created&#39;)</code>在<code>.coalesce()</code>中随意调换顺序的区别。</p>
</li>
<li><p><code>optional()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查找顶点&quot;linary&quot;的“created”出顶点，如果没有就返回&quot;linary&quot;自己</span><br><span class="line">g.V(&#x27;linary&#x27;).optional(out(&#x27;created&#x27;))</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查找顶点&quot;linary&quot;的“knows”出顶点，如果没有就返回&quot;linary&quot;自己</span><br><span class="line">g.V(&#x27;linary&#x27;).optional(out(&#x27;knows&#x27;))</span><br></pre></td></tr></table></figure>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查找每个“person”顶点的出“knows”顶点，如果存在，然后以出“knows”顶点为起点，继续寻找其出“created”顶点，最后打印路径</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).optional(out(&#x27;knows&#x27;).optional(out(&#x27;created&#x27;))).path()</span><br></pre></td></tr></table></figure>
<p>结果中的后面四个顶点因为没有出“knows”顶点，所以在第一步返回了自身后就停止了。</p>
</li>
<li><p><code>union()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 寻找顶点“linary”的出“created”顶点，邻接“knows”顶点，并将结果合并</span><br><span class="line">g.V(&#x27;linary&#x27;).union(out(&#x27;created&#x27;), both(&#x27;knows&#x27;)).path()</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 寻找顶点“HugeGraph”的入“created”顶点（创作者），出“implements”和出“supports”顶点，并将结果合并</span><br><span class="line">g.V(&#x27;3:HugeGraph&#x27;).union(__.in(&#x27;created&#x27;), out(&#x27;implements&#x27;), out(&#x27;supports&#x27;), out(&#x27;contains&#x27;)).path()</span><br></pre></td></tr></table></figure>
<p>顶点“HugeGraph”没有“contains”边，所以只打印出了其作者（入“created”），它实现的框架（出“implements”）和支持的特性（出“supports”）。</p>
</li>
</ol>
<h3 id="结果聚集与展开说明"><a href="#结果聚集与展开说明" class="headerlink" title="结果聚集与展开说明"></a>结果聚集与展开说明</h3><p>Gremlin在路径游走的时候，可以将某一步的所有结果收集到一个集合里面（我们称之为结果聚集），以备在后续步骤中使用；此外还可在需要的时候将聚集的结果展开。</p>
<p>下面讲解实现上述功能的具体Step：</p>
<ul>
<li><code>aggregate()</code>: 聚集路径中指定步骤的所有结果，通过<code>aggregate(label)</code>对任意步骤打上标签，在此之前的步骤的结果均会被收集到此标签所代表的集合中（但并不会影响路径的游走），可配合<code>by</code>及<code>cap</code>一起使用，通过<code>cap(label)</code>来获取该结果集合，此外还可通过<code>select(label)</code>或<code>without(label)</code>等其它方式读取。</li>
<li><code>store()</code>: 类似<code>aggregate()</code>，只是以Lazy的方式来收集。</li>
<li><code>unfold()</code>: 将集合展开平铺，路径将扩张。</li>
<li><code>fold()</code>: 将多个元素折叠为一个集合，路径将收缩。</li>
</ul>
<h4 id="实例讲解-11"><a href="#实例讲解-11" class="headerlink" title="实例讲解"></a>实例讲解</h4><p>下面通过实例来深入理解每一个操作。</p>
<ol>
<li><p><code>aggregate()</code>：聚集路径中的结果</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 收集第1步的结果到集合&#x27;x&#x27;中</span><br><span class="line">// 注意：不影响后续结果</span><br><span class="line">g.V(&#x27;2:HugeGraph&#x27;).out().aggregate(&#x27;x&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/2019031515421790.png" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 收集第1步的结果到集合&#x27;x&#x27;中</span><br><span class="line">// 并通过cap取出结果</span><br><span class="line">// 与示例1比较，结果的层次更深了</span><br><span class="line">g.V(&#x27;2:HugeGraph&#x27;).out()</span><br><span class="line"> .aggregate(&#x27;x&#x27;).cap(&#x27;x&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190315154310641.png" alt=""></p>
<p>试一试：将<code>cap(&#39;x&#39;)</code>换为<code>select(&#39;x&#39;)</code>看看有什么区别</p>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通过by()来指定聚集的维度</span><br><span class="line">g.V(&#x27;2:HugeGraph&#x27;).out()</span><br><span class="line"> .aggregate(&#x27;x&#x27;).by(&#x27;name&#x27;)</span><br><span class="line"> .cap(&#x27;x&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/2019031515441092.png" alt=""></p>
</li>
<li><p><code>store()</code>：以Lazy的方式来收集结果</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 以Lazy方式收集，后续步骤使用limit限制时，</span><br><span class="line">// 路径中取到第2个结果时将会停止，</span><br><span class="line">// 因此集合中有2个元素。</span><br><span class="line">g.V().store(&#x27;x&#x27;).by(&#x27;name&#x27;).limit(1).cap(&#x27;x&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190315154446895.png" alt=""></p>
<p>请试一试并比较：<code>g.V().aggregate(&#39;x&#39;).by(&#39;name&#39;).limit(1).cap(&#39;x&#39;)</code>。</p>
</li>
<li><p><code>unfold()</code>：以把集合展开、平铺</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 将集合‘x’展开(层级变少了)</span><br><span class="line">g.V(&#x27;2:HugeGraph&#x27;).out()</span><br><span class="line"> .aggregate(&#x27;x&#x27;).by(&#x27;name&#x27;)</span><br><span class="line"> .cap(&#x27;x&#x27;).unfold()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190315154601645.png" alt=""></p>
</li>
<li><p><code>fold()</code>：将元素折叠为集合</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 将属性折叠起来(层级变深)</span><br><span class="line">g.V(&#x27;2:HugeGraph&#x27;).out()</span><br><span class="line"> .values(&#x27;name&#x27;).fold()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190315154633638.png" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 统计所有&#x27;name&#x27;属性的长度</span><br><span class="line">// 其中通过lambuda表达式累加字符串长度</span><br><span class="line">g.V(&#x27;2:HugeGraph&#x27;).out().values(&#x27;name&#x27;)</span><br><span class="line"> .fold(0) &#123;a,b -&gt; a + b.length()&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190315154654292.png" alt=""></p>
</li>
</ol>
<h4 id="综合运用-4"><a href="#综合运用-4" class="headerlink" title="综合运用"></a>综合运用</h4><ol>
<li><p>查询一个软件的同类别软件，但不包括自身在内</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 查询与HugeGraph类似支持Gremlin语言的软件</span><br><span class="line">// 但不包含自身和一步邻居</span><br><span class="line">// 比较：请看看去除where语句的效果</span><br><span class="line">g.V(&#x27;2:HugeGraph&#x27;).aggregate(&#x27;x&#x27;)</span><br><span class="line"> .out().aggregate(&#x27;x&#x27;)</span><br><span class="line"> .out().in()</span><br><span class="line"> .where(without(&#x27;x&#x27;))</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190315154713891.png" alt=""></p>
</li>
<li><p>查询2度之内的所有邻居的名称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查询与HugeGraph的两度OUT邻居</span><br><span class="line">// 并收集这些到‘a’集合里面，</span><br><span class="line">// 最终以‘name’属性展示其邻居</span><br><span class="line">g.V(&#x27;2:HugeGraph&#x27;).out().aggregate(&#x27;a&#x27;)</span><br><span class="line"> .out().aggregate(&#x27;a&#x27;).cap(&#x27;a&#x27;)</span><br><span class="line"> .unfold().values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190315154747246.png" alt=""></p>
</li>
<li><p>查询由多人合作的软件及其各作者的名称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 查询所有由3个以上作者完成的软件</span><br><span class="line">// 并显示它的名称及其作者</span><br><span class="line">g.V().as(&#x27;software&#x27;, &#x27;authors&#x27;)</span><br><span class="line"> .where(__.in(&#x27;created&#x27;).count().is(gte(3)))</span><br><span class="line"> .select(&#x27;software&#x27;, &#x27;authors&#x27;)</span><br><span class="line"> .by(&#x27;name&#x27;)</span><br><span class="line"> .by(__.in(&#x27;created&#x27;).values(&#x27;name&#x27;).fold())</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190315154804196.png" alt="img"></p>
</li>
</ol>
<h3 id="模式匹配说明"><a href="#模式匹配说明" class="headerlink" title="模式匹配说明"></a>模式匹配说明</h3><p>Gremlin中的<code>match()</code>语句为图查询提供了一种基于“模式匹配”的方式，以便用更具描述性的方式进行图查询。<code>match()</code>语句通过多个模式片段<code>traversal fragments</code>来进行模式匹配。这些<code>traversal fragments</code>中会定义一些变量，只有满足所有用变量表示的约束的对象才能够通过，并被放到一个<code>Map&lt;String, Object&gt;</code>中，其中map的key为变量名（label），value为顶点、边、路径或者属性。<code>match()</code>语句的格式为：<code>match(Traversal...)</code>。其中可以有任意多个<code>Traversal</code>，每一个<code>Traversal</code>就是一个“匹配模式”<code>traversal fragment</code>。</p>
<p><code>match()</code>语句中的“模式”通过<code>MatchAlgorithm</code>来选择匹配顺序，默认的<code>MatchAlgorithm</code>是<code>CountMatchAlgorithm</code>。<code>CountMatchAlgorithm</code>根据过滤强度动态调整“模式匹配”的执行计划（最能够减少规模的“模式”优先匹配），从而优化执行减少资源消耗。因此，当图的规模比较大且用户不知道满足特定模式的数据规模时，使用<code>match()</code>可以自动进行优化，减小操作规模。另外，对于一些图查询场景，相较于单路径遍历，<code>match()</code>语句的“模式匹配”更容易表达需求。</p>
<h4 id="实例说明-1"><a href="#实例说明-1" class="headerlink" title="实例说明"></a>实例说明</h4><ol>
<li><p><code>match()</code>语句通过模式匹配生成<code>map&lt;String, Object&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 对每一个顶点，用以下模式去匹配，满足则生成一个map&lt;String, Object&gt;，不满足则过滤掉</span><br><span class="line">// 模式1：“a”对应当前顶点，且创建了软件“HugeGraph”</span><br><span class="line">// 模式2：“b”对应顶点软件“HugeGraph”</span><br><span class="line">// 模式3：“c”对应创建软件“HugeGraph”的年龄为29的person顶点</span><br><span class="line">g.V().match(__.as(&#x27;a&#x27;).out(&#x27;created&#x27;).has(&#x27;name&#x27;, &#x27;HugeGraph&#x27;).as(&#x27;b&#x27;),</span><br><span class="line">            __.as(&#x27;b&#x27;).in(&#x27;created&#x27;).has(&#x27;age&#x27;, 29).as(&#x27;c&#x27;))</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180926201415544" alt=""></p>
</li>
<li><p><code>match()</code>语句可以与<code>select()</code>语句配合使用，从<code>Map&lt;String, Object&gt;</code>中选取部分结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 对每一个顶点，用以下模式去匹配，满足则生成一个map&lt;String, Object&gt;，不满足则过滤掉</span><br><span class="line">// 模式1：“a”对应当前顶点，且创建了软件“HugeGraph”</span><br><span class="line">// 模式2：“b”对应顶点软件“HugeGraph”</span><br><span class="line">// 模式3：“c”对应创建软件“HugeGraph”的年龄为29的person顶点</span><br><span class="line">// 并选取map中的“a&quot;和”c&quot;，对应的对象以”name“属性的值代替</span><br><span class="line">g.V().match(__.as(&#x27;a&#x27;).out(&#x27;created&#x27;).has(&#x27;name&#x27;, &#x27;HugeGraph&#x27;).as(&#x27;b&#x27;),</span><br><span class="line">            __.as(&#x27;b&#x27;).in(&#x27;created&#x27;).has(&#x27;age&#x27;, 29).as(&#x27;c&#x27;))</span><br><span class="line">     .select(&#x27;a&#x27;, &#x27;c&#x27;).by(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180926204743857" alt=""></p>
</li>
<li><p><code>match()</code>语句可以与<code>where()</code>语句配合使用，过滤结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 对每一个顶点，用以下模式去匹配，满足则生成一个map&lt;String, Object&gt;，不满足则过滤掉</span><br><span class="line">// 模式1：“a”对应当前顶点，且创建了软件“HugeGraph”</span><br><span class="line">// 模式2：“b”对应顶点软件“HugeGraph”</span><br><span class="line">// 模式3：“c”对应创建软件“HugeGraph”的年龄为29的person顶点</span><br><span class="line">// 模式4：”a“和”c“对应的对象不相等</span><br><span class="line">// 并选取map中的“a&quot;和”c&quot;，对应的对象以”name“属性的值代替</span><br><span class="line">g.V().match(__.as(&#x27;a&#x27;).out(&#x27;created&#x27;).has(&#x27;name&#x27;, &#x27;HugeGraph&#x27;).as(&#x27;b&#x27;),</span><br><span class="line">            __.as(&#x27;b&#x27;).in(&#x27;created&#x27;).has(&#x27;age&#x27;, 29).as(&#x27;c&#x27;))</span><br><span class="line">     .where(&#x27;a&#x27;, neq(&#x27;c&#x27;))</span><br><span class="line">     .select(&#x27;a&#x27;, &#x27;c&#x27;).by(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180926205130463" alt=""></p>
</li>
<li><p><code>match()</code>语句中可以使用外部的label</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 对每一个顶点打标签”a“，&quot;a&quot;经过一条OUT方向的”knows“边到达的顶点打标签”b“</span><br><span class="line">// 对”b“中的每一个顶点用以下模式去匹配，满足则生成一个map&lt;String, Object&gt;，不满足则过滤掉</span><br><span class="line">// 模式1：”b“通过一条OUT方向的”created“边到达顶点”c“</span><br><span class="line">// 模式2：”c“不能通过一条IN方向的”created“边到达”a“</span><br><span class="line">// 选取map中的“a&quot;，”b“，”c&quot;，对应的对象以”name“属性的值代替</span><br><span class="line">g.V().as(&#x27;a&#x27;).out(&#x27;knows&#x27;).as(&#x27;b&#x27;)</span><br><span class="line"> .match(__.as(&#x27;b&#x27;).out(&#x27;created&#x27;).as(&#x27;c&#x27;),</span><br><span class="line">        __.not(__.as(&#x27;c&#x27;).in(&#x27;created&#x27;).as(&#x27;a&#x27;)))</span><br><span class="line"> .select(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;).by(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p>注意<code>match(__.as(&#39;b&#39;).out(&#39;created&#39;).as(&#39;c&#39;)</code>中的<code>__.as(b)</code>是读取label标识的对象，<code>as(&#39;c&#39;)</code>是为新的对象打上label标识。</p>
<p><img src="https://image.rexking6.top/img/20180926212157714" alt=""></p>
</li>
</ol>
<h3 id="随机过滤与注入说明"><a href="#随机过滤与注入说明" class="headerlink" title="随机过滤与注入说明"></a>随机过滤与注入说明</h3><h4 id="随机过滤说明"><a href="#随机过滤说明" class="headerlink" title="随机过滤说明"></a>随机过滤说明</h4><p>Gremlin支持对遍历器（traversal）上的结果进行采样或者做随机过滤。</p>
<ul>
<li><code>sample</code>: 接受一个整数值，从前一步的遍历器中采样（随机）出最多指定数目的结果；</li>
<li><code>coin</code>: 字面意思是抛硬币过滤，接受一个浮点值，该浮点值表示硬币出现正面的概率。coin Step 对前一步的遍历器中的每个元素都抛一次硬币，出现正面则可以通过，反面则被拦截。</li>
</ul>
<p><code>sample</code>Step后能接上<code>by</code>Step，能以指定的属性为判断依据进行随机过滤。</p>
<h4 id="注入说明"><a href="#注入说明" class="headerlink" title="注入说明"></a>注入说明</h4><p>Gremlin允许在遍历器中注入一些默认值或自定义值，比如在分支 Step 中给 <code>else</code> 路径的元素一个默认值，又或者在遍历器过程中人为地加上一些额外的元素。</p>
<ul>
<li><code>constant</code>: 通常用在<code>choose</code>或<code>coalesce</code>Step中做辅助输出，为那些不满足条件的元素提供一个默认值；</li>
<li><code>inject</code>: 能够在流（遍历器）的任何位置注入与当前遍历器同输出类型的对象，当然，也可以作为流的起始 Step 产生数据。</li>
</ul>
<p><code>inject</code>只是在查询过程中添加一些额外的元素，并没有把数据真正地插入到图中。</p>
<h4 id="实例讲解-12"><a href="#实例讲解-12" class="headerlink" title="实例讲解"></a>实例讲解</h4><p>下面通过实例来深入理解每一个操作。</p>
<ol>
<li><p><code>sample()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 从所有顶点的出边中随机选择2条</span><br><span class="line">g.V().outE().sample(2)</span><br></pre></td></tr></table></figure>
<p>由于<code>sample</code>是随机采样，所以运行结果每次都可能不一样。另外，<code>sample(n)</code>表示最多采样<code>n</code>个，如果上一步不够<code>n</code>个元素自然结果是会小于<code>n</code>的。</p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 从所以顶点的“name”属性中随机选取3个</span><br><span class="line">g.V().values(&#x27;name&#x27;).sample(3)</span><br></pre></td></tr></table></figure>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 从所有的“person”中根据“age”随机选择3个</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).sample(3).by(&#x27;age&#x27;)</span><br></pre></td></tr></table></figure>
<p>示例4：与<code>local</code>联合使用做随机漫游（从某个顶点出发，随机选一条边，走到边上的邻接点；再以该点为起点，继续随机选择边，走到邻接点……）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//  从顶点“HugeGraph”出发做3次随机漫游</span><br><span class="line">g.V(&#x27;3:HugeGraph&#x27;)</span><br><span class="line"> .repeat(local(bothE().sample(1).otherV()))</span><br><span class="line"> .times(3)</span><br><span class="line"> .path()</span><br></pre></td></tr></table></figure>
<p>第1次：从“HugeGraph”沿着“Szhoney&gt;2&gt;&gt;S3:HugeGraph”走到“zhoney”<br>第2次：从“zhoney”沿着“Sjaveme&gt;1&gt;&gt;Szhoney”走到“javeme”<br>第3次：从“javeme”沿着“Sjaveme&gt;1&gt;&gt;Slinary”走到“linary”</p>
</li>
<li><p><code>coin()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 每个顶点按0.5的概率过滤</span><br><span class="line">g.V().coin(0.5)</span><br></pre></td></tr></table></figure>
<p>这一次输出了5个顶点，而总共是有12个顶点的，为什么不是输出6个呢？学过概率论的应该都知道，不解释。我又多执行了两次，输出顶点数分别是5和7。</p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 每个顶点按0.0的概率过滤</span><br><span class="line">g.V().coin(0.0)</span><br></pre></td></tr></table></figure>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 每个顶点按1.0的概率过滤</span><br><span class="line">g.V().coin(1.0).count()</span><br></pre></td></tr></table></figure>
<p>避免输出太长，加上<code>count</code>。</p>
</li>
<li><p><code>constant()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 输出所有“person”类顶点的“name”属性，否则输出“inhuman”（非人类）</span><br><span class="line">g.V().choose(hasLabel(&#x27;person&#x27;),</span><br><span class="line">             values(&#x27;name&#x27;),</span><br><span class="line">             constant(&#x27;inhuman&#x27;))</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 与示例1功能相同，使用“coalesce”Step 实现</span><br><span class="line">g.V().coalesce(hasLabel(&#x27;person&#x27;).values(&#x27;name&#x27;),</span><br><span class="line">               constant(&#x27;inhuman&#x27;))</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>inject()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 给顶点“HugeGraph”的作者添加一个叫“Tom”的人</span><br><span class="line">g.V(&#x27;3:HugeGraph&#x27;).in(&#x27;created&#x27;).values(&#x27;name&#x27;).inject(&#x27;Tom&#x27;) </span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 在示例1的基础上计算每个元素的长度（“name”属性值的长度）</span><br><span class="line">g.V(&#x27;3:HugeGraph&#x27;).in(&#x27;created&#x27;).values(&#x27;name&#x27;).inject(&#x27;Tom&#x27;)</span><br><span class="line"> .map &#123;it.get().length()&#125; </span><br></pre></td></tr></table></figure>
<p>可以看到，注入的元素“Tom”与原生的元素一样参与了计算。</p>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 在示例2的基础上计算走过的路径</span><br><span class="line">g.V(&#x27;3:HugeGraph&#x27;).in(&#x27;created&#x27;).values(&#x27;name&#x27;).inject(&#x27;Tom&#x27;)</span><br><span class="line"> .map &#123;it.get().length()&#125;.path()</span><br></pre></td></tr></table></figure>
<p>这里又能看出注入元素“Tom”与原生的元素的区别，由于“Tom”是在获取“name”属性这一步时才注入的，所以之前的从顶点“HugeGraph”出发，获取其“created”的入顶点这两步“Tom”是没有的。</p>
<p>示例4：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用inject创建出两个元素（顶点的id），并使用该元素作为id获取顶点及其属性“name”</span><br><span class="line">inject(&#x27;javeme&#x27;, &#x27;linary&#x27;, &#x27;zhoney&#x27;).map &#123;g.V(it.get()).next()&#125;.values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用inject创建出一个“person”（顶点label），并使用该元素作为label获取顶点及其属性“name”</span><br><span class="line">inject(&#x27;person&#x27;).flatMap &#123;g.V().hasLabel(it.get())&#125;.values(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="结果存取口袋说明"><a href="#结果存取口袋说明" class="headerlink" title="结果存取口袋说明"></a>结果存取口袋说明</h3><p>Gremlin在路径遍历的时候，可以将中间结果存放到一个叫口袋（sack）的结构里面，以备在后续步骤中使用；此外在放入数据到口袋的时候，还可以做一些灵活的操作比如：分裂（split）、合并（merge）等。sack相关step属于Gremlin语言里面的高级操作，在处理较为复杂的任务时可以灵活的实现一些特殊功能。</p>
<p>下面讲解实现上述功能的具体Step：</p>
<ul>
<li><code>withSack()</code>: 创建一个口袋，并给定一个初始结构，比如可以是一个返回Map或者随机数的lambda函数，也可以是一个对象或常数；另外还可以提供lambda分裂函数，以指定当traverser分裂时的行为，比如进行clone操作。</li>
<li><code>sack()</code>: 将数据放入口袋，或者从口袋取出数据。当传入lambda合并函数作为参数时，可指定放入口袋的行为如何执行；当不传入参数时表示读取口袋中的内容。</li>
</ul>
<h4 id="实例讲解-13"><a href="#实例讲解-13" class="headerlink" title="实例讲解"></a>实例讲解</h4><p>下面通过实例来深入理解每一个操作。</p>
<ol>
<li><p><code>withSack()…sack()</code>： 利用口袋来存取结果</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个包含常数1的口袋，</span><br><span class="line">// 并且在最终取出口袋中的值</span><br><span class="line">g.withSack(1).V().sack()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190405003231225.png" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个包含随机数的口袋，</span><br><span class="line">// 并且在最终取出口袋中的值</span><br><span class="line">g.withSack&#123;new Random().nextFloat()&#125;</span><br><span class="line"> .V().sack()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190405003253956.png" alt=""></p>
<p>试一试：将<code>g.withSack&#123;&#125;</code>的大括号换为小括号<code>g.withSack()</code>看看有什么区别。</p>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通过sum求和的方式把数据放入口袋</span><br><span class="line">g.withSack(0).V()</span><br><span class="line"> .repeat(outE().sack(sum).by(&#x27;weight&#x27;).inV())</span><br><span class="line"> .times(3).sack()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190405003317467.png" alt=""></p>
<p>试一试：通过以下gremlin查看路径及其权重：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g.withSack(0).V()</span><br><span class="line"> .repeat(outE().sack(sum).by(&#x27;weight&#x27;).inV())</span><br><span class="line"> .times(3).path().by().by(&#x27;weight&#x27;)</span><br></pre></td></tr></table></figure>
<p>示例4：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 通过lambda函数来指定放入口袋的行为</span><br><span class="line">// 注意：提供的初始值为Map类型，而且</span><br><span class="line">// 当traverser分裂时会拷贝Map</span><br><span class="line">g.withSack&#123;[:]&#125;&#123;it.clone()&#125;</span><br><span class="line"> .V().out().out().dedup()</span><br><span class="line"> .sack&#123;m,v -&gt; m[v.value(&#x27;name&#x27;)] = v.value(&#x27;lang&#x27;); m&#125;</span><br><span class="line"> .sack()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190405003339980.png" alt=""></p>
<p>试一试：去掉分裂函数后看看效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g.withSack&#123;[:]&#125;</span><br><span class="line"> .V().out().out().dedup()</span><br><span class="line"> .sack&#123;m,v -&gt; m[v.value(&#x27;name&#x27;)] = v.value(&#x27;lang&#x27;); m&#125;</span><br><span class="line"> .sack()</span><br></pre></td></tr></table></figure>
<p>示例5：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 平均获取口袋中的值</span><br><span class="line">g.withSack(1.0).V(&#x27;javeme&#x27;)</span><br><span class="line"> .out(&#x27;knows&#x27;).out(&#x27;created&#x27;)</span><br><span class="line"> .barrier(normSack).sack()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190405003408154.png" alt=""></p>
</li>
</ol>
<h4 id="综合运用-5"><a href="#综合运用-5" class="headerlink" title="综合运用"></a>综合运用</h4><ol>
<li><p>获取路径并计算路径权重之和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取路径的同时通过sack(sum)计算权重之和</span><br><span class="line">// 最终通过select把权重和路径选取出来</span><br><span class="line">g.withSack(0).V()</span><br><span class="line"> .repeat(outE().sack(sum).by(&#x27;weight&#x27;).inV().as(&#x27;p&#x27;))</span><br><span class="line"> .times(3).sack().as(&#x27;w&#x27;)</span><br><span class="line"> .select(&#x27;w&#x27;, &#x27;p&#x27;).by().by&#123;p-&gt;p.toString()&#125;.limit(3)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190405003426322.png" alt=""></p>
</li>
<li><p>获取路径并根据路径权重之和排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取路径的同时通过sack(sum)计算权重之和</span><br><span class="line">// 最终通过order().by(sack())根据总权重排序</span><br><span class="line">g.withSack(0).V()</span><br><span class="line"> .repeat(outE().sack(sum).by(&#x27;weight&#x27;).inV())</span><br><span class="line"> .times(3).order().by(sack(),decr)</span><br><span class="line"> .path().limit(3)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190405003444250.png" alt=""></p>
</li>
</ol>
<h3 id="遍历栅栏说明"><a href="#遍历栅栏说明" class="headerlink" title="遍历栅栏说明"></a>遍历栅栏说明</h3><p>Gremlin在路径遍历的时候，可以将栅栏barrier插入到懒加载的遍历流水线中，以使得barrier之前的步骤都执行完成之后再继续往下执行。barrier主要有2个好处：1、可以强制改变深度优先搜索为广度优先搜索，2、由于通过层的bulking模式可以优化大量重复的数据访问。</p>
<p>下面讲解实现上述功能的具体Step：</p>
<ul>
<li><code>barrier()</code>: 在某个位置插入一个栅栏，以强制该位置之前的步骤必须都执行完成才可以继续往后执行，比如<code>g.V().both().barrier().both()</code>只有在第一个<code>both()</code>全部完成之后才会执行第二个<code>both()</code>。</li>
</ul>
<h4 id="实例讲解-14"><a href="#实例讲解-14" class="headerlink" title="实例讲解"></a>实例讲解</h4><p>下面通过实例来深入理解每一个操作。</p>
<ol>
<li><p><code>barrier()</code>： 遍历时设置栅栏</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 将所有顶点打印出来</span><br><span class="line">// 打印完一轮之后再打印一轮</span><br><span class="line">def list=[]</span><br><span class="line">g.V().sideEffect&#123;list.add(&quot;first: &quot;+it)&#125;</span><br><span class="line">     .barrier()</span><br><span class="line">     .sideEffect&#123;list.add(&quot;second: &quot;+it)&#125;</span><br><span class="line">     .iterate()</span><br><span class="line">list</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/2019041014391430.png" alt=""></p>
<p>对比无barrier时的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 打印first后打印second，</span><br><span class="line">// 直到一轮所有的顶点都完成</span><br><span class="line">def list=[]</span><br><span class="line">g.V().sideEffect&#123;list.add(&quot;first: &quot;+it)&#125;</span><br><span class="line">     .sideEffect&#123;list.add(&quot;second: &quot;+it)&#125;</span><br><span class="line">     .iterate()</span><br><span class="line">list</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190410143940543.png" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 禁用自动barrier策略</span><br><span class="line">g = g.withoutStrategies(LazyBarrierStrategy)</span><br><span class="line">g.V()</span><br><span class="line"> .both().barrier()</span><br><span class="line"> .both().barrier()</span><br><span class="line"> .both().barrier()</span><br><span class="line"> .both().barrier()</span><br><span class="line"> .both().barrier()</span><br><span class="line"> .groupCount()</span><br><span class="line"> .order(local).by(values, decr)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190410144005464.png" alt=""></p>
<p>对比无barrier时的效果（消耗时间更长）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 通过lambda函数来指定放入口袋的行为</span><br><span class="line">// 注意：提供的初始值为Map类型，而且</span><br><span class="line">// 当traverser分裂时会拷贝Map</span><br><span class="line">g = g.withoutStrategies(LazyBarrierStrategy)</span><br><span class="line">g.V()</span><br><span class="line"> .both()</span><br><span class="line"> .both()</span><br><span class="line"> .both()</span><br><span class="line"> .both()</span><br><span class="line"> .both()</span><br><span class="line"> .groupCount()</span><br><span class="line"> .order(local).by(values, decr)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190410144025455.png" alt=""></p>
<p>注意：LazyBarrierStrategy是默认策略，该策略会在合适的地方插入barrier，因此这里先禁用了该策略。</p>
</li>
<li><p><code>barrier()</code>相关Step：</p>
<p>事实上除了可显示的插入barrier栅栏外，还有不少Step会隐式插入barrier，包括 <code>order()</code>, <code>sample()</code>, <code>dedup()</code>, <code>aggregate()</code>, <code>fold()</code>, <code>count()</code>, <code>sum()</code>, <code>max()</code>, <code>min()</code>, <code>group()</code>, <code>groupCount()</code>, <code>cap()</code>等。</p>
</li>
</ol>
<h4 id="综合运用-6"><a href="#综合运用-6" class="headerlink" title="综合运用"></a>综合运用</h4><ol>
<li><p>计算特征向量中心性（Eigenvector Centrality）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 利用隐式barrier计算特征向量中心性</span><br><span class="line">// 包括groupCount、cap，按照降序排序</span><br><span class="line">g.V().repeat(both().groupCount(&#x27;m&#x27;))</span><br><span class="line">     .times(5).cap(&#x27;m&#x27;)</span><br><span class="line">     .order(local).by(values, decr)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/2019041014404436.png" alt=""></p>
</li>
</ol>
<h3 id="局部操作local说明"><a href="#局部操作local说明" class="headerlink" title="局部操作local说明"></a>局部操作local说明</h3><p>通过Gremlin进行图遍历通常是当前step处理前一step传递过来的对象流。很多操作是针对传递过来的对象流中的全部对象进行操作，但也有很多时候需要针对对象流中的单个对象而非对象流中的全部对象进行一些操作。这种对单个对象的局部操作，可以使用<code>local()</code>语句实现。</p>
<p>另外，有一些step默认的操作是针对对象流中的全部对象，但也可以通过参数来改变默认操作，允许针对对象流中的单个对象进行操作，包括<code>count()</code>，<code>max()</code>，<code>mean()</code>，<code>min()</code>，<code>sum()</code>，<code>order()</code>，<code>tail()</code>，<code>limit()</code>，<code>range()</code>，<code>sample()</code>，<code>skip()</code>和<code>dedup()</code>等。</p>
<h4 id="实例说明-2"><a href="#实例说明-2" class="headerlink" title="实例说明"></a>实例说明</h4><ol>
<li><p>local的作用说明</p>
<p>是否使用<code>local()</code>的区别可以参见如下示意图：</p>
<p><img src="https://image.rexking6.top/img/local-step.png" alt=""></p>
<p>实例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 不使用local()</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).as(&#x27;person&#x27;)</span><br><span class="line"> .properties(&#x27;age&#x27;).order().by(value).limit(2)</span><br><span class="line"> .value().as(&#x27;age&#x27;)</span><br><span class="line"> .select(&#x27;person&#x27;,&#x27;age&#x27;).by(&#x27;name&#x27;).by()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180927180036350" alt="img"></p>
<p>实例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用local()</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).as(&#x27;person&#x27;)</span><br><span class="line"> .local(properties(&#x27;age&#x27;).order().by(value).limit(2))</span><br><span class="line"> .value().as(&#x27;age&#x27;)</span><br><span class="line"> .select(&#x27;person&#x27;,&#x27;age&#x27;).by(&#x27;name&#x27;).by()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180927180230660" alt=""></p>
<p><strong><em>这里应该是“所有人根据年龄排序选出最小的两个”变为“每个人根据年龄排序选出最小的两个”，所以就变成每个人都输出。</em></strong></p>
<p>为了跟TinkerPop官网的示意图配合，例子中的”age“属性只有一个，使用<code>order().by().limit(2)</code>有些多余。</p>
</li>
<li><p>以参数的形式指定局部操作</p>
<p>实例1 <code>count()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 查询软件HugeGraph的属性Map</span><br><span class="line">g.V().hasLabel(&#x27;software&#x27;).has(&#x27;name&#x27;, &#x27;HugeGraph&#x27;)</span><br><span class="line"> .propertyMap()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/201809281150255" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 查询软件HugeGraph的属性个数</span><br><span class="line">g.V().hasLabel(&#x27;software&#x27;).has(&#x27;name&#x27;, &#x27;HugeGraph&#x27;)</span><br><span class="line"> .propertyMap().count(local)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180928115221627" alt=""></p>
<p>试一下不加<code>local</code>结果是什么。</p>
<p>实例2 <code>max()</code>、<code>min()</code>、<code>mean()</code>、<code>sum()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 数目最多的顶点类型的顶点数目</span><br><span class="line">g.V().groupCount().by(label).select(values).max(local)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180928115919197" alt=""></p>
<p><code>min()</code>、<code>mean()</code>、<code>sum()</code>等与<code>max()</code>使用local参数的方法基本一致，不再赘述。</p>
<p>试一下不加<code>local</code>结果是什么。</p>
<p>实例3 <code>limit()</code>、<code>tail()</code>、<code>range()</code>、<code>skip()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 所有顶点的属性列表中的第一个属性</span><br><span class="line">g.V().valueMap().limit(local, 1)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180928120339915" alt=""></p>
<p><code>tail()</code>、<code>range()</code>、<code>skip()</code>与<code>limit()</code>使用local参数的方法基本一致，不再赘述。</p>
<p>试一下不加<code>local</code>结果是什么。</p>
<p>实例4 <code>dedup()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 所有顶点一步邻居中所有的software</span><br><span class="line">g.V().both().group().by(label).select(&#x27;software&#x27;).dedup(local)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180928120759516" alt=""></p>
<p>试一下不加<code>local</code>结果是什么。</p>
<p>实例5 <code>order()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 所有顶点按类型计数并按数目由多到少排序</span><br><span class="line">g.V().groupCount().by(label).order(local).by(values, decr)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180928131453914" alt=""></p>
<p>实例6 <code>sample()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 所有顶点作为一个集合，从中采样2个</span><br><span class="line">g.V().fold().sample(local,2)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180928131759140" alt=""></p>
</li>
</ol>
<h3 id="遍历终止说明"><a href="#遍历终止说明" class="headerlink" title="遍历终止说明"></a>遍历终止说明</h3><p>Gremlin 中有一类特殊的操作，它能够终止遍历器的“遍历”行为，使其执行并返回结果。在这里要强调的一点：原生的 Gremlin 语句通常都是用遍历器连接起来的，但其实这些连接的过程并不会执行 Gremlin 语句，只有走到了<code>terminal</code>Step 时才会执行。这个模式类似于 Spark 中对<code>RDD</code>的<code>map</code>和<code>action</code>操作。</p>
<ul>
<li><code>hasNext</code>: 判断遍历器是否含有元素（结果），返回布尔值；</li>
<li><code>next</code>: 不传参数时获取遍历器的下一个元素，也可以传入一个整数 n，则获取后面 n 个元素；</li>
<li><code>tryNext</code>: <code>hasNext</code>和<code>next</code>的结合版，返回一个Optional对象，如果有结果还需要调用<code>get()</code>方法才能拿到；</li>
<li><code>toList</code>: 将所有的元素放到一个<code>List</code>中返回；</li>
<li><code>toSet</code>: 将所有的元素放到一个<code>Set</code>中返回，会去除重复元素；</li>
<li><code>toBulkSet</code>: 将所有的元素放到一个能排序的<code>List</code>中返回，重复元素也会保留；</li>
<li><code>fill</code>: 传入一个集合对象，将所有的元素放入该集合并返回，其实<code>toList</code>、<code>toSet</code>和<code>toBulkSet</code>就是通过<code>fill</code>Step实现的；</li>
<li><code>iterate</code>: 这个 Step 在终止操作里面有点特殊，它并不完全符合终止操作的定义。它会在内部迭代完整个遍历器但是不返回结果。</li>
</ul>
<p>那肯定有细心的同学要问了，前面我们介绍了那么多的 Step 很多都没有加<code>terminal</code>Step 啊，为什么也能返回结果呢？其实这是 Tinkerpop 的 Gremlin 解析引擎对遍历器对象调用了一个<code>IteratorUtils.asList()</code>方法，又调用了它内部的<code>fill()</code>方法（注意：不是上面讲到的<code>fill()</code>Step）。</p>
<h4 id="实例讲解-15"><a href="#实例讲解-15" class="headerlink" title="实例讲解"></a>实例讲解</h4><p>下面通过实例来深入理解每一个操作。</p>
<ol>
<li><p><code>hasNext()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 判断顶点“linary”是否包含“created”出顶点</span><br><span class="line">g.V(&#x27;linary&#x27;).out(&#x27;created&#x27;).hasNext()</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 判断顶点“linary”是否包含“knows”出顶点</span><br><span class="line">g.V(&#x27;linary&#x27;).out(&#x27;knows&#x27;).hasNext()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>next()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取顶点“javeme”的“knows”出顶点集合的下一个（第1个）</span><br><span class="line">g.V(&#x27;javeme&#x27;).out(&#x27;knows&#x27;).next()</span><br></pre></td></tr></table></figure>
<p><code>g.V(&#39;javeme&#39;).out(&#39;knows&#39;)</code>返回的是一个遍历器（迭代器），每次执行这句话实际上都是获取的迭代器的第一个元素，那如果想获取第二个元素该怎么写呢？很简单，执行两次<code>next()</code>即可，但是这里的前提条件是遍历器中确实存在多个元素。</p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获取顶点“javeme”的“knows”出顶点集合的下一个（第2个）</span><br><span class="line">it = g.V(&#x27;javeme&#x27;).out(&#x27;knows&#x27;)</span><br><span class="line">it.next()</span><br><span class="line">it.next()</span><br></pre></td></tr></table></figure>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取顶点“javeme”的“knows”出顶点集合的前两个</span><br><span class="line">g.V(&#x27;javeme&#x27;).out(&#x27;knows&#x27;).next(2)</span><br></pre></td></tr></table></figure>
<p><code>next()</code>与<code>next(n)</code>使用中有一点小小的区别，就是当没有元素或者没有足够多的元素时，执行<code>next()</code>会报错，但是执行<code>next(n)</code>则是返回一个空集合（List）。</p>
</li>
<li><p><code>tryNext()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 试图获取顶点“javeme”的“created”出顶点集合中的下一个</span><br><span class="line">g.V(&#x27;javeme&#x27;).out(&#x27;created&#x27;).tryNext()</span><br></pre></td></tr></table></figure>
<p>这里细心的读者会发现结果与前面概述中说的有些不同。概述中说的是返回一个<code>Optional</code>对象，要获取<code>Optional</code>对象里的值是需要调用它的<code>get()</code>方法的，怎么这里直接就把值给返回了呢？大家先别着急，我们再看一个例子。</p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 试图获取顶点“javeme”的“created”入顶点集合中的下一个</span><br><span class="line">g.V(&#x27;javeme&#x27;).in(&#x27;created&#x27;).tryNext()</span><br></pre></td></tr></table></figure>
<p>这里更加令人费解，没有“created”入顶点时竟然直接报错了，其实这是<code>HugeGraph</code>的实现中关于Optional的序列化所致。<code>HugeGraph</code>序列化<code>Optional</code>对象时会判断该对象内的值是否存在，如果存在则取出来序列化该值，否则填入一个<code>null</code>。详细代码见<a target="_blank" rel="noopener" href="https://github.com/hugegraph/hugegraph/blob/master/hugegraph-core/src/main/java/com/baidu/hugegraph/io/HugeGraphSONModule.java">HugeGraphSONModule.java</a>中关于<code>OptionalSerializer</code>的实现。<br>本文的重点在于学习<code>Gremlin</code>语法本身，下面给出上述两个示例的预期结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional[v[3:HugeGraph]]</span><br><span class="line">Optional.empty</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toList()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有“person”顶点的“created”出顶点集合，放入List中，允许包含重复结果</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).out(&#x27;created&#x27;).toList()</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有“person”顶点的“created”入顶点集合，放入List中，允许包含重复结果</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).in(&#x27;created&#x27;).toList()</span><br></pre></td></tr></table></figure>
<p>结果与<code>next(n)</code>有些类似。</p>
</li>
<li><p><code>toSet()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有“person”顶点的“created”出顶点集合，放入Set中，不允许包含重复结果</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).out(&#x27;created&#x27;).toSet()</span><br></pre></td></tr></table></figure>
<p>相比于<code>toList</code>，<code>toSet</code>去除了重复元素。</p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有“person”顶点的“created”入顶点集合，放入Set中，不允许包含重复结果</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).in(&#x27;created&#x27;).toSet()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toBulkSet()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有“person”顶点的“created”出顶点集合，放入BulkSet中，允许包含重复结果，排序</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).out(&#x27;created&#x27;).toBulkSet()</span><br></pre></td></tr></table></figure>
<p>所谓的<code>BulkSet</code>虽然名字上带有”Set”，但还是更像一个List，对比<code>toList</code>的结果，它实际上是把所有元素排了个序。</p>
</li>
<li><p><code>fill()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个List，获取所有“person”顶点的“created”出顶点，并放入该List中</span><br><span class="line">results = []</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;).out(&#x27;created&#x27;).fill(results)</span><br><span class="line">results</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>iterate()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 迭代所有“person”顶点</span><br><span class="line">it = g.V().hasLabel(&#x27;person&#x27;).iterate()</span><br><span class="line">it.hasNext()</span><br></pre></td></tr></table></figure>
<p>调用了<code>iterate()</code>后遍历器内部的元素就已经全部迭代过了，所以再调用<code>hasNext()</code>返回false。</p>
</li>
</ol>
<h3 id="转换操作说明"><a href="#转换操作说明" class="headerlink" title="转换操作说明"></a>转换操作说明</h3><ul>
<li><code>map</code>: 可以接受一个遍历器 Step 或 Lamda 表达式，将遍历器中的元素映射（转换）成另一个类型的某个对象（一对一），以便进行下一步处理；</li>
<li><code>flatMap</code>: 可以接受一个遍历器 Step 或 Lamda 表达式，将遍历器中的元素映射（转换）成另一个类型的某个对象流或迭代器（一对多）。</li>
</ul>
<h4 id="实例讲解-16"><a href="#实例讲解-16" class="headerlink" title="实例讲解"></a>实例讲解</h4><p>下面通过实例来深入理解每一个操作。</p>
<ol>
<li><p><code>map()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 获取顶点“3:HugeGraph”的入“created”顶点的“name”属性，其实可以理解为顶点对象转化成了属性值对象</span><br><span class="line">g.V(&#x27;3:HugeGraph&#x27;).in(&#x27;created&#x27;).map(values(&#x27;name&#x27;))</span><br><span class="line">// g.V(&#x27;3:HugeGraph&#x27;).in(&#x27;created&#x27;).map &#123;it.get().value(&#x27;name&#x27;)&#125;</span><br></pre></td></tr></table></figure>
<p>自己动手将<code>g.V(&#39;3:HugeGraph&#39;).in(&#39;created&#39;).map &#123;it.get().value(&#39;name&#39;)&#125;</code>的注视打开试试效果。</p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 先获取顶点“3:HugeGraph”的入“created”顶点，再将每个顶点转化为出边（一条）</span><br><span class="line">g.V(&#x27;3:HugeGraph&#x27;).in(&#x27;created&#x27;).map(outE())</span><br></pre></td></tr></table></figure>
<p>注意：顶点“javeme”其实是有三条边的，但是这里只打印出了一条。因为<code>map</code>Step是一对一的转换，要想获取所有的边可以使用<code>flatMap</code>。</p>
</li>
<li><p><code>flatMap()</code></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 先获取顶点“3:HugeGraph”的入“created”顶点，再将每个顶点转化为出边（多条）</span><br><span class="line">g.V(&#x27;3:HugeGraph&#x27;).in(&#x27;created&#x27;).flatMap(outE())</span><br></pre></td></tr></table></figure>
<p>注意：这一次就能打印出顶点“javeme”的全部三条边了。</p>
</li>
</ol>
<h3 id="附加操作说明"><a href="#附加操作说明" class="headerlink" title="附加操作说明"></a>附加操作说明</h3><p>Gremlin在路径遍历的时候，可以在路径中做一些额外的附加操作，这个附加操作不会改变上一步的结果，会原封不动的传递到下一步去。附加操作看起来就像透明的，但实际上可以将附加操作的处理结果存储到外部变量中去。</p>
<p>下面讲解实现上述功能的具体Step：</p>
<ul>
<li><code>sideEffect()</code>: 在某个位置插入一个附加操作，以执行额外的操作，通常可与<code>store</code>、<code>sack</code>等配合使用。另外如下一些Step本质上也是<code>sideEffect</code>：<code>group(string)</code>、<code>groupCount(string)</code>、<code>subgraph(string)</code>、<code>aggregate(string)</code>、<code>inject(string)</code>、<code>profile(string)</code>等。</li>
<li><code>withSideEffect()</code>：绑定初始值到变量上，等价于<code>sideEffect</code>的效果。</li>
</ul>
<h4 id="实例讲解-17"><a href="#实例讲解-17" class="headerlink" title="实例讲解"></a>实例讲解</h4><p>下面通过实例来深入理解每一个操作。</p>
<ol>
<li><p><code>sideEffect()</code>： 附加操作</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将所有顶点打印出来</span><br><span class="line">// sideEffect本身不影响结果</span><br><span class="line">def list=[]</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;)</span><br><span class="line"> .sideEffect&#123;list.add(&quot;vertex:&quot;+it)&#125;</span><br><span class="line"> .toList()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190429205446664.png" alt=""></p>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将sideEffect处理的结果打印出来</span><br><span class="line">def list=[]</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;)</span><br><span class="line"> .sideEffect&#123;list.add(&quot;vertex:&quot;+it)&#125;</span><br><span class="line"> .toList()</span><br><span class="line">list</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190429205509217.png" alt=""></p>
<p>注意：Gremlin中的最后一行内容表示输出的结果。</p>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 将sideEffect结果存到变量中</span><br><span class="line">g.V().hasLabel(&#x27;person&#x27;)</span><br><span class="line"> .sideEffect(outE().count().store(&quot;o&quot;))</span><br><span class="line"> .sideEffect(inE().count().store(&quot;i&quot;))</span><br><span class="line"> .cap(&quot;o&quot;,&quot;i&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190429205527373.png" alt=""></p>
</li>
<li><p><code>withSideEffect()</code>： 绑定变量初始值</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 初始化一个变量以供后续条件判断中使用</span><br><span class="line">// 查找javeme的共同作者，且名称在初始集合中</span><br><span class="line">g.withSideEffect(&#x27;p&#x27;,[&#x27;Linary Li&#x27;,&#x27;Zhoney Zhang&#x27;,&#x27;Tom&#x27;])</span><br><span class="line"> .V(&#x27;javeme&#x27;).out(&#x27;created&#x27;).in(&#x27;created&#x27;)</span><br><span class="line"> .values(&#x27;name&#x27;).where(within(&#x27;p&#x27;))</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190429205541262.png" alt=""></p>
</li>
</ol>
<h4 id="综合运用-7"><a href="#综合运用-7" class="headerlink" title="综合运用"></a>综合运用</h4><ol>
<li><p>计算度中心性（Degree Centrality）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 利用sideEffect计算3种度中心性</span><br><span class="line">g.V().group(&#x27;both&#x27;).by().by(bothE().count())</span><br><span class="line">     .group(&#x27;out&#x27;).by().by(outE().count())</span><br><span class="line">     .group(&#x27;in&#x27;).by().by(inE().count())</span><br><span class="line">     .cap(&#x27;both&#x27;, &#x27;out&#x27;, &#x27;in&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20190429205556817.png" alt=""></p>
</li>
</ol>
<h3 id="统计和分析说明"><a href="#统计和分析说明" class="headerlink" title="统计和分析说明"></a>统计和分析说明</h3><p>Gremlin提供了两种语句来帮助用户对执行的查询语句进行统计和分析工作：</p>
<ul>
<li><code>explain()</code>，详细描述原始的Gremlin语句在编译期是如何转变为最终要执行的step集合的</li>
<li><code>profile()</code>，统计Gremlin语句执行过程中的每个step消耗的时间和通过的对象等统计信息</li>
</ul>
<p><code>TraversalStrategy</code>是“遍历策略”，可以在编译期分析遍历（<code>Traversal</code>）的组成，并在遍历满足<code>TraversalStrategy</code>的条件时对遍历进行修改。这些修改往往都是为了能够更加高效的执行遍历。</p>
<p>遍历策略有5类：</p>
<ul>
<li><code>Decoration</code>，应用程序级别的策略</li>
<li><code>Optimization</code>，TinkerPop3级别的策略</li>
<li><code>Provider optimization</code>，图数据库实现级别的策略</li>
<li><code>Finalization</code>，遍历执行前的调整和清理策略</li>
<li><code>Verification</code>，判断遍历是否合法的验证策略</li>
</ul>
<h4 id="实例说明-3"><a href="#实例说明-3" class="headerlink" title="实例说明"></a>实例说明</h4><p>实例1 <code>explain()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(&#x27;person&#x27;).outE().identity().inV().count().is(gt(5)).explain()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180928161628651" alt=""></p>
<p>结果中：</p>
<ul>
<li><code>original</code>，表示Gremlin语句等价的最初的step列表</li>
<li><code>intermediate</code>，表示<code>original</code>转化在<code>TraversalStrategy</code>作用下的转化过程<ul>
<li><code>strategy</code>，表示作用于上一轮的step列表的<code>TraversalStrategy</code></li>
<li><code>category</code>，表示<code>strategy</code>中的<code>TraversalStrategy</code>所属的级别，参见说明部分</li>
<li><code>traversal</code>，表示上一轮的step列表经过<code>strategy</code>中的<code>TraversalStrategy</code>处理之后的新的step列表</li>
</ul>
</li>
<li><code>final</code>，表示经过所有<code>TraversalStrategy</code>处理后的最终要执行的step列表</li>
</ul>
<p>实例2 <code>profile()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.V().out(&#x27;created&#x27;).profile()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180928150731149" alt=""></p>
<p>返回的结果中，metrics中每一条是一个执行的step，其中：</p>
<ul>
<li><code>name</code>是step的名字，例如”HugeGraphStep(vertex,[])”</li>
<li><code>dur</code>是step执行的时间，单位是毫秒</li>
<li><code>annotations</code>中的<code>percentDur</code>是当前step消耗的时间在总的执行时间中的比例</li>
<li><code>counts</code>中的<code>traverserCount</code>是当前step中的traverser的数目</li>
<li><code>counts</code>中的<code>elementCount</code>是当前step中的element的数目</li>
</ul>
<p><code>traverserCount</code>和<code>elementCount</code>的区别在于： <code>traverserCount</code>是同一step中相同的对象合并之后的数目，对象相同是指当前的对象是一样的，并不代表对象的path等其他数据也相同；相同的对象合并为bulk，可以减少重复工作，提高效率。<code>elementCount</code>是同一step中所有对象展开bulk之后的数目之和，即未去重的对象数目。因此，<code>traverserCount</code>总是小于等于<code>elementCount</code>。</p>
<p><code>profile()</code>语句是一个“副作用”（side effect）语句，并非立刻执行。<code>profile()</code>语句还可以指定一个key，形式为<code>profile(String)</code>，在执行完要统计的Gremlin语句后，通过key获取统计信息。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t=g.V().out(&#x27;created&#x27;).profile(&#x27;metrics&#x27;)</span><br><span class="line">t.iterate()</span><br><span class="line">t.getSideEffects().get(&#x27;metrics&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/20180928153220587" alt=""></p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2017\07\10\MySQL存储引擎\" rel="bookmark">MySQL存储引擎</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2017\08\28\MySQL知识点\" rel="bookmark">MySQL</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2017\09\02\Redis知识点\" rel="bookmark">Redis知识点</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div>一分一毛，也是心意。</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Run-Qing Chen 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Run-Qing Chen 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Run-Qing Chen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://blog.rexking6.top/2021/07/25/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/" title="图数据库">https://blog.rexking6.top/2021/07/25/图数据库/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%BC%80%E5%8F%91/" rel="tag"># 开发</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/24/Docker-k8s/" rel="prev" title="Docker & k8s">
      <i class="fa fa-chevron-left"></i> Docker & k8s
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/08/30/A-B%E6%B5%8B%E8%AF%95/" rel="next" title="A/B测试">
      A/B测试 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

    <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93-vs-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93"><span class="nav-number">2.</span> <span class="nav-text">数据库 vs 数据仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%B5%E5%95%86%E4%BE%8B%E5%AD%90"><span class="nav-number">2.2.</span> <span class="nav-text">电商例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E4%B9%A6%E7%B3%BB%E7%BB%9F%E4%BE%8B%E5%AD%90"><span class="nav-number">2.3.</span> <span class="nav-text">图书系统例子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%AF%B9%E6%AF%94"><span class="nav-number">2.3.1.</span> <span class="nav-text">存储空间对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E4%BC%98%E5%8C%96%E5%AF%B9%E6%AF%94"><span class="nav-number">2.3.2.</span> <span class="nav-text">读写优化对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E3%80%81%E5%8D%8A%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E5%92%8C%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE"><span class="nav-number">3.</span> <span class="nav-text">结构化数据、半结构化数据和非结构化数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE"><span class="nav-number">3.1.</span> <span class="nav-text">结构化数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8A%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE"><span class="nav-number">3.2.</span> <span class="nav-text">半结构化数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE"><span class="nav-number">3.3.</span> <span class="nav-text">非结构化数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-vs-%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">4.</span> <span class="nav-text">关系型数据库 vs 非关系型数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">4.1.</span> <span class="nav-text">关系型数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">4.1.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%93%B6%E9%A2%88"><span class="nav-number">4.1.2.</span> <span class="nav-text">瓶颈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%BD%99%E7%89%B9%E6%80%A7"><span class="nav-number">4.1.3.</span> <span class="nav-text">多余特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E6%B5%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">4.1.4.</span> <span class="nav-text">主流关系型数据库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSQL"><span class="nav-number">4.2.</span> <span class="nav-text">非关系型数据库NoSQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-1"><span class="nav-number">4.2.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">4.2.2.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAP%E7%90%86%E8%AE%BA"><span class="nav-number">4.2.3.</span> <span class="nav-text">CAP理论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-vs-%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-1"><span class="nav-number">4.3.</span> <span class="nav-text">关系型数据库  vs 非关系型数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%B1%BB"><span class="nav-number">4.4.</span> <span class="nav-text">非关系型数据库分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99%E7%9A%84key-value%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">4.4.1.</span> <span class="nav-text">面向高性能并发读写的key-value数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E7%9A%84%E9%9D%A2%E5%90%91%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">4.4.2.</span> <span class="nav-text">面向海量数据访问的面向文档数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E6%90%9C%E7%B4%A2%E6%95%B0%E6%8D%AE%E5%86%85%E5%AE%B9%E7%9A%84%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E"><span class="nav-number">4.4.3.</span> <span class="nav-text">面向搜索数据内容的搜索引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E9%9D%A2%E5%90%91%E5%88%97%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%89"><span class="nav-number">4.4.4.</span> <span class="nav-text">面向可扩展性的分布式数据库（面向列的数据库）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%85%B3%E7%B3%BB%E5%88%86%E6%9E%90%E7%9A%84%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">4.4.5.</span> <span class="nav-text">面向关系分析的图数据库</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">5.</span> <span class="nav-text">图数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E8%B0%88%E8%B5%B7"><span class="nav-number">5.1.</span> <span class="nav-text">从社交网络谈起</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="nav-number">5.2.</span> <span class="nav-text">传统数据库的解决思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">5.2.1.</span> <span class="nav-text">传统数据库的概念模型及查询的代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">5.2.2.</span> <span class="nav-text">传统关系数据库的性能问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%B8%B8%E8%A7%84%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="nav-number">5.2.3.</span> <span class="nav-text">传统数据库的常规优化策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E4%B8%80%EF%BC%9A%E7%B4%A2%E5%BC%95"><span class="nav-number">5.2.3.1.</span> <span class="nav-text">策略一：索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E4%BA%8C%EF%BC%9A%E7%BC%93%E5%AD%98"><span class="nav-number">5.2.3.2.</span> <span class="nav-text">策略二：缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%BB%93%E6%9E%84%E5%BB%BA%E6%A8%A1"><span class="nav-number">5.3.</span> <span class="nav-text">使用图结构建模</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%82%B9%E3%80%81%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E5%92%8C%E5%9B%BE%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.3.1.</span> <span class="nav-text">点、关联关系和图数据模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8-amp-%E5%A4%84%E7%90%86%E5%BC%95%E6%93%8E"><span class="nav-number">5.4.</span> <span class="nav-text">底层存储 &amp; 处理引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-amp-%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">5.5.</span> <span class="nav-text">知识图谱 &amp; 图数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6Tinkerpop"><span class="nav-number">5.6.</span> <span class="nav-text">图计算框架Tinkerpop</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E5%9B%BE%E8%AE%A1%E7%AE%97"><span class="nav-number">5.6.1.</span> <span class="nav-text">是图计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFTinkerPop"><span class="nav-number">5.6.2.</span> <span class="nav-text">什么是TinkerPop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">5.6.3.</span> <span class="nav-text">体系结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%9B%BE-vs-RDF"><span class="nav-number">5.7.</span> <span class="nav-text">属性图 vs RDF</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%9B%BE%EF%BC%88Property-Graphs%EF%BC%89"><span class="nav-number">5.7.1.</span> <span class="nav-text">属性图（Property Graphs）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E6%8F%8F%E8%BF%B0%E6%A1%86%E6%9E%B6%E5%9B%BE%EF%BC%88RDF-Graphs%EF%BC%89"><span class="nav-number">5.7.2.</span> <span class="nav-text">资源描述框架图（RDF Graphs）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-number">5.7.2.1.</span> <span class="nav-text">序列化方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%80%85%E7%9A%84%E6%AF%94%E8%BE%83%E4%B8%8E%E8%BD%AC%E5%8C%96"><span class="nav-number">5.7.3.</span> <span class="nav-text">二者的比较与转化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%9C%A8%E8%A1%A8%E8%BE%BE%E7%9A%84%E6%9C%AF%E8%AF%AD%E5%92%8C%E8%83%BD%E5%8A%9B%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">5.7.3.1.</span> <span class="nav-text">1. 在表达的术语和能力上的不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%9C%A8%E8%BE%B9%E4%B8%8A%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="nav-number">5.7.3.2.</span> <span class="nav-text">2. 在边上附加信息的差异</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%9B%BE%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9B%BE%E7%9A%84%E5%88%92%E5%88%86"><span class="nav-number">5.7.3.3.</span> <span class="nav-text">3. 图分析算法与图的划分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%B1%9E%E6%80%A7%E5%9B%BE%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">5.7.3.4.</span> <span class="nav-text">4. 属性图的局限性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-RDF%E5%9B%BE%E4%B8%8E%E5%B1%9E%E6%80%A7%E5%9B%BE%E5%88%B0%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E5%8C%96"><span class="nav-number">5.7.3.5.</span> <span class="nav-text">5. RDF图与属性图到知识图谱之间的转化</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80"><span class="nav-number">6.</span> <span class="nav-text">查询语言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#nGQL"><span class="nav-number">6.1.</span> <span class="nav-text">nGQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cypher"><span class="nav-number">6.2.</span> <span class="nav-text">Cypher</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gremlin"><span class="nav-number">6.3.</span> <span class="nav-text">Gremlin</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">6.3.1.</span> <span class="nav-text">图基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">6.3.2.</span> <span class="nav-text">图基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E9%81%8D%E5%8E%86%E6%A6%82%E5%BF%B5"><span class="nav-number">6.3.3.</span> <span class="nav-text">边遍历概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3"><span class="nav-number">6.3.3.1.</span> <span class="nav-text">实例讲解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8"><span class="nav-number">6.3.3.2.</span> <span class="nav-text">综合运用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Has-Step%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.4.</span> <span class="nav-text">Has Step说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3-1"><span class="nav-number">6.3.4.1.</span> <span class="nav-text">实例讲解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E6%95%B0%E9%99%90%E5%88%B6"><span class="nav-number">6.3.5.</span> <span class="nav-text">图查询返回结果数限制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3-2"><span class="nav-number">6.3.5.1.</span> <span class="nav-text">实例讲解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Path%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.6.</span> <span class="nav-text">Path说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3-3"><span class="nav-number">6.3.6.1.</span> <span class="nav-text">实例讲解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.7.</span> <span class="nav-text">循环操作说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3-4"><span class="nav-number">6.3.7.1.</span> <span class="nav-text">实例讲解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8-1"><span class="nav-number">6.3.7.2.</span> <span class="nav-text">综合运用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%92%8C%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.8.</span> <span class="nav-text">条件和过滤操作说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3-5"><span class="nav-number">6.3.8.1.</span> <span class="nav-text">实例讲解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.9.</span> <span class="nav-text">逻辑运算说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3-6"><span class="nav-number">6.3.9.1.</span> <span class="nav-text">实例讲解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8-2"><span class="nav-number">6.3.9.2.</span> <span class="nav-text">综合运用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E8%BF%90%E7%AE%97%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.10.</span> <span class="nav-text">统计运算说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3-7"><span class="nav-number">6.3.10.1.</span> <span class="nav-text">实例讲解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.11.</span> <span class="nav-text">数学运算说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.11.1.</span> <span class="nav-text">实例说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E9%80%89%E5%8F%96%E4%B8%8E%E8%BF%87%E6%BB%A4%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.12.</span> <span class="nav-text">路径选取与过滤说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3-8"><span class="nav-number">6.3.12.1.</span> <span class="nav-text">实例讲解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8-3"><span class="nav-number">6.3.12.2.</span> <span class="nav-text">综合运用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.13.</span> <span class="nav-text">分支操作说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3-9"><span class="nav-number">6.3.13.1.</span> <span class="nav-text">实例讲解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.14.</span> <span class="nav-text">合并操作说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3-10"><span class="nav-number">6.3.14.1.</span> <span class="nav-text">实例讲解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%9C%E8%81%9A%E9%9B%86%E4%B8%8E%E5%B1%95%E5%BC%80%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.15.</span> <span class="nav-text">结果聚集与展开说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3-11"><span class="nav-number">6.3.15.1.</span> <span class="nav-text">实例讲解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8-4"><span class="nav-number">6.3.15.2.</span> <span class="nav-text">综合运用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.16.</span> <span class="nav-text">模式匹配说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E-1"><span class="nav-number">6.3.16.1.</span> <span class="nav-text">实例说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E8%BF%87%E6%BB%A4%E4%B8%8E%E6%B3%A8%E5%85%A5%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.17.</span> <span class="nav-text">随机过滤与注入说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E8%BF%87%E6%BB%A4%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.17.1.</span> <span class="nav-text">随机过滤说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.17.2.</span> <span class="nav-text">注入说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3-12"><span class="nav-number">6.3.17.3.</span> <span class="nav-text">实例讲解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%9C%E5%AD%98%E5%8F%96%E5%8F%A3%E8%A2%8B%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.18.</span> <span class="nav-text">结果存取口袋说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3-13"><span class="nav-number">6.3.18.1.</span> <span class="nav-text">实例讲解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8-5"><span class="nav-number">6.3.18.2.</span> <span class="nav-text">综合运用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E6%A0%85%E6%A0%8F%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.19.</span> <span class="nav-text">遍历栅栏说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3-14"><span class="nav-number">6.3.19.1.</span> <span class="nav-text">实例讲解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8-6"><span class="nav-number">6.3.19.2.</span> <span class="nav-text">综合运用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%93%8D%E4%BD%9Clocal%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.20.</span> <span class="nav-text">局部操作local说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E-2"><span class="nav-number">6.3.20.1.</span> <span class="nav-text">实例说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E7%BB%88%E6%AD%A2%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.21.</span> <span class="nav-text">遍历终止说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3-15"><span class="nav-number">6.3.21.1.</span> <span class="nav-text">实例讲解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.22.</span> <span class="nav-text">转换操作说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3-16"><span class="nav-number">6.3.22.1.</span> <span class="nav-text">实例讲解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%84%E5%8A%A0%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.23.</span> <span class="nav-text">附加操作说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3-17"><span class="nav-number">6.3.23.1.</span> <span class="nav-text">实例讲解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8-7"><span class="nav-number">6.3.23.2.</span> <span class="nav-text">综合运用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E5%92%8C%E5%88%86%E6%9E%90%E8%AF%B4%E6%98%8E"><span class="nav-number">6.3.24.</span> <span class="nav-text">统计和分析说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E-3"><span class="nav-number">6.3.24.1.</span> <span class="nav-text">实例说明</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Run-Qing Chen"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Run-Qing Chen</p>
  <div class="site-description" itemprop="description">覆苍天以为衾，卧大地以为庐。</div>
</div>


   <div class="feed-link motion-element">
     <a href="/atom.xml" rel="alternate">
       <i class="fa fa-rss"></i>
       RSS
     </a>
   </div>
 
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">241</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">85</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">84</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RexKing6" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RexKing6" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1010026261@qq.com" title="E-Mail → mailto:1010026261@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://zhimi.vercel.app/index_zh-cn.html" title="https:&#x2F;&#x2F;zhimi.vercel.app&#x2F;index_zh-cn.html" rel="noopener" target="_blank">執迷</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://whitepuffer.github.io/" title="https:&#x2F;&#x2F;whitepuffer.github.io&#x2F;" rel="noopener" target="_blank">江斓</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kexue.fm/" title="https:&#x2F;&#x2F;kexue.fm&#x2F;" rel="noopener" target="_blank">科学空间</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yongyuan.name/" title="https:&#x2F;&#x2F;yongyuan.name&#x2F;" rel="noopener" target="_blank">袁勇</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/abcjennifer" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;abcjennifer" rel="noopener" target="_blank">Rachel Zhang</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://dmkf.xyz/" title="http:&#x2F;&#x2F;dmkf.xyz&#x2F;" rel="noopener" target="_blank">代码咖啡</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://wuxiaolong.me/" title="http:&#x2F;&#x2F;wuxiaolong.me&#x2F;" rel="noopener" target="_blank">吴小龙同学</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.tennfy.com/" title="http:&#x2F;&#x2F;www.tennfy.com&#x2F;" rel="noopener" target="_blank">TENNFY WU</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fab fa-accessible-icon"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Run-Qing Chen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">4.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">64:09</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"6XDsO3aHIjDk3nV6eLJCufbl-MdYXbMMI","app_key":"YK4qOc0TpkazN6exhuqsnwmB","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
