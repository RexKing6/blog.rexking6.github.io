<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.rexking6.top","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#37c6c0","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"YS7HT61SEB","apiKey":"0fd1eba022e7883c76ff4a71aee2acdc","indexName":"blog_NAME","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"找不到关于 ${query} 的文章","hits_stats":"共找到 ${hits} 篇文章，花了 ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="...">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker &amp; k8s">
<meta property="og:url" content="https://blog.rexking6.top/2021/07/24/Docker-k8s/">
<meta property="og:site_name" content="RexKing6&#39;s Note">
<meta property="og:description" content="...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.rexking6.top/img/a55676f8e1b084a398f8cd5f85cdae7d_r.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/9acf7b0482902a634f654ae8d7e7fbe1_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/b642b741b04857b513824913d0e71863_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/b7849abcf2233f18b62df90d134b2295_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/1e2589df4b3c7caa86e361e3f8796080_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/be14da9aaf55270380dae3f37eabda7e_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/f3cc3fca72da988a748cc87173d36e1a_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/0f8566256a31169d93094fd0b90c9720_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/v2-fa6224083928d42567d8b1a1282e9b31_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/v2-09f5aba883098583bf7d4d096cfe3e44_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/v2-fab4fbe4180d392f1ee858d7d885edb6_720w.jpg">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2016/04/576507-docker1.png">
<meta property="og:image" content="https://image.rexking6.top/img/docker27.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2016/05/docker-run-d.png">
<meta property="og:image" content="https://image.rexking6.top/img/docker-run-d2.png">
<meta property="og:image" content="https://image.rexking6.top/img/docker23.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2016/05/docker-attach.png">
<meta property="og:image" content="https://image.rexking6.top/img/docker-exec.png">
<meta property="og:image" content="https://image.rexking6.top/img/docker31.png">
<meta property="og:image" content="https://image.rexking6.top/img/423F2A2C-287A-4B03-855E-6A78E125B346.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/docker-net.png">
<meta property="og:image" content="https://image.rexking6.top/img/docker-net2.png">
<meta property="og:image" content="https://image.rexking6.top/img/docker-net3.png">
<meta property="og:image" content="https://image.rexking6.top/img/docker-net4.png">
<meta property="og:image" content="https://image.rexking6.top/img/docker-net5.png">
<meta property="og:image" content="https://image.rexking6.top/img/docker-net6.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2019/10/docker-search22.png">
<meta property="og:image" content="https://image.rexking6.top/img/dockerfile1.png">
<meta property="og:image" content="https://image.rexking6.top/img/dockerfile2.png">
<meta property="og:image" content="https://image.rexking6.top/img/v2-09f5aba883098583bf7d4d096cfe3e44_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/image-20210724195932964.png">
<meta property="og:image" content="https://image.rexking6.top/img/v2-4db17c30464263fc0291c5e625d84645_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/v2-18ca461d2374acad017e0484dd4fc982_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/image-20210724201759937.png">
<meta property="og:image" content="https://image.rexking6.top/img/image-20210724201842455.png">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-3bd329c8c154fad6d55890c817efb170_720w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-b8700d330dcb53af12974b4dcb11cae7_720w.jpg">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2019/11/docker-composex.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine1.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine3.png">
<meta property="og:image" content="https://image.rexking6.top/img/services-diagram.png">
<meta property="og:image" content="https://image.rexking6.top/img/swarm2.png">
<meta property="og:image" content="https://image.rexking6.top/img/swarm3.png">
<meta property="og:image" content="https://image.rexking6.top/img/swarm4.png">
<meta property="og:image" content="https://image.rexking6.top/img/swarm5.png">
<meta property="og:image" content="https://image.rexking6.top/img/swarm6.png">
<meta property="og:image" content="https://image.rexking6.top/img/swarm7.png">
<meta property="og:image" content="https://image.rexking6.top/img/swarm8.png">
<meta property="og:image" content="https://image.rexking6.top/img/swarm9.png">
<meta property="og:image" content="https://image.rexking6.top/img/swarm10.png">
<meta property="og:image" content="https://image.rexking6.top/img/swarm11.png">
<meta property="og:image" content="https://image.rexking6.top/img/swarm12.png">
<meta property="og:image" content="https://image.rexking6.top/img/swarm13.png">
<meta property="og:image" content="https://image.rexking6.top/img/swarm14.png">
<meta property="og:image" content="https://image.rexking6.top/img/swarm16.png">
<meta property="og:image" content="https://image.rexking6.top/img/swarm17.png">
<meta property="og:image" content="https://image.rexking6.top/img/swarm19.png">
<meta property="og:image" content="https://image.rexking6.top/img/image-20210724210117858.png">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-7305c00631afe335a217ad23af43a040_720w.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-0e673b996fb2541b72278e169c1afff4_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/v2-df516572fbdf315050a91e6cace07604_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/image-20210724234936410.png">
<meta property="og:image" content="https://image.rexking6.top/img/image-20210724235918835.png">
<meta property="og:image" content="https://image.rexking6.top/img/v2-3ab9824b444f4ec4f17b3bdb95017881_720w.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/image-20210725000027235.png">
<meta property="og:image" content="https://image.rexking6.top/img/image-20210725000128301.png">
<meta property="og:image" content="https://image.rexking6.top/img/18885539-d5d52769d1469bfe.png">
<meta property="article:published_time" content="2021-07-24T01:44:40.000Z">
<meta property="article:modified_time" content="2021-07-25T05:18:46.961Z">
<meta property="article:author" content="Run-Qing Chen">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.rexking6.top/img/a55676f8e1b084a398f8cd5f85cdae7d_r.jpg">

<link rel="canonical" href="https://blog.rexking6.top/2021/07/24/Docker-k8s/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Docker & k8s | RexKing6's Note</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="RexKing6's Note" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RexKing6's Note</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/rexking6" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.rexking6.top/2021/07/24/Docker-k8s/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Run-Qing Chen">
      <meta itemprop="description" content="覆苍天以为衾，卧大地以为庐。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RexKing6's Note">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Docker & k8s
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-24 09:44:40" itemprop="dateCreated datePublished" datetime="2021-07-24T09:44:40+08:00">2021-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-25 13:18:46" itemprop="dateModified" datetime="2021-07-25T13:18:46+08:00">2021-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
            </span>

          
            <span id="/2021/07/24/Docker-k8s/" class="post-meta-item leancloud_visitors" data-flag-title="Docker & k8s" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>68k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>1:01</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>了解一下Docker和k8s。综合转载于：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21641778/answer/62523535">有哪些通俗易懂的例子可以解释 IaaS、PaaS、SaaS 的区别？ - 何足道的回答 - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/391085208">一文快速了解 Docker 和 Kubernetes</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-tutorial.html">Docker 教程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38328477/article/details/86712892">docker&amp;k8s入门详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b7374f4e1e8f">docker restart、start、stop与容器文件系统</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/62985699/answer/204233732">openstack，docker，mesos，k8s什么关系？ - 张乾的回答 - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://os.51cto.com/art/202007/622553.htm">Docker不香吗，为啥还要K8s？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/304c629d127c">k8s常见命令</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/create-cluster/cluster-interactive/">交互式教程</a></li>
</ul>
<h1 id="On-Premises、IaaS、PaaS、SaaS与Serverless"><a href="#On-Premises、IaaS、PaaS、SaaS与Serverless" class="headerlink" title="On-Premises、IaaS、PaaS、SaaS与Serverless"></a>On-Premises、IaaS、PaaS、SaaS与Serverless</h1><p><img src="https://image.rexking6.top/img/a55676f8e1b084a398f8cd5f85cdae7d_r.jpg" alt=""></p>
<p>云计算中的三个“高大上”的概念：IaaS、PaaS和SaaS，这几个术语并不好理解。</p>
<p>换个例子理解，一个“吃货”是怎样吃到披萨的呢?</p>
<ol>
<li><p>在家自己做</p>
<p>这真是个麻烦事，你的准备很多东西，发面、做面团、进烤箱。简单列一下，需要下图所示的一切：</p>
<p><img src="https://image.rexking6.top/img/9acf7b0482902a634f654ae8d7e7fbe1_720w.jpg" alt=""></p>
</li>
<li><p>买好速食披萨回家自己做着吃</p>
<p>你只需要从披萨店里买回成品，回家烘焙就好了，在自己的餐桌上吃。和自己在家做不同，你需要一个pizza供应商。</p>
<p><img src="https://image.rexking6.top/img/b642b741b04857b513824913d0e71863_720w.jpg" alt=""></p>
</li>
<li><p>打电话叫外卖将披萨送到家中</p>
<p>打个电话，pizza就送到家门口。</p>
<p><img src="https://image.rexking6.top/img/b7849abcf2233f18b62df90d134b2295_720w.jpg" alt=""></p>
</li>
<li><p>在披萨店吃披萨</p>
<p>你什么都不需要准备，连餐桌也是pizza店的。</p>
<p><img src="https://image.rexking6.top/img/1e2589df4b3c7caa86e361e3f8796080_720w.jpg" alt=""></p>
</li>
</ol>
<p>总结一下，吃货可以通过如下途径吃披萨：</p>
<p><img src="https://image.rexking6.top/img/be14da9aaf55270380dae3f37eabda7e_720w.jpg" alt=""></p>
<p>好了，现在忘掉pizza!</p>
<p>假设你是一家超牛X的技术公司，根本不需要别人提供服务，你拥有基础设施、应用等等其它一切，你把它们分为三层：<strong>基础设施（infrastructure）、平台（platform）和软件（software）</strong>，如下图：</p>
<p><img src="https://image.rexking6.top/img/f3cc3fca72da988a748cc87173d36e1a_720w.jpg" alt=""></p>
<p>这其实就是云计算的三个分层，基础设施在最下端，平台在中间，软件在顶端，分别是分别是Infrastructure-as-a-Service（IaaS），Platform-as-a-Service（PaaS），Software-as-a-Service（SaaS），别的一些“软”的层可以在这些层上面添加。</p>
<p>而你的公司什么都有，现在所处的状态叫本地部署（On-Premises），就像在自己家做pizza一样。几年前如果你想在办公室或者公司的网站上运行一些企业应用，你需要去买服务器，或者别的高昂的硬件来控制本地应用，让你的业务运行起来，这就叫本地部署。</p>
<p>假如你家BOSS突然有一天想明白了，只是为了吃上pizza，为什么非要自己做呢？于是，准备考虑一家云服务供应商，这个云服务供应商能提供哪些服务呢？其所能提供的云服务也就是云计算的三个分层：IaaS、PaaS和SaaS，就像pizza店提供三种服务：买成品回家做、外卖和到披萨店吃。</p>
<p>用一张图来表示就是这样的。</p>
<p><img src="https://image.rexking6.top/img/0f8566256a31169d93094fd0b90c9720_720w.jpg" alt=""></p>
<p>现在我们来谈谈具体细节。</p>
<ul>
<li><p><strong>IaaS</strong>：Infrastructure-as-a-Service（基础设施即服务）</p>
<p>有了IaaS，你可以将硬件外包到别的地方去。IaaS公司会提供场外服务器，存储和网络硬件，你可以租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行其应用。</p>
<p>一些大的IaaS公司包括Amazon，Microsoft，VMWare，Rackspace和Red Hat。不过这些公司又都有自己的专长，比如Amazon和微软给你提供的不只是IaaS，他们还会将其计算能力出租给你来host你的网站。</p>
</li>
<li><p><strong>PaaS</strong>：Platform-as-a-Service（平台即服务）</p>
<p>第二层就是所谓的PaaS，某些时候也叫做中间件。你公司所有的开发都可以在这一层进行，节省了时间和资源。</p>
<p>PaaS公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，也让分散的工作室之间的合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。</p>
<p>一些大的PaaS提供者有Google App Engine，Microsoft Azure，Force.com，Heroku，Engine Yard。最近兴起的公司有AppFog，Mendix和Standing Cloud。</p>
</li>
<li><p><strong>SaaS</strong>：Software-as-a-Service(软件即服务)</p>
<p>第三层也就是所谓SaaS。这一层是和你的生活每天接触的一层，大多是通过网页浏览器来接入。任何一个远程服务器上的应用都可以通过网络来运行，就是SaaS了。</p>
<p>你消费的服务完全是从网页如Netflix，MOG，Google Apps，Box.net，Dropbox或者苹果的iCloud那里进入这些分类。尽管这些网页服务是用作商务和娱乐或者两者都有，但这也算是云技术的一部分。</p>
<p>一些用作商务的SaaS应用包括Citrix的Go To Meeting，Cisco的WebEx，Salesforce的CRM，ADP，Workday和SuccessFactors。</p>
</li>
<li><p>Serverless：无服务，不需要服务器。站在用户的角度考虑问题，用户只需要使用云服务器即可，在云服务器所在的基础环境，软件环境都不需要用户关心。</p>
</li>
</ul>
<h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h2><p>为了让应用程序(项目，服务软件)都运行在云上的解决方案，这样的方案叫做云原生。</p>
<p>云原生有如下特点：</p>
<ul>
<li>容器化，所有服务都必须部署在容器中</li>
<li>微服务，Web 服务架构式服务架构</li>
<li>CI/CD</li>
<li>DevOps</li>
</ul>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p>Docker 是一个开源的应用容器引擎，是一种资源虚拟化技术，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上。虚拟化技术演历路径可分为三个时代：</p>
<ol>
<li><p>物理机时代，多个应用程序可能跑在一台物理机器上</p>
<p><img src="https://image.rexking6.top/img/v2-fa6224083928d42567d8b1a1282e9b31_720w.jpg" alt=""></p>
</li>
<li><p>虚拟机时代，一台物理机器启动多个虚拟机实例，一个虚拟机跑多个应用程序</p>
<p><img src="https://image.rexking6.top/img/v2-09f5aba883098583bf7d4d096cfe3e44_720w.jpg" alt=""></p>
</li>
<li><p>容器化时代，一台物理机上启动多个容器实例，一个容器跑多个应用程序</p>
<p><img src="https://image.rexking6.top/img/v2-fab4fbe4180d392f1ee858d7d885edb6_720w.jpg" alt=""></p>
</li>
</ol>
<p>在没有 Docker 的时代，我们会使用硬件虚拟化（虚拟机）以提供隔离。这里，虚拟机通过在操作系统上建立了一个中间虚拟软件层 Hypervisor ，并利用物理机器的资源虚拟出多个虚拟硬件环境来共享宿主机的资源，其中的应用运行在虚拟机内核上。但是，虚拟机对硬件的利用率存在瓶颈，因为虚拟机很难根据当前业务量动态调整其占用的硬件资源，加之容器化技术蓬勃发展使其得以流行。</p>
<p>Docker与虚拟机对比：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>Docker</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动速度</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>交付/部署</td>
<td>开发、测试、生产环境一致</td>
<td>-</td>
</tr>
<tr>
<td>性能</td>
<td>近似物理机</td>
<td>性能损耗大</td>
</tr>
<tr>
<td>体量</td>
<td>极小（MB）</td>
<td>较大（GB）</td>
</tr>
<tr>
<td>迁移/扩展</td>
<td>跨平台、可复制</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<p>另外开发人员在实际的工作中，经常会遇到测试环境或生产环境与本地开发环境不一致的问题，轻则修复保持环境一致，重则可能需要返工。但 Docker 恰好解决了这一问题，它将软件程序和运行的基础环境分开。开发人员编码完成后将程序整合环境通过 DockerFile 打包到一个容器镜像中，从根本上解决了环境不一致的问题。</p>
<h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><p>Docker 包括三个基本概念:</p>
<ul>
<li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li>
<li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li>
</ul>
<p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</p>
<p>Docker 容器通过 Docker 镜像来创建。</p>
<p>容器与镜像的关系类似于面向对象编程中的对象与类。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Docker</th>
<th style="text-align:left">面向对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">容器</td>
<td style="text-align:left">对象</td>
</tr>
<tr>
<td style="text-align:left">镜像</td>
<td style="text-align:left">类</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://www.runoob.com/wp-content/uploads/2016/04/576507-docker1.png" alt="img"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">概念</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Docker 镜像（Images）</td>
<td style="text-align:left">Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td>
</tr>
<tr>
<td style="text-align:left">Docker 容器（Container）</td>
<td style="text-align:left">容器是独立运行的一个或一组应用，是镜像运行时的实体。</td>
</tr>
<tr>
<td style="text-align:left">Docker 客户端（Client）</td>
<td style="text-align:left">Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a target="_blank" rel="noopener" href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td style="text-align:left">Docker 主机（Host）</td>
<td style="text-align:left">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td style="text-align:left">Docker Registry</td>
<td style="text-align:left">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <strong>&lt;仓库名&gt;:&lt;标签&gt;</strong> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong>latest</strong> 作为默认标签。</td>
</tr>
<tr>
<td style="text-align:left">Docker Machine</td>
<td style="text-align:left">Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>
<p>也可以使用国内 daocloud 一键安装命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bashcurl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure>
<h2 id="容器使用"><a href="#容器使用" class="headerlink" title="容器使用"></a>容器使用</h2><h3 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a>Docker 客户端</h3><p>可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/docker27.png" alt=""></p>
<p>可以通过命令 <code>docker command --help</code> 更深入的了解指定的 Docker 命令使用方法。</p>
<p>例如我们要查看 <code>docker stats</code>指令的具体使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats --help</span><br></pre></td></tr></table></figure>
<h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>如果本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure>
<h3 id="Docker-Hello-World"><a href="#Docker-Hello-World" class="headerlink" title="Docker Hello World"></a>Docker Hello World</h3><p>Docker 允许你在容器内运行应用程序， 使用 <strong>docker run</strong> 命令来在容器内运行一个应用程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu /bin/echo &quot;Hello world&quot;</span><br></pre></td></tr></table></figure>
<p>各个参数解析：</p>
<ul>
<li>docker：Docker 的二进制执行文件。</li>
<li>run：与前面的 docker 组合来运行一个容器。</li>
<li>ubuntu：指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li>
<li>/bin/echo “Hello world”：在启动的容器里执行的命令</li>
</ul>
<p>以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo “Hello world”，然后输出结果。</p>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>-i：交互式操作。</li>
<li>-t：终端。</li>
<li>ubuntu：ubuntu 镜像。</li>
<li>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li>
</ul>
<p>要退出终端，直接输入 <code>exit</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
<h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 <strong>-d</strong> 指定容器的运行模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name ubuntu-test ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/wp-content/uploads/2016/05/docker-run-d.png"><img src="https://www.runoob.com/wp-content/uploads/2016/05/docker-run-d.png" alt="img"></a></p>
<p><img src="https://image.rexking6.top/img/docker-run-d2.png" alt=""></p>
<p><strong>注：</strong>加了 -d 参数默认不会进入容器，想要进入容器需要使用指令 <code>docker exec</code>。</p>
<p>在输出中，我们没有看到期望的 “hello world”，而是一串长字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63</span><br></pre></td></tr></table></figure>
<p>这个长字符串叫做容器 ID，对每个容器来说都是唯一的，我们可以通过容器 ID 来查看对应的容器发生了什么。</p>
<p>首先，我们需要确认容器有在运行，可以通过 <code>docker ps</code> 来查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND              ...  </span><br><span class="line">5917eac21c36        ubuntu:15.10           &quot;/bin/sh -c &#x27;while t…&quot;    ...</span><br></pre></td></tr></table></figure>
<p>输出详情介绍：</p>
<ul>
<li><p>CONTAINER ID: 容器 ID。</p>
</li>
<li><p>IMAGE: 使用的镜像。</p>
</li>
<li><p>COMMAND: 启动容器时运行的命令。</p>
</li>
<li><p>CREATED: 容器的创建时间。</p>
</li>
<li><p>STATUS: 容器状态。</p>
<p>状态有7种：</p>
<ul>
<li>created（已创建）</li>
<li>restarting（重启中）</li>
<li>running 或 Up（运行中）</li>
<li>removing（迁移中）</li>
<li>paused（暂停）</li>
<li>exited（停止）</li>
<li>dead（死亡）</li>
</ul>
</li>
<li><p>PORTS: 容器的端口信息和使用的连接类型（tcp\udp）。</p>
</li>
<li><p>NAMES: 自动分配的容器名称。</p>
</li>
</ul>
<p>在宿主主机内使用 <code>docker logs</code> 命令，查看容器内的标准输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs </span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/docker23.png" alt=""></p>
<h3 id="停止一个容器"><a href="#停止一个容器" class="headerlink" title="停止一个容器"></a>停止一个容器</h3><p>停止容器的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;容器 ID&gt;</span><br></pre></td></tr></table></figure>
<p>停止的容器可以通过 docker restart 重启：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;容器 ID&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>docker start ...</code> 包含容器文件系统挂载的操作</p>
</li>
<li><p><code>docker stop ...</code> 包含容器文件系统卸载的操作</p>
</li>
<li><p><code>docker restart ...</code> 不包含容器文件系统的卸载与挂载操作，本质上restart不涉及文件系统的操作，因此restart命令并不是stop与start两个命令的顺序叠加，谨慎使用。</p>
</li>
</ul>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p>
<ul>
<li><p><code>docker attach</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker attach 1e560fca3906 </span><br></pre></td></tr></table></figure>
<p><img src="https://www.runoob.com/wp-content/uploads/2016/05/docker-attach.png" alt="img"></p>
<p><strong>注意：</strong> 如果从这个容器退出，会导致容器的停止。</p>
</li>
<li><p><code>docker exec</code>：推荐使用 docker exec 命令，因为这样退出容器终端，不会导致容器的停止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 243c32535da7 /bin/bash</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/docker-exec.png" alt=""></p>
<p><strong>注意：</strong> 如果从这个容器退出，容器不会停止，这就是为什么推荐大家使用 <strong>docker exec</strong> 的原因。</p>
</li>
</ul>
<h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export 1e560fca3906 &gt; ubuntu.tar</span><br></pre></td></tr></table></figure>
<p>导出容器 <code>1e560fca3906</code> 快照到本地文件 <code>ubuntu.tar</code>。这样将导出容器快照到本地文件。</p>
<h3 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，以下实例将快照文件 <code>ubuntu.tar</code> 导入到镜像 <code>test/ubuntu:v1</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat docker/ubuntu.tar | docker import - test/ubuntu:v1</span><br></pre></td></tr></table></figure>
<p>此外，也可以通过指定 URL 或者某个目录来导入，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>删除容器使用 <code>docker rm</code> 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f 1e560fca3906</span><br></pre></td></tr></table></figure>
<p>下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure>
<h3 id="运行一个-web-应用"><a href="#运行一个-web-应用" class="headerlink" title="运行一个 web 应用"></a>运行一个 web 应用</h3><p>尝试使用 docker 构建一个 web 应用程序。</p>
<p>我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~# docker pull training/webapp  # 载入镜像</span><br><span class="line">runoob@runoob:~# docker run -d -P training/webapp python app.py</span><br></pre></td></tr></table></figure>
<p>参数说明:</p>
<ul>
<li>-d：让容器在后台运行。</li>
<li>-P：将容器内部使用的网络端口随机映射到我们使用的主机上。</li>
</ul>
<h3 id="查看web应用容器"><a href="#查看web应用容器" class="headerlink" title="查看web应用容器"></a>查看web应用容器</h3><p>使用 <code>docker ps</code> 来查看我们正在运行的容器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             ...        PORTS             </span><br><span class="line">d3d5e39ed9d3        training/webapp     &quot;python app.py&quot;     ...        0.0.0.0:32769-&gt;5000/tcp</span><br></pre></td></tr></table></figure>
<p>这里多了端口信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PORTS</span><br><span class="line">0.0.0.0:32769-&gt;5000/tcp</span><br></pre></td></tr></table></figure>
<p>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769 上。</p>
<p>这时我们可以通过浏览器访问WEB应用</p>
<p><img src="https://image.rexking6.top/img/docker31.png" alt=""></p>
<p>我们也可以通过 -p 参数来设置不一样的端口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure>
<p>查看正在运行的容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~#  docker ps</span><br><span class="line">CONTAINER ID        IMAGE                             PORTS                     NAMES</span><br><span class="line">bf08b7f2cd89        training/webapp     ...        0.0.0.0:5000-&gt;5000/tcp    wizardly_chandrasekhar</span><br><span class="line">d3d5e39ed9d3        training/webapp     ...        0.0.0.0:32769-&gt;5000/tcp   xenodochial_hoov</span><br></pre></td></tr></table></figure>
<p>容器内部的 5000 端口映射到我们本地主机的 5000 端口上。</p>
<h3 id="网络端口的快捷方式"><a href="#网络端口的快捷方式" class="headerlink" title="网络端口的快捷方式"></a>网络端口的快捷方式</h3><p>通过 docker ps 命令可以查看到容器的端口映射，Docker 还提供了另一个快捷方式 docker port，使用 docker port 可以查看指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号。</p>
<p>上面我们创建的 web 应用容器 ID 为 bf08b7f2cd89 名字为 wizardly_chandrasekhar。</p>
<p>我可以使用 <code>docker port bf08b7f2cd89</code> 或 <code>docker port wizardly_chandrasekhar</code> 来查看容器端口的映射情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker port bf08b7f2cd89</span><br><span class="line">5000/tcp -&gt; 0.0.0.0:5000</span><br><span class="line">docker port wizardly_chandrasekhar</span><br><span class="line">5000/tcp -&gt; 0.0.0.0:5000</span><br></pre></td></tr></table></figure>
<h3 id="查看web应用程序日志"><a href="#查看web应用程序日志" class="headerlink" title="查看web应用程序日志"></a>查看web应用程序日志</h3><p><code>docker logs [ID或者名字]</code>：可以查看容器内部的标准输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f bf08b7f2cd89</span><br><span class="line"> * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><br><span class="line">192.168.239.1 - - [09/May/2016 16:30:37] &quot;GET / HTTP/1.1&quot; 200 -</span><br><span class="line">192.168.239.1 - - [09/May/2016 16:30:37] &quot;GET /favicon.ico HTTP/1.1&quot; 404 -</span><br></pre></td></tr></table></figure>
<ul>
<li>-f：让 <code>docker logs</code> 像使用 <code>tail -f</code> 一样来输出容器内部的标准输出。</li>
</ul>
<p>从上面，我们可以看到应用程序使用的是 5000 端口并且能够查看到应用程序的访问日志。</p>
<h3 id="查看web应用程序容器的进程"><a href="#查看web应用程序容器的进程" class="headerlink" title="查看web应用程序容器的进程"></a>查看web应用程序容器的进程</h3><p>我们还可以使用 <code>docker top</code> 来查看容器内部运行的进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker top wizardly_chandrasekhar</span><br><span class="line">UID     PID         PPID          ...       TIME                CMD</span><br><span class="line">root    23245       23228         ...       00:00:00            python app.py</span><br></pre></td></tr></table></figure>
<h3 id="检查web应用程序"><a href="#检查web应用程序" class="headerlink" title="检查web应用程序"></a>检查web应用程序</h3><p>使用 <code>docker inspect</code> 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker inspect wizardly_chandrasekhar</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;bf08b7f2cd897b5964943134aa6d373e355c286db9b9885b1f60b6e8f82b2b85&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-09-17T01:41:26.174228707Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;python&quot;,</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;app.py&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">            &quot;Running&quot;: true,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            &quot;Dead&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 23245,</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">            &quot;StartedAt&quot;: &quot;2018-09-17T01:41:26.494185806Z&quot;,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h3 id="移除web应用容器"><a href="#移除web应用容器" class="headerlink" title="移除web应用容器"></a>移除web应用容器</h3><p>使用 <code>docker rm</code> 命令来删除不需要的容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm wizardly_chandrasekhar  </span><br><span class="line">wizardly_chandrasekhar</span><br></pre></td></tr></table></figure>
<p>删除容器时，容器必须是停止状态，否则会报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm wizardly_chandrasekhar</span><br><span class="line">Error response from daemon: You cannot remove a running container bf08b7f2cd897b5964943134aa6d373e355c286db9b9885b1f60b6e8f82b2b85. Stop the container before attempting removal or force remove</span><br></pre></td></tr></table></figure>
<h2 id="镜像使用"><a href="#镜像使用" class="headerlink" title="镜像使用"></a>镜像使用</h2><p>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</p>
<h3 id="列出镜像列表"><a href="#列出镜像列表" class="headerlink" title="列出镜像列表"></a>列出镜像列表</h3><p>我们可以使用 <code>docker images</code> 来列出本地主机上的镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker images           </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               90d5884b1ee0        5 days ago          188 MB</span><br><span class="line">php                 5.6                 f40e9e0f10c8        9 days ago          444.8 MB</span><br><span class="line">nginx               latest              6f8d099c3adc        12 days ago         182.7 MB</span><br><span class="line">mysql               5.6                 f2e8d6c772c0        3 weeks ago         324.6 MB</span><br><span class="line">httpd               latest              02ef73cf1bc0        3 weeks ago         194.4 MB</span><br><span class="line">ubuntu              15.10               4e3b13c8a266        4 weeks ago         136.3 MB</span><br><span class="line">hello-world         latest              690ed74de00f        6 months ago        960 B</span><br><span class="line">training/webapp     latest              6fae60ef3446        11 months ago       348.8 MB</span><br></pre></td></tr></table></figure>
<p>各个选项说明:</p>
<ul>
<li>REPOSITORY：表示镜像的仓库源</li>
<li>TAG：镜像的标签</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像创建时间</li>
<li>SIZE：镜像大小</li>
</ul>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p>
<p>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</p>
<h3 id="获取新的镜像"><a href="#获取新的镜像" class="headerlink" title="获取新的镜像"></a>获取新的镜像</h3><p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果想预先下载这个镜像，可以使用 docker pull 命令来下载它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:13.10</span><br><span class="line">13.10: Pulling from library/ubuntu</span><br><span class="line">6599cadaf950: Pull complete </span><br><span class="line">23eda618d451: Pull complete </span><br><span class="line">f0be3084efe9: Pull complete </span><br><span class="line">52de432f084b: Pull complete </span><br><span class="line">a3ed95caeb02: Pull complete </span><br><span class="line">Digest: sha256:15b79a6654811c8d992ebacdfbd5152fcf3d165e374e264076aa435214a947a3</span><br><span class="line">Status: Downloaded newer image for ubuntu:13.10</span><br></pre></td></tr></table></figure>
<p>下载完成后，我们可以直接使用这个镜像来运行容器。</p>
<h3 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h3><p>可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <strong><a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></strong>。</p>
<p>我们也可以使用 <code>docker search</code> 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 <code>docker search</code> 命令搜索 <code>httpd</code> 来寻找适合我们的镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search httpd</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/423F2A2C-287A-4B03-855E-6A78E125B346.jpg" alt=""></p>
<ul>
<li><p>NAME：镜像仓库源的名称</p>
</li>
<li><p>DESCRIPTION：镜像的描述</p>
</li>
<li><p>OFFICIAL：是否 docker 官方发布</p>
</li>
<li><p>stars：类似 Github 里面的 star，表示点赞、喜欢的意思。</p>
</li>
<li><p>AUTOMATED：自动构建。</p>
</li>
</ul>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>镜像删除使用 <code>docker rmi</code> 命令，比如我们删除 hello-world 镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi hello-world</span><br></pre></td></tr></table></figure>
<h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><p>当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。</p>
<ul>
<li>1、从已经创建的容器中更新镜像，并且提交这个镜像</li>
<li>2、使用 Dockerfile 指令来创建一个新的镜像</li>
</ul>
<h3 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h3><p>更新镜像之前，需要使用镜像来创建一个容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i ubuntu:15.10 /bin/bash</span><br></pre></td></tr></table></figure>
<p>在运行的容器内使用 <code>apt-get update</code> 命令进行更新。</p>
<p>在完成操作之后，输入 <code>exit</code> 命令来退出这个容器。</p>
<p>此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。可以通过命令 <code>docker commit</code> 来提交容器副本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2</span><br></pre></td></tr></table></figure>
<p>各个参数说明：</p>
<ul>
<li>-m：提交的描述信息</li>
<li>-a：指定镜像作者</li>
<li>e218edb10161：容器 ID</li>
<li>runoob/ubuntu:v2：指定要创建的目标镜像名</li>
</ul>
<p>可以使用 <code>docker images</code> 命令来查看我们的新镜像 <code>runoob/ubuntu:v2</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v2                  70bf1840fd7c        15 seconds ago      158.5 MB</span><br><span class="line">ubuntu              14.04               90d5884b1ee0        5 days ago          188 MB</span><br><span class="line">php                 5.6                 f40e9e0f10c8        9 days ago          444.8 MB</span><br><span class="line">nginx               latest              6f8d099c3adc        12 days ago         182.7 MB</span><br><span class="line">mysql               5.6                 f2e8d6c772c0        3 weeks ago         324.6 MB</span><br><span class="line">httpd               latest              02ef73cf1bc0        3 weeks ago         194.4 MB</span><br><span class="line">ubuntu              15.10               4e3b13c8a266        4 weeks ago         136.3 MB</span><br><span class="line">hello-world         latest              690ed74de00f        6 months ago        960 B</span><br><span class="line">training/webapp     latest              6fae60ef3446        12 months ago       348.8 MB</span><br></pre></td></tr></table></figure>
<p>使用我们的新镜像 <code>runoob/ubuntu</code> 来启动一个容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i runoob/ubuntu:v2 /bin/bash                            </span><br></pre></td></tr></table></figure>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>使用命令 <code>docker build</code> ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat Dockerfile </span><br><span class="line">FROM    centos:6.7</span><br><span class="line">MAINTAINER      Fisher &quot;fisher@sudops.com&quot;</span><br><span class="line"></span><br><span class="line">RUN     /bin/echo &#x27;root:123456&#x27; |chpasswd</span><br><span class="line">RUN     useradd runoob</span><br><span class="line">RUN     /bin/echo &#x27;runoob:123456&#x27; |chpasswd</span><br><span class="line">RUN     /bin/echo -e &quot;LANG=\&quot;en_US.UTF-8\&quot;&quot; &gt;/etc/default/local</span><br><span class="line">EXPOSE  22</span><br><span class="line">EXPOSE  80</span><br><span class="line">CMD     /usr/sbin/sshd -D</span><br></pre></td></tr></table></figure>
<p>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</p>
<p>第一条FROM，指定使用哪个镜像源</p>
<p>RUN 指令告诉docker 在镜像内执行命令，安装了什么。</p>
<p>然后，我们使用 Dockerfile 文件，通过 <code>docker build</code> 命令来构建一个镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker build -t runoob/centos:6.7 .</span><br><span class="line">Sending build context to Docker daemon 17.92 kB</span><br><span class="line">Step 1 : FROM centos:6.7</span><br><span class="line"> ---&amp;gt; d95b5ca17cc3</span><br><span class="line">Step 2 : MAINTAINER Fisher &quot;fisher@sudops.com&quot;</span><br><span class="line"> ---&amp;gt; Using cache</span><br><span class="line"> ---&amp;gt; 0c92299c6f03</span><br><span class="line">Step 3 : RUN /bin/echo &#x27;root:123456&#x27; |chpasswd</span><br><span class="line"> ---&amp;gt; Using cache</span><br><span class="line"> ---&amp;gt; 0397ce2fbd0a</span><br><span class="line">Step 4 : RUN useradd runoob</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>-t ：指定要创建的目标镜像名</li>
<li><strong>.</strong> ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</li>
</ul>
<p>使用 <code>docker images</code> 查看创建的镜像已经在列表中存在，镜像ID为860c279d2fec</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker images </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">runoob/centos       6.7                 860c279d2fec        About a minute ago   190.6 MB</span><br><span class="line">runoob/ubuntu       v2                  70bf1840fd7c        17 hours ago         158.5 MB</span><br><span class="line">ubuntu              14.04               90d5884b1ee0        6 days ago           188 MB</span><br><span class="line">php                 5.6                 f40e9e0f10c8        10 days ago          444.8 MB</span><br><span class="line">nginx               latest              6f8d099c3adc        12 days ago          182.7 MB</span><br><span class="line">mysql               5.6                 f2e8d6c772c0        3 weeks ago          324.6 MB</span><br><span class="line">httpd               latest              02ef73cf1bc0        3 weeks ago          194.4 MB</span><br><span class="line">ubuntu              15.10               4e3b13c8a266        5 weeks ago          136.3 MB</span><br><span class="line">hello-world         latest              690ed74de00f        6 months ago         960 B</span><br><span class="line">centos              6.7                 d95b5ca17cc3        6 months ago         190.6 MB</span><br><span class="line">training/webapp     latest              6fae60ef3446        12 months ago        348.8 MB</span><br></pre></td></tr></table></figure>
<h3 id="设置镜像标签"><a href="#设置镜像标签" class="headerlink" title="设置镜像标签"></a>设置镜像标签</h3><p>可以使用 docker tag 命令，为镜像添加一个新的标签。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag 860c279d2fec runoob/centos:dev</span><br></pre></td></tr></table></figure>
<p><code>docker tag 镜像ID</code>，这里是 860c279d2fec，用户名称、镜像源名（repository name）和新的标签名（tag）。</p>
<p>使用 <code>docker images</code> 命令可以看到，ID为860c279d2fec的镜像多一个标签。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/centos       6.7                 860c279d2fec        5 hours ago         190.6 MB</span><br><span class="line">runoob/centos       dev                 860c279d2fec        5 hours ago         190.6 MB</span><br><span class="line">runoob/ubuntu       v2                  70bf1840fd7c        22 hours ago        158.5 MB</span><br><span class="line">ubuntu              14.04               90d5884b1ee0        6 days ago          188 MB</span><br><span class="line">php                 5.6                 f40e9e0f10c8        10 days ago         444.8 MB</span><br><span class="line">nginx               latest              6f8d099c3adc        13 days ago         182.7 MB</span><br><span class="line">mysql               5.6                 f2e8d6c772c0        3 weeks ago         324.6 MB</span><br><span class="line">httpd               latest              02ef73cf1bc0        3 weeks ago         194.4 MB</span><br><span class="line">ubuntu              15.10               4e3b13c8a266        5 weeks ago         136.3 MB</span><br><span class="line">hello-world         latest              690ed74de00f        6 months ago        960 B</span><br><span class="line">centos              6.7                 d95b5ca17cc3        6 months ago        190.6 MB</span><br><span class="line">training/webapp     latest              6fae60ef3446        12 months ago       348.8 MB</span><br></pre></td></tr></table></figure>
<h2 id="容器连接"><a href="#容器连接" class="headerlink" title="容器连接"></a>容器连接</h2><p>前面实现了通过网络端口来访问运行在 docker 容器内的服务。</p>
<p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。</p>
<p>下面我们来实现通过端口连接到一个 docker 容器。</p>
<h3 id="网络端口映射"><a href="#网络端口映射" class="headerlink" title="网络端口映射"></a>网络端口映射</h3><p>我们创建了一个 python 应用的容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P training/webapp python app.py</span><br><span class="line">fce072cc88cee71b1cdceb57c2821d054a4a59f67da6b416fceb5593f059fc6d</span><br></pre></td></tr></table></figure>
<p>另外，我们可以指定容器绑定的网络地址，比如绑定 127.0.0.1。</p>
<p>我们使用 -P 绑定端口号，使用 <code>docker ps</code> 可以看到容器端口 5000 绑定主机端口 32768。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">CONTAINER ID    IMAGE               COMMAND            ...           PORTS                     NAMES</span><br><span class="line">fce072cc88ce    training/webapp     &quot;python app.py&quot;    ...     0.0.0.0:32768-&gt;5000/tcp   grave_hopper</span><br></pre></td></tr></table></figure>
<p>我们也可以使用 -p 标识来指定容器端口绑定到主机端口。</p>
<p>两种方式的区别是:</p>
<ul>
<li>-P：是容器内部端口<strong>随机</strong>映射到主机的高端口。</li>
<li>-p ：是容器内部端口绑定到<strong>指定</strong>的主机端口。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 training/webapp python app.py</span><br><span class="line">33e4523d30aaf0258915c368e66e03b49535de0ef20317d3f639d40222ba6bc0</span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND           ...           PORTS                     NAMES</span><br><span class="line">33e4523d30aa        training/webapp     &quot;python app.py&quot;   ...   0.0.0.0:5000-&gt;5000/tcp    berserk_bartik</span><br><span class="line">fce072cc88ce        training/webapp     &quot;python app.py&quot;   ...   0.0.0.0:32768-&gt;5000/tcp   grave_hopper</span><br></pre></td></tr></table></figure>
<p>另外，我们可以指定容器绑定的网络地址，比如绑定 127.0.0.1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</span><br><span class="line">95c6ceef88ca3e71eaf303c2833fd6701d8d1b2572b5613b5a932dfdfe8a857c</span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND           ...     PORTS                                NAMES</span><br><span class="line">95c6ceef88ca        training/webapp     &quot;python app.py&quot;   ...  5000/tcp, 127.0.0.1:5001-&gt;5000/tcp   adoring_stonebraker</span><br><span class="line">33e4523d30aa        training/webapp     &quot;python app.py&quot;   ...  0.0.0.0:5000-&gt;5000/tcp               berserk_bartik</span><br><span class="line">fce072cc88ce        training/webapp     &quot;python app.py&quot;   ...    0.0.0.0:32768-&gt;5000/tcp              grave_hopper</span><br></pre></td></tr></table></figure>
<p>这样我们就可以通过访问 127.0.0.1:5001 来访问容器的 5000 端口。</p>
<p>上面的例子中，默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 /udp。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br><span class="line">6779686f06f6204579c1d655dd8b2b31e8e809b245a97b2d3a8e35abe9dcd22a</span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND           ...   PORTS                                NAMES</span><br><span class="line">6779686f06f6        training/webapp     &quot;python app.py&quot;   ...   5000/tcp, 127.0.0.1:5000-&gt;5000/udp   drunk_visvesvaraya</span><br><span class="line">95c6ceef88ca        training/webapp     &quot;python app.py&quot;   ...    5000/tcp, 127.0.0.1:5001-&gt;5000/tcp   adoring_stonebraker</span><br><span class="line">33e4523d30aa        training/webapp     &quot;python app.py&quot;   ...     0.0.0.0:5000-&gt;5000/tcp               berserk_bartik</span><br><span class="line">fce072cc88ce        training/webapp     &quot;python app.py&quot;   ...    0.0.0.0:32768-&gt;5000/tcp              grave_hopper</span><br></pre></td></tr></table></figure>
<p><strong>docker port</strong> 命令可以让我们快捷地查看端口的绑定情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker port adoring_stonebraker 5000</span><br><span class="line">127.0.0.1:5001</span><br></pre></td></tr></table></figure>
<h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><p>端口映射并不是唯一把 docker 连接到另一个容器的方法。</p>
<p>docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。</p>
<p>docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。</p>
<h4 id="容器命名"><a href="#容器命名" class="headerlink" title="容器命名"></a>容器命名</h4><p>当我们创建一个容器的时候，docker 会自动对它进行命名。另外，我们也可以使用 —name 标识来命名容器，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --name runoob training/webapp python app.py</span><br><span class="line">43780a6eabaaf14e590b6e849235c75f3012995403f97749775e38436db9a441</span><br></pre></td></tr></table></figure>
<p>我们可以使用 docker ps 命令来查看容器名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps -l</span><br><span class="line">CONTAINER ID     IMAGE            COMMAND           ...    PORTS                     NAMES</span><br><span class="line">43780a6eabaa     training/webapp   &quot;python app.py&quot;  ...     0.0.0.0:32769-&gt;5000/tcp   runoob</span><br></pre></td></tr></table></figure>
<h4 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h4><p>下面先创建一个新的 Docker 网络。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d bridge test-net</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/docker-net.png" alt=""></p>
<p>参数说明：</p>
<ul>
<li>-d：参数指定 Docker 网络类型，有 bridge、overlay。</li>
</ul>
<p>其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它。</p>
<h4 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h4><p>运行一个容器并连接到新建的 test-net 网络:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -itd --name test1 --network test-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>打开新的终端，再运行一个容器并加入到 test-net 网络:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -itd --name test2 --network test-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/docker-net2.png" alt=""></p>
<p>下面通过 ping 来证明 test1 容器和 test2 容器建立了互联关系。</p>
<p>如果 test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping。即学即用：可以在一个容器里安装好，提交容器到镜像，在以新的镜像重新运行以上俩个容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt install iputils-ping</span><br></pre></td></tr></table></figure>
<p>在 test1 容器输入以下命令：</p>
<p><img src="https://image.rexking6.top/img/docker-net3.png" alt=""></p>
<p>同理在 test2 容器也会成功连接到:</p>
<p><img src="https://image.rexking6.top/img/docker-net4.png" alt=""></p>
<p>这样，test1 容器和 test2 容器建立了互联关系。</p>
<p>如果你有多个容器之间需要互相连接，推荐使用 Docker Compose，后面会介绍。</p>
<h3 id="配置-DNS"><a href="#配置-DNS" class="headerlink" title="配置 DNS"></a>配置 DNS</h3><p>我们可以在宿主机的 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置全部容器的 DNS：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;dns&quot; : [</span><br><span class="line">    &quot;114.114.114.114&quot;,</span><br><span class="line">    &quot;8.8.8.8&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置后，启动容器的 DNS 会自动配置为 <code>114.114.114.114</code> 和 <code>8.8.8.8</code>。</p>
<p>配置完，需要重启 docker 才能生效。</p>
<p>查看容器的 DNS 是否生效可以使用以下命令，它会输出容器的 DNS 信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm  ubuntu  cat etc/resolv.conf</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/docker-net5.png" alt=""></p>
<h4 id="手动指定容器的配置"><a href="#手动指定容器的配置" class="headerlink" title="手动指定容器的配置"></a>手动指定容器的配置</h4><p>如果只想在指定的容器设置 DNS，则可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm -h host_ubuntu --dns=114.114.114.114 --dns-search=test.com ubuntu</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><p>—rm：容器退出时自动清理容器内部的文件系统。</p>
</li>
<li><p>-h HOSTNAME 或者 —hostname=HOSTNAME： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。</p>
</li>
<li><p>—dns=IP_ADDRESS： 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</p>
</li>
<li><p>—dns-search=DOMAIN： 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 <code>host</code> 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。</p>
</li>
</ul>
<p><img src="https://image.rexking6.top/img/docker-net6.png" alt=""></p>
<p>如果在容器启动时没有指定 —dns 和 —dns-search，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS。</p>
<h2 id="仓库管理"><a href="#仓库管理" class="headerlink" title="仓库管理"></a>仓库管理</h2><p>仓库（Repository）是集中存放镜像的地方。以下介绍一下 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的。</p>
<h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p>目前 Docker 官方维护了一个公共仓库 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>在 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure>
<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>退出 docker hub 可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logout</span><br></pre></td></tr></table></figure>
<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>你可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p>
<p>以 ubuntu 为关键词进行搜索：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search ubuntu</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/wp-content/uploads/2019/10/docker-search22.png"><img src="https://www.runoob.com/wp-content/uploads/2019/10/docker-search22.png" alt="img"></a></p>
<p>使用 <code>docker pull</code> 将官方 ubuntu 镜像下载到本地：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu </span><br></pre></td></tr></table></figure>
<h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p>用户登录后，可以通过 <code>docker push</code> 命令将自己的镜像推送到 Docker Hub。</p>
<p>以下命令中的 <code>username</code>请替换为你的 Docker 账号用户名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:18.04 username/ubuntu:18.04</span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY      TAG        IMAGE ID            CREATED           ...  </span><br><span class="line">ubuntu          18.04      275d79972a86        6 days ago        ...  </span><br><span class="line">username/ubuntu 18.04      275d79972a86        6 days ago        ...  </span><br><span class="line">$ docker push username/ubuntu:18.04</span><br><span class="line">$ docker search username/ubuntu</span><br><span class="line"></span><br><span class="line">NAME             DESCRIPTION       STARS         OFFICIAL    AUTOMATED</span><br><span class="line">username/ubuntu</span><br></pre></td></tr></table></figure>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h3 id="什么是Dockerfile？"><a href="#什么是Dockerfile？" class="headerlink" title="什么是Dockerfile？"></a>什么是Dockerfile？</h3><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<h3 id="使用Dockerfile定制镜像"><a href="#使用Dockerfile定制镜像" class="headerlink" title="使用Dockerfile定制镜像"></a>使用Dockerfile定制镜像</h3><p>这里仅讲解如何运行 Dockerfile 文件来定制一个镜像，具体 Dockerfile 文件内指令详解，将在下一节中介绍，这里你只要知道构建的流程即可。</p>
<ol>
<li><p>下面以定制一个 nginx 镜像（构建好的镜像内会有一个 <code>/usr/share/nginx/html/index.html</code> 文件）</p>
<p>在一个空目录下，新建一个名为 Dockerfile 文件，并在文件内添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#x27;这是一个本地构建的nginx镜像&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/dockerfile1.png" alt=""></p>
</li>
<li><p><code>FROM</code> 和 <code>RUN</code> 指令的作用</p>
<ul>
<li><p>FROM：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</p>
</li>
<li><p>RUN：用于执行后面跟着的命令行命令。有以下俩种格式：</p>
<ul>
<li><p>shell 格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;命令行命令&gt;</span><br><span class="line"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span><br></pre></td></tr></table></figure>
</li>
<li><p>exec 格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span><br><span class="line"># 例如：</span><br><span class="line"># RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install wget</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span><br><span class="line">RUN tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure>
<p>以上执行会创建 3 层镜像。可简化为以下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install wget \</span><br><span class="line">  &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \</span><br><span class="line">  &amp;&amp; tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure>
<p>如上，以 <code>&amp;&amp;</code> 符号连接命令，这样执行后，只会创建 1 层镜像。</p>
</li>
</ol>
<h3 id="开始构建镜像"><a href="#开始构建镜像" class="headerlink" title="开始构建镜像"></a>开始构建镜像</h3><p>在 Dockerfile 文件的存放目录下，执行构建动作。</p>
<p>以下示例，通过目录下的 Dockerfile 构建一个 <code>nginx:v3</code>（镜像名称:镜像标签）。</p>
<p><strong>注</strong>：最后的 <code>.</code> 代表本次执行的上下文路径，下一节会介绍。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/dockerfile2.png" alt=""></p>
<p>以上显示，说明已经构建成功。</p>
<h3 id="上下文路径"><a href="#上下文路径" class="headerlink" title="上下文路径"></a>上下文路径</h3><p>上一节中，有提到指令最后一个 <code>.</code> 是上下文路径，那么什么是上下文路径呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure>
<p>上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</p>
<p><strong>解析</strong>：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</p>
<p>如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。</p>
<p><strong>注意</strong>：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</p>
<h3 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h3><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,...  &quot;&lt;目标路径&gt;&quot;]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>[—chown=<user>:<group>]：可选参数，用户改变复制到容器内文件的拥有者和属组。</p>
</li>
<li><p>&lt;源路径&gt;：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure>
</li>
<li><p>&lt;目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p>
</li>
</ul>
<h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p>
<ul>
<li>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</li>
<li>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li>
</ul>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p>
<ul>
<li>CMD 在 <code>docker run</code> 时运行。</li>
<li>RUN 是在 <code>docker build</code>。</li>
</ul>
<p>作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 <code>docker run</code> 命令行参数中指定要运行的程序所覆盖。</p>
<p>注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD &lt;shell 命令&gt; </span><br><span class="line">CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] </span><br><span class="line">CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span><br></pre></td></tr></table></figure>
<p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p>
<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>类似于 CMD 指令，但其不会被 <code>docker run</code> 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p>
<p>但是，如果运行 <code>docker run</code> 时使用了 <code>--entrypoint</code> 选项，将覆盖 CMD 指令指定的程序。</p>
<p><strong>优点</strong>：在执行 <code>docker run</code> 的时候可以指定 ENTRYPOINT 运行所需的参数。</p>
<p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</span><br></pre></td></tr></table></figure>
<p>可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。</p>
<p>示例：</p>
<p>假设已通过 Dockerfile 构建了 <code>nginx:test</code> 镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参</span><br><span class="line">CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参 </span><br></pre></td></tr></table></figure>
<ol>
<li><p>不传参运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run  nginx:test</span><br></pre></td></tr></table></figure>
<p>容器内会默认运行以下命令，启动主进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>传参运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run  nginx:test -c /etc/nginx/new.conf</span><br></pre></td></tr></table></figure>
<p>容器内会默认运行以下命令，启动主进程（<code>/etc/nginx/new.conf</code>：假设容器内已有此文件）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -c /etc/nginx/new.conf</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br></pre></td></tr></table></figure>
<p>以下示例设置 ·NODE_VERSION = 7.2.0· ， 在后续的指令中可以通过 ·$NODE_VERSION· 引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot; \</span><br><span class="line">  &amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;</span><br></pre></td></tr></table></figure>
<h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><p>构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p>
<p>构建命令 <code>docker build</code> 中可以用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;参数名&gt;[=&lt;默认值&gt;]</span><br></pre></td></tr></table></figure>
<h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p>
<p>作用：</p>
<ul>
<li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li>
<li>避免容器不断变大。</li>
</ul>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</span><br><span class="line">VOLUME &lt;路径&gt;</span><br></pre></td></tr></table></figure>
<p>在启动容器 <code>docker run</code> 的时候，我们可以通过 <code>-v</code> 参数修改挂载点。</p>
<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p>仅仅只是声明端口。</p>
<p>作用：</p>
<ul>
<li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li>
<li>在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 EXPOSE 的端口。</li>
</ul>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</span><br></pre></td></tr></table></figure>
<h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</p>
<p><code>docker build</code> 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR &lt;工作目录路径&gt;</span><br></pre></td></tr></table></figure>
<h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER &lt;用户名&gt;[:&lt;用户组&gt;]</span><br></pre></td></tr></table></figure>
<h4 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h4><p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</span><br><span class="line">HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</span><br><span class="line">HEALTHCHECK [选项] CMD &lt;命令&gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。</span><br></pre></td></tr></table></figure>
<h4 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h4><p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这时执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD &lt;其它指令&gt;</span><br></pre></td></tr></table></figure>
<h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>LABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure>
<p>比如我们可以添加镜像的作者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL org.opencontainers.image.authors=&quot;runoob&quot;</span><br></pre></td></tr></table></figure>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>Docker 是如何进行资源虚拟化的，并且如何实现资源隔离的，其核心技术原理主要有（内容部分参考自 Docker 核心技术与实现原理）：</p>
<p><img src="https://image.rexking6.top/img/v2-09f5aba883098583bf7d4d096cfe3e44_720w.jpg" alt=""></p>
<h3 id="1、Namespace"><a href="#1、Namespace" class="headerlink" title="1、Namespace"></a>1、Namespace</h3><blockquote>
<p>在日常使用 Linux 或者 macOS 时，我们并没有运行多个完全分离的服务器的需要，但是如果我们在服务器上启动了多个服务，这些服务其实会相互影响的，每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件，这是很多时候我们都不愿意看到的，我们更希望运行在同一台机器上的不同服务能做到完全隔离，就像运行在多台不同的机器上一样。</p>
</blockquote>
<p>命名空间（Namespaces）是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法。Linux 的命名空间机制提供了以下七种不同的命名空间，通过这七个选项我们能在创建新的进程时设置新进程应该在哪些资源上与宿主机器进行隔离。</p>
<ol>
<li>CLONE_NEWCGROUP</li>
<li>CLONE_NEWIPC</li>
<li>CLONE_NEWNET</li>
<li>CLONE_NEWNS</li>
<li>CLONE_NEWPID</li>
<li>CLONE_NEWUSER</li>
<li>CLONE_NEWUTS</li>
</ol>
<p><img src="https://image.rexking6.top/img/image-20210724195932964.png" alt=""></p>
<p>在 Linux 系统中，有两个特殊的进程，一个是 pid 为 1 的 /sbin/init 进程，另一个是 pid 为 2 的 kthreadd 进程，这两个进程都是被 Linux 中的上帝进程 idle 创建出来的，其中前者负责执行内核的一部分初始化工作和系统配置，也会创建一些类似 getty 的注册进程，而后者负责管理和调度其他的内核进程。</p>
<p>当在宿主机运行 Docker，通过<code>docker run</code>或<code>docker start</code>创建新容器进程时，会传入 CLONE_NEWPID 实现进程上的隔离。</p>
<p><img src="https://image.rexking6.top/img/v2-4db17c30464263fc0291c5e625d84645_720w.jpg" alt=""></p>
<p>接着，在方法<code>createSpec</code>的<code>setNamespaces</code>中，完成除进程命名空间之外与用户、网络、IPC 以及 UTS 相关的命名空间的设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func (daemon *Daemon) createSpec(c *container.Container) (*specs.Spec, error) &#123;</span><br><span class="line"> s := oci.DefaultSpec()</span><br><span class="line"></span><br><span class="line"> // ...</span><br><span class="line"> if err := setNamespaces(daemon, &amp;s, c); err != nil &#123;</span><br><span class="line">  return nil, fmt.Errorf(&quot;linux spec namespaces: %v&quot;, err)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return &amp;s, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func setNamespaces(daemon *Daemon, s *specs.Spec, c *container.Container) error &#123;</span><br><span class="line"> // user</span><br><span class="line"> // network</span><br><span class="line"> // ipc</span><br><span class="line"> // uts</span><br><span class="line"></span><br><span class="line"> // pid</span><br><span class="line"> if c.HostConfig.PidMode.IsContainer() &#123;</span><br><span class="line">  ns := specs.LinuxNamespace&#123;Type: &quot;pid&quot;&#125;</span><br><span class="line">  pc, err := daemon.getPidContainer(c)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">   return err</span><br><span class="line">  &#125;</span><br><span class="line">  ns.Path = fmt.Sprintf(&quot;/proc/%d/ns/pid&quot;, pc.State.GetPID())</span><br><span class="line">  setNamespace(s, ns)</span><br><span class="line"> &#125; else if c.HostConfig.PidMode.IsHost() &#123;</span><br><span class="line">  oci.RemoveNamespace(s, specs.LinuxNamespaceType(&quot;pid&quot;))</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">  ns := specs.LinuxNamespace&#123;Type: &quot;pid&quot;&#125;</span><br><span class="line">  setNamespace(s, ns)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>当 Docker 容器完成命名空间的设置，其网络也变成了独立的命名空间，与宿主机的网络互联便产生了限制，这就导致外部很难访问到容器内的应用程序服务。Docker 提供了 4 种网络模式，通过<code>--net</code>指定。</p>
<ol>
<li>host</li>
<li>container</li>
<li>none</li>
<li>bridge</li>
</ol>
<p>由于后续介绍 Kubernetes 利用了 Docker 的 bridge 网络模式，所以仅介绍该模式。Linux 中为了方便各网络命名空间的网络互相访问，设置了 Veth Pair 和网桥来实现，Docker 也是基于此方式实现了网络通信。</p>
<p>下图中 <code>eth0</code> 与 <code>veth9953b75</code> 是一个 Veth Pair，<code>eth0</code> 与 <code>veth3e84d4f</code> 为另一个 Veth Pair。Veth Pair 在容器内一侧会被设置为 <code>eth0</code> 模拟网卡，另一侧连接 Docker0 网桥，这样就实现了不同容器间网络的互通。加之 Docker0 为每个容器配置的 iptables 规则，又实现了与宿主机外部网络的互通。</p>
<p><img src="https://image.rexking6.top/img/v2-18ca461d2374acad017e0484dd4fc982_720w.jpg" alt=""></p>
<blockquote>
<p>解决了进程和网络隔离的问题，但是 Docker 容器中的进程仍然能够访问或者修改宿主机器上的其他目录，这是我们不希望看到的。</p>
</blockquote>
<p>在新的进程中创建隔离的挂载点命名空间需要在 clone 函数中传入 CLONE_NEWNS，这样子进程就能得到父进程挂载点的拷贝，如果不传入这个参数子进程对文件系统的读写都会同步回父进程以及整个主机的文件系统。当一个容器需要启动时，它一定需要提供一个根文件系统（rootfs），容器需要使用这个文件系统来创建一个新的进程，所有二进制的执行都必须在这个根文件系统中，并建立一些符号链接来保证 IO 不会出现问题。</p>
<p><img src="https://image.rexking6.top/img/image-20210724201759937.png" alt=""></p>
<p>另外，通过 Linux 的<code>chroot</code>命令能够改变当前的系统根目录结构，通过改变当前系统的根目录，我们能够限制用户的权利，在新的根目录下并不能够访问旧系统根目录的结构个文件，也就建立了一个与原系统完全隔离的目录结构。</p>
<h3 id="2、Control-Groups（CGroups）"><a href="#2、Control-Groups（CGroups）" class="headerlink" title="2、Control Groups（CGroups）"></a>2、Control Groups（CGroups）</h3><p>Control Groups（CGroups）提供了宿主机上物理资源的隔离，例如 CPU、内存、磁盘 I/O 和网络带宽。主要由这几个组件构成：</p>
<ol>
<li>控制组（CGroup）：一个 CGroup 包含一组进程，并可以在这个 CGroup 上增加 Linux Subsystem 的各种参数配置，将一组进程和一组 Subsystem 关联起来。</li>
<li>Subsystem 子系统：是一组资源控制模块，比如 CPU 子系统可以控制 CPU 时间分配，内存子系统可以限制 CGroup 内存使用量。可以通过<code>lssubsys -a</code>命令查看当前内核支持哪些 Subsystem。</li>
<li>Hierarchy 层级树：主要功能是把 CGroup 串成一个树型结构，使 CGruop 可以做到继承，每个 Hierarchy 通过绑定对应的 Subsystem 进行资源调度。</li>
<li>Task：在 CGroups 中，task 就是系统的一个进程。一个任务可以加入某个 CGroup，也可以从某个 CGroup 迁移到另外一个 CGroup。</li>
</ol>
<p>在 Linux 的 Docker 安装目录下有一个 docker 目录，当启动一个容器时，就会创建一个与容器标识符相同的 CGroup，举例来说当前的主机就会有以下层级关系：</p>
<p><img src="https://image.rexking6.top/img/image-20210724201842455.png" alt=""></p>
<p>每一个 CGroup 下面都有一个 tasks 文件，其中存储着属于当前控制组的所有进程的 pid，作为负责 cpu 的子系统，cpu.cfs_quota_us 文件中的内容能够对 CPU 的使用作出限制，如果当前文件的内容为 50000，那么当前控制组中的全部进程的 CPU 占用率不能超过 50%。</p>
<p>当我们使用 Docker 关闭掉正在运行的容器时，Docker 的子控制组对应的文件夹也会被 Docker 进程移除。</p>
<h3 id="3、UnionFS"><a href="#3、UnionFS" class="headerlink" title="3、UnionFS"></a>3、UnionFS</h3><blockquote>
<p>联合文件系统（Union File System），它可以把多个目录内容联合挂载到同一个目录下，而目录的物理位置是分开的。UnionFS 可以把只读和可读写文件系统合并在一起，具有写时复制功能，允许只读文件系统的修改可以保存到可写文件系统当中。Docker 之前使用的为 AUFS（Advanced Union FS），现为 Overlay2。</p>
</blockquote>
<p>Docker 中的每一个镜像都是由一系列只读的层组成的，Dockerfile 中的每一个命令都会在已有的只读层上创建一个新的层：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:15.04</span><br><span class="line">COPY . /app</span><br><span class="line">RUN make /app</span><br><span class="line">CMD python /app/app.py</span><br></pre></td></tr></table></figure>
<p>容器中的每一层都只对当前容器进行了非常小的修改，上述的 Dockerfile 文件会构建一个拥有四层 layer 的镜像：</p>
<p><img src="https://pic1.zhimg.com/80/v2-3bd329c8c154fad6d55890c817efb170_720w.jpg" alt="img"></p>
<p>当镜像被命令创建时就会在镜像的最上层添加一个可写的层，也就是容器层，所有对于运行时容器的修改其实都是对这个容器读写层的修改。容器和镜像的区别就在于，所有的镜像都是只读的，而每一个容器其实等于镜像加上一个可读写的层，也就是同一个镜像可以对应多个容器。</p>
<p><img src="https://pic4.zhimg.com/80/v2-b8700d330dcb53af12974b4dcb11cae7_720w.jpg" alt="img"></p>
<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><h3 id="Compose简介"><a href="#Compose简介" class="headerlink" title="Compose简介"></a>Compose简介</h3><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<p>Compose 使用的三个步骤：</p>
<ul>
<li>使用 Dockerfile 定义应用程序的环境。</li>
<li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li>
</ul>
<p>docker-compose.yml 的配置案例如下（配置参数参考下文）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># yaml 配置实例</span><br><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">   - &quot;5000:5000&quot;</span><br><span class="line">    volumes:</span><br><span class="line">   - .:/code</span><br><span class="line">    - logvolume01:/var/log</span><br><span class="line">    links:</span><br><span class="line">   - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">volumes:</span><br><span class="line">  logvolume01: &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Compose-安装"><a href="#Compose-安装" class="headerlink" title="Compose 安装"></a>Compose 安装</h3><p>Linux 上我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：<a target="_blank" rel="noopener" href="https://github.com/docker/compose/releases。">https://github.com/docker/compose/releases。</a></p>
<p>运行以下命令以下载 Docker Compose 的当前稳定版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>要安装其他版本的 Compose，请替换 1.24.1。</p>
<p>将可执行权限应用于二进制文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>创建软链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>测试是否安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line">cker-compose version 1.24.1, build 4667896b</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>： 对于 alpine，需要以下依赖包： py-pip，python-dev，libffi-dev，openssl-dev，gcc，libc-dev，和 make。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="1、准备"><a href="#1、准备" class="headerlink" title="1、准备"></a>1、准备</h4><p>创建一个测试目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir composetest</span><br><span class="line">$ cd composetest</span><br></pre></td></tr></table></figure>
<p>在测试目录中创建一个名为 <code>app.py</code> 的文件，并复制粘贴以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">import redis</span><br><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=&#x27;redis&#x27;, port=6379)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_hit_count():</span><br><span class="line">    retries = 5</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            return cache.incr(&#x27;hits&#x27;)</span><br><span class="line">        except redis.exceptions.ConnectionError as exc:</span><br><span class="line">            if retries == 0:</span><br><span class="line">                raise exc</span><br><span class="line">            retries -= 1</span><br><span class="line">            time.sleep(0.5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def hello():</span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    return &#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;.format(count)</span><br></pre></td></tr></table></figure>
<p>在此示例中，redis 是应用程序网络上的 redis 容器的主机名，该主机使用的端口为 6379。</p>
<p>在 composetest 目录中创建另一个名为 <code>requirements.txt</code> 的文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure>
<h4 id="2、创建-Dockerfile-文件"><a href="#2、创建-Dockerfile-文件" class="headerlink" title="2、创建 Dockerfile 文件"></a>2、创建 Dockerfile 文件</h4><p>在 composetest 目录中，创建一个名为 Dockerfile 的文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.7-alpine</span><br><span class="line">WORKDIR /code</span><br><span class="line">ENV FLASK_APP app.py</span><br><span class="line">ENV FLASK_RUN_HOST 0.0.0.0</span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">COPY . .</span><br><span class="line">CMD [&quot;flask&quot;, &quot;run&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>Dockerfile 内容解释：</strong></p>
<ul>
<li><p>FROM python:3.7-alpine：从 Python 3.7 映像开始构建镜像。</p>
</li>
<li><p>WORKDIR /code：将工作目录设置为 /code。</p>
</li>
<li><p>```<br>ENV FLASK_APP app.py<br>ENV FLASK_RUN_HOST 0.0.0.0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  设置 flask 命令使用的环境变量。</span><br><span class="line"></span><br><span class="line">- RUN apk add --no-cache gcc musl-dev linux-headers：安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以编译加速。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  COPY requirements.txt requirements.txt</span><br><span class="line">  RUN pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
<p>复制 requirements.txt 并安装 Python 依赖项。</p>
</li>
<li><p>COPY . .：将 . 项目中的当前目录复制到 . 镜像中的工作目录。</p>
</li>
<li><p>CMD [“flask”, “run”]：容器提供默认的执行命令为：flask run。</p>
</li>
</ul>
<h4 id="3、创建-docker-compose-yml"><a href="#3、创建-docker-compose-yml" class="headerlink" title="3、创建 docker-compose.yml"></a>3、创建 docker-compose.yml</h4><p>在测试目录中创建一个名为 docker-compose.yml 的文件，然后粘贴以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># yaml 配置</span><br><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - &quot;5000:5000&quot;</span><br><span class="line">  redis:</span><br><span class="line">    image: &quot;redis:alpine&quot;</span><br></pre></td></tr></table></figure>
<p>该 Compose 文件定义了两个服务：web 和 redis。</p>
<ul>
<li>web：该 web 服务使用从 Dockerfile 当前目录中构建的镜像。然后，它将容器和主机绑定到暴露的端口 5000。此示例服务使用 Flask Web 服务器的默认端口 5000 。</li>
<li>redis：该 redis 服务使用 Docker Hub 的公共 Redis 映像。</li>
</ul>
<h4 id="4、使用-Compose-命令构建和运行您的应用"><a href="#4、使用-Compose-命令构建和运行您的应用" class="headerlink" title="4、使用 Compose 命令构建和运行您的应用"></a>4、使用 Compose 命令构建和运行您的应用</h4><p>在测试目录中，执行以下命令来启动应用程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>
<p>如果你想在后台执行该服务可以加上 -d 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<h3 id="yml-配置指令参考"><a href="#yml-配置指令参考" class="headerlink" title="yml 配置指令参考"></a>yml 配置指令参考</h3><h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><p>指定本 yml 依从的 compose 哪个版本制定的。</p>
<h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>指定为构建镜像上下文路径：</p>
<p>例如 webapp 服务，指定为从上下文路径 <code>./dir/Dockerfile</code> 所构建的镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir</span><br></pre></td></tr></table></figure>
<p>或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-alternate</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br><span class="line">      labels:</span><br><span class="line">        - &quot;com.example.description=Accounting webapp&quot;</span><br><span class="line">        - &quot;com.example.department=Finance&quot;</span><br><span class="line">        - &quot;com.example.label-with-empty-value&quot;</span><br><span class="line">      target: prod</span><br></pre></td></tr></table></figure>
<ul>
<li>context：上下文路径。</li>
<li>dockerfile：指定构建镜像的 Dockerfile 文件名。</li>
<li>args：添加构建参数，这是只能在构建过程中访问的环境变量。</li>
<li>labels：设置构建镜像的标签。</li>
<li>target：多层构建，可以指定构建哪一层。</li>
</ul>
<h4 id="cap-add，cap-drop"><a href="#cap-add，cap-drop" class="headerlink" title="cap_add，cap_drop"></a>cap_add，cap_drop</h4><p>添加或删除容器拥有的宿主机的内核功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cap_add:</span><br><span class="line">  - ALL # 开启全部权限</span><br><span class="line"></span><br><span class="line">cap_drop:</span><br><span class="line">  - SYS_PTRACE # 关闭 ptrace权限</span><br></pre></td></tr></table></figure>
<h4 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a>cgroup_parent</h4><p>为容器指定父 cgroup 组，意味着将继承该组的资源限制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgroup_parent: m-executor-abcd</span><br></pre></td></tr></table></figure>
<h4 id="command"><a href="#command" class="headerlink" title="command"></a>command</h4><p>覆盖容器启动的默认命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]</span><br></pre></td></tr></table></figure>
<h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h4><p>指定自定义容器名称，而不是生成的默认名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: my-web-container</span><br></pre></td></tr></table></figure>
<h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h4><p>设置依赖关系。</p>
<ul>
<li>docker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。</li>
<li>docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。</li>
<li>docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure>
<p>注意：web 服务不会等待 redis和db 完全启动 之后才启动。</p>
<h4 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h4><p>指定与服务的部署和运行有关的配置。只在 swarm 模式下才会有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    deploy:</span><br><span class="line">      mode：replicated</span><br><span class="line">      replicas: 6</span><br><span class="line">      endpoint_mode: dnsrr</span><br><span class="line">      labels: </span><br><span class="line">        description: &quot;This redis service label&quot;</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &#x27;0.50&#x27;</span><br><span class="line">          memory: 50M</span><br><span class="line">        reservations:</span><br><span class="line">          cpus: &#x27;0.25&#x27;</span><br><span class="line">          memory: 20M</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 5s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">        window: 120s</span><br></pre></td></tr></table></figure>
<p>可以选参数：</p>
<ul>
<li><p>endpoint_mode：访问集群服务的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">endpoint_mode: vip </span><br><span class="line"># Docker 集群服务一个对外的虚拟 ip。所有的请求都会通过这个虚拟 ip 到达集群服务内部的机器。</span><br><span class="line">endpoint_mode: dnsrr</span><br><span class="line"># DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群 ip 列表中的一个 ip 地址。</span><br></pre></td></tr></table></figure>
</li>
<li><p>labels：在服务上设置标签。可以用容器上的 labels（跟 deploy 同级的配置） 覆盖 deploy 下的 labels。</p>
</li>
<li><p>mode：指定服务提供的模式。</p>
</li>
</ul>
<ul>
<li><p>replicated：复制服务，复制指定服务到集群的机器上。</p>
</li>
<li><p>global：全局服务，服务将部署至集群的每个节点。</p>
</li>
<li><p>图解：下图中黄色的方块是 replicated 模式的运行情况，灰色方块是 global 模式的运行情况。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/11/docker-composex.png" alt="img"></p>
</li>
</ul>
<p>replicas：mode 为 replicated 时，需要使用此参数配置具体运行的节点数量。</p>
<p>resources：配置服务器资源使用的限制，例如上例子，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用。避免占用资源过高出现异常。</p>
<p>restart_policy：配置如何在退出容器时重新启动容器。</p>
<ul>
<li>condition：可选 none，on-failure 或者 any（默认值：any）。</li>
<li>delay：设置多久之后重启（默认值：0）。</li>
<li>max_attempts：尝试重新启动容器的次数，超出次数，则不再尝试（默认值：一直重试）。</li>
<li>window：设置容器重启超时时间（默认值：0）。</li>
</ul>
<p>rollback_config：配置在更新失败的情况下应如何回滚服务。</p>
<ul>
<li>parallelism：一次要回滚的容器数。如果设置为0，则所有容器将同时回滚。</li>
<li>delay：每个容器组回滚之间等待的时间（默认为0s）。</li>
<li>failure_action：如果回滚失败，该怎么办。其中一个 continue 或者 pause（默认pause）。</li>
<li>monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。</li>
<li>max_failure_ratio：在回滚期间可以容忍的故障率（默认为0）。</li>
<li>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认 stop-first ）。</li>
</ul>
<p>update_config：配置应如何更新服务，对于配置滚动更新很有用。</p>
<ul>
<li>parallelism：一次更新的容器数。</li>
<li>delay：在更新一组容器之间等待的时间。</li>
<li>failure_action：如果更新失败，该怎么办。其中一个 continue，rollback 或者pause （默认：pause）。</li>
<li>monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。</li>
<li>max_failure_ratio：在更新过程中可以容忍的故障率。</li>
<li>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认stop-first）。</li>
</ul>
<p><strong>注</strong>：仅支持 V3.4 及更高版本。</p>
<h4 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h4><p>指定设备映射列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devices:</span><br><span class="line">  - &quot;/dev/ttyUSB0:/dev/ttyUSB0&quot;</span><br></pre></td></tr></table></figure>
<h4 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h4><p>自定义 DNS 服务器，可以是单个值或列表的多个值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 9.9.9.9</span><br></pre></td></tr></table></figure>
<h4 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h4><p>自定义 DNS 搜索域。可以是单个值或列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line"></span><br><span class="line">dns_search:</span><br><span class="line">  - dc1.example.com</span><br><span class="line">  - dc2.example.com</span><br></pre></td></tr></table></figure>
<h4 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h4><p>覆盖容器默认的 entrypoint。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entrypoint: /code/entrypoint.sh</span><br></pre></td></tr></table></figure>
<p>也可以是以下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">entrypoint:</span><br><span class="line">    - php</span><br><span class="line">    - -d</span><br><span class="line">    - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so</span><br><span class="line">    - -d</span><br><span class="line">    - memory_limit=-1</span><br><span class="line">    - vendor/bin/phpunit</span><br></pre></td></tr></table></figure>
<h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h4><p>从文件添加环境变量。可以是单个值或列表的多个值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br></pre></td></tr></table></figure>
<p>也可以是列表格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure>
<h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p>添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SHOW: &#x27;true&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h4><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p>
<p>仅可以指定内部端口为参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000&quot;</span><br></pre></td></tr></table></figure>
<h4 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h4><p>添加主机名映射。类似 docker client —add-host。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - &quot;somehost:162.242.195.82&quot;</span><br><span class="line"> - &quot;otherhost:50.31.209.229&quot;</span><br></pre></td></tr></table></figure>
<p>以上会在此服务的内部容器中 /etc/hosts 创建一个具有 ip 地址和主机名的映射关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">162.242.195.82  somehost</span><br><span class="line">50.31.209.229   otherhost</span><br></pre></td></tr></table></figure>
<h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h4><p>用于检测 docker 服务是否健康运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;] # 设置检测程序</span><br><span class="line">  interval: 1m30s # 设置检测间隔</span><br><span class="line">  timeout: 10s # 设置检测超时时间</span><br><span class="line">  retries: 3 # 设置重试次数</span><br><span class="line">  start_period: 40s # 启动后，多少秒开始启动检测程序</span><br></pre></td></tr></table></figure>
<h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>指定容器运行的镜像。以下格式都可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image: redis</span><br><span class="line">image: ubuntu:14.04</span><br><span class="line">image: tutum/influxdb</span><br><span class="line">image: example-registry.com:4000/postgresql</span><br><span class="line">image: a4bc65fd # 镜像id</span><br></pre></td></tr></table></figure>
<h4 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h4><p>服务的日志记录配置。</p>
<p>driver：指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver: &quot;json-file&quot;</span><br><span class="line">driver: &quot;syslog&quot;</span><br><span class="line">driver: &quot;none&quot;</span><br></pre></td></tr></table></figure>
<p>仅在 json-file 驱动程序下，可以使用以下参数，限制日志得数量和大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: json-file</span><br><span class="line">  options:</span><br><span class="line">    max-size: &quot;200k&quot; # 单个文件大小为200k</span><br><span class="line">    max-file: &quot;10&quot; # 最多10个文件</span><br></pre></td></tr></table></figure>
<p>当达到文件限制上限，会自动删除旧的文件。</p>
<p>syslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: &quot;tcp://192.168.0.42:123&quot;</span><br></pre></td></tr></table></figure>
<h4 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h4><p>设置网络模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name/id]&quot;</span><br></pre></td></tr></table></figure>
<p>配置容器连接的网络，引用顶级 networks 下的条目 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">      some-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias1</span><br><span class="line">      other-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias2</span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">    # Use a custom driver</span><br><span class="line">    driver: custom-driver-1</span><br><span class="line">  other-network:</span><br><span class="line">    # Use a custom driver which takes special options</span><br><span class="line">    driver: custom-driver-2</span><br></pre></td></tr></table></figure>
<ul>
<li>aliases ：同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务。</li>
</ul>
<h4 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h4><ul>
<li>no：是默认的重启策略，在任何情况下都不会重启容器。</li>
<li>always：容器总是重新启动。</li>
<li>on-failure：在容器非正常退出时（退出状态非0），才会重启容器。</li>
<li>unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restart: &quot;no&quot;</span><br><span class="line">restart: always</span><br><span class="line">restart: on-failure</span><br><span class="line">restart: unless-stopped</span><br></pre></td></tr></table></figure>
<p>注：swarm 集群模式，请改用 restart_policy。</p>
<h4 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a>secrets</h4><p>存储敏感数据，例如密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.1&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">  image: mysql</span><br><span class="line">  environment:</span><br><span class="line">    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/my_secret</span><br><span class="line">  secrets:</span><br><span class="line">    - my_secret</span><br><span class="line"></span><br><span class="line">secrets:</span><br><span class="line">  my_secret:</span><br><span class="line">    file: ./my_secret.txt</span><br></pre></td></tr></table></figure>
<h4 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a>security_opt</h4><p>修改容器默认的 schema 标签。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">security-opt：</span><br><span class="line">  - label:user:USER   # 设置容器的用户标签</span><br><span class="line">  - label:role:ROLE   # 设置容器的角色标签</span><br><span class="line">  - label:type:TYPE   # 设置容器的安全策略标签</span><br><span class="line">  - label:level:LEVEL  # 设置容器的安全等级标签</span><br></pre></td></tr></table></figure>
<h4 id="stop-grace-period"><a href="#stop-grace-period" class="headerlink" title="stop_grace_period"></a>stop_grace_period</h4><p>指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop_grace_period: 1s # 等待 1 秒</span><br><span class="line">stop_grace_period: 1m30s # 等待 1 分 30 秒 </span><br></pre></td></tr></table></figure>
<p>默认的等待时间是 10 秒。</p>
<h4 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a>stop_signal</h4><p>设置停止容器的替代信号。默认情况下使用 SIGTERM 。</p>
<p>以下示例，使用 SIGUSR1 替代信号 SIGTERM 来停止容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop_signal: SIGUSR1</span><br></pre></td></tr></table></figure>
<h4 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h4><p>设置容器中的内核参数，可以使用数组或字典格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconn: 1024</span><br><span class="line">  net.ipv4.tcp_syncookies: 0</span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconn=1024</span><br><span class="line">  - net.ipv4.tcp_syncookies=0</span><br></pre></td></tr></table></figure>
<h4 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h4><p>在容器内安装一个临时文件系统。可以是单个值或列表的多个值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tmpfs: /run</span><br><span class="line"></span><br><span class="line">tmpfs:</span><br><span class="line">  - /run</span><br><span class="line">  - /tmp</span><br></pre></td></tr></table></figure>
<h4 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h4><p>覆盖容器默认的 ulimit。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure>
<h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h4><p>将主机的数据卷或着文件挂载到容器里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres:latest</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/localhost/postgres.sock:/var/run/postgres/postgres.sock&quot;</span><br><span class="line">      - &quot;/localhost/data:/var/lib/postgresql/data&quot;</span><br></pre></td></tr></table></figure>
<h2 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Docker Machine 是一种可以让您在虚拟主机上安装 Docker 的工具，并可以使用 docker-machine 命令来管理主机。</p>
<p>Docker Machine 也可以集中管理所有的 docker 主机，比如快速的给 100 台服务器安装上 docker。</p>
<p>Docker Machine 管理的虚拟主机可以是机上的，也可以是云供应商，如阿里云，腾讯云，AWS，或 DigitalOcean。</p>
<p>使用 docker-machine 命令，您可以启动，检查，停止和重新启动托管主机，也可以升级 Docker 客户端和守护程序，以及配置 Docker 客户端与您的主机进行通信。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 Docker Machine 之前你需要先安装 Docker。</p>
<p>Docker Machine 可以在多种平台上安装使用，包括 Linux 、MacOS 以及 windows。</p>
<h4 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;</span><br><span class="line">  curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/tmp/docker-machine &amp;&amp;</span><br><span class="line">  sudo mv /tmp/docker-machine /usr/local/bin/docker-machine &amp;&amp;</span><br><span class="line">  chmod +x /usr/local/bin/docker-machine</span><br></pre></td></tr></table></figure>
<p>查看是否安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-machine version</span><br><span class="line">docker-machine version 0.16.0, build 9371605</span><br></pre></td></tr></table></figure>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>本章通过 virtualbox 来介绍 docker-machine 的使用方法。其他云服务商操作与此基本一致。具体可以参考每家服务商的指导文档。</p>
<h4 id="1、列出可用的机器"><a href="#1、列出可用的机器" class="headerlink" title="1、列出可用的机器"></a>1、列出可用的机器</h4><p>可以看到目前只有这里默认的 default 虚拟机。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ls</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine1.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine1.png" alt="img"></a></p>
<h4 id="2、创建机器"><a href="#2、创建机器" class="headerlink" title="2、创建机器"></a>2、创建机器</h4><p>创建一台名为 test 的机器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create --driver virtualbox test</span><br></pre></td></tr></table></figure>
<ul>
<li>—driver：指定用来创建机器的驱动类型，这里是 virtualbox。</li>
</ul>
<h4 id="3、查看机器的-ip"><a href="#3、查看机器的-ip" class="headerlink" title="3、查看机器的 ip"></a>3、查看机器的 ip</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ip test</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine3.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine3.png" alt="img"></a></p>
<h4 id="4、停止机器"><a href="#4、停止机器" class="headerlink" title="4、停止机器"></a>4、停止机器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine stop test</span><br></pre></td></tr></table></figure>
<h4 id="5、启动机器"><a href="#5、启动机器" class="headerlink" title="5、启动机器"></a>5、启动机器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine start test</span><br></pre></td></tr></table></figure>
<h4 id="6、进入机器"><a href="#6、进入机器" class="headerlink" title="6、进入机器"></a>6、进入机器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh test</span><br></pre></td></tr></table></figure>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul>
<li><p>docker-machine active：查看当前激活状态的 Docker 主机。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line"></span><br><span class="line">NAME      ACTIVE   DRIVER         STATE     URL</span><br><span class="line">dev       -        virtualbox     Running   tcp://192.168.99.103:2376</span><br><span class="line">staging   *        digitalocean   Running   tcp://203.0.113.81:2376</span><br><span class="line"></span><br><span class="line">$ echo $DOCKER_HOST</span><br><span class="line">tcp://203.0.113.81:2376</span><br><span class="line"></span><br><span class="line">$ docker-machine active</span><br><span class="line">staging</span><br></pre></td></tr></table></figure>
</li>
<li><p>config：查看当前激活状态 Docker 主机的连接信息。</p>
</li>
<li><p>create：创建 Docker 主机</p>
</li>
<li><p>env：显示连接到某个主机需要的环境变量</p>
</li>
<li><p>inspect： 以 json 格式输出指定Docker的详细信息</p>
</li>
<li><p>ip： 获取指定 Docker 主机的地址</p>
</li>
<li><p>kill： 直接杀死指定的 Docker 主机</p>
</li>
<li><p>ls： 列出所有的管理主机</p>
</li>
<li><p>provision： 重新配置指定主机</p>
</li>
<li><p>regenerate-certs： 为某个主机重新生成 TLS 信息</p>
</li>
<li><p>restart： 重启指定的主机</p>
</li>
<li><p>rm： 删除某台 Docker 主机，对应的虚拟机也会被删除</p>
</li>
<li><p>ssh： 通过 SSH 连接到主机上，执行命令</p>
</li>
<li><p>scp： 在 Docker 主机之间以及 Docker 主机和本地主机之间通过 scp 远程复制数据</p>
</li>
<li><p>mount： 使用 SSHFS 从计算机装载或卸载目录</p>
</li>
<li><p>start： 启动一个指定的 Docker 主机，如果对象是个虚拟机，该虚拟机将被启动</p>
</li>
<li><p>status： 获取指定 Docker 主机的状态(包括：Running、Paused、Saved、Stopped、Stopping、Starting、Error)等</p>
</li>
<li><p>stop： 停止一个指定的 Docker 主机</p>
</li>
<li><p>upgrade： 将一个指定主机的 Docker 版本更新为最新</p>
</li>
<li><p>url： 获取指定 Docker 主机的监听 URL</p>
</li>
<li><p>version： 显示 Docker Machine 的版本或者主机 Docker 版本</p>
</li>
<li><p>help： 显示帮助信息</p>
</li>
</ul>
<h2 id="Swarm-集群管理"><a href="#Swarm-集群管理" class="headerlink" title="Swarm 集群管理"></a>Swarm 集群管理</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Docker Swarm 是 Docker 的集群管理工具。它将 Docker 主机池转变为单个虚拟 Docker 主机。 Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护程序通信的工具都可以使用 Swarm 轻松地扩展到多个主机。</p>
<p>支持的工具包括但不限于以下各项：</p>
<ul>
<li>Dokku</li>
<li>Docker Compose</li>
<li>Docker Machine</li>
<li>Jenkins</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>如下图所示，swarm 集群由管理节点（manager）和工作节点（work node）构成。</p>
<ul>
<li>swarm mananger：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。</li>
<li>work node：即图中的 available node，主要负责运行相应的服务来执行任务（task）。</li>
</ul>
<p><img src="https://image.rexking6.top/img/services-diagram.png" alt=""></p>
<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p>以下示例，均以 Docker Machine 和 virtualbox 进行介绍，确保你的主机已安装 virtualbox。</p>
<h4 id="1、创建-swarm-集群管理节点（manager）"><a href="#1、创建-swarm-集群管理节点（manager）" class="headerlink" title="1、创建 swarm 集群管理节点（manager）"></a>1、创建 swarm 集群管理节点（manager）</h4><p>创建 docker 机器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create -d virtualbox swarm-manager</span><br></pre></td></tr></table></figure>
<p>初始化 swarm 集群，进行初始化的这台机器，就是集群的管理节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh swarm-manager</span><br><span class="line">docker swarm init --advertise-addr 192.168.99.107 #这里的 IP 为创建机器时分配的 ip。</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/swarm2.png" alt=""></p>
<p>以上输出，证明已经初始化成功。需要把以下这行复制出来，在增加工作节点时会用到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join --token SWMTKN-1-4oogo9qziq768dma0uh3j0z0m5twlm10iynvz7ixza96k6jh9p-ajkb6w7qd06y1e33yrgko64sk 192.168.99.107:2377</span><br></pre></td></tr></table></figure>
<h4 id="2、创建-swarm-集群工作节点（worker）"><a href="#2、创建-swarm-集群工作节点（worker）" class="headerlink" title="2、创建 swarm 集群工作节点（worker）"></a>2、创建 swarm 集群工作节点（worker）</h4><p>这里直接创建好俩台机器，swarm-worker1 和 swarm-worker2 。</p>
<p><img src="https://image.rexking6.top/img/swarm3.png" alt=""></p>
<p>分别进入两个机器里，指定添加至上一步中创建的集群，这里会用到上一步复制的内容。</p>
<p><img src="https://image.rexking6.top/img/swarm4.png" alt=""></p>
<p>以上数据输出说明已经添加成功。</p>
<p>上图中，由于上一步复制的内容比较长，会被自动截断，实际上在图运行的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join --token SWMTKN-1-4oogo9qziq768dma0uh3j0z0m5twlm10iynvz7ixza96k6jh9p-ajkb6w7qd06y1e33yrgko64sk 192.168.99.107:2377</span><br></pre></td></tr></table></figure>
<h4 id="3、查看集群信息"><a href="#3、查看集群信息" class="headerlink" title="3、查看集群信息"></a>3、查看集群信息</h4><p>进入管理节点，执行：<code>docker info</code> 可以查看当前集群的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker info</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/swarm5.png" alt=""></p>
<p>通过画红圈的地方，可以知道当前运行的集群中，有三个节点，其中有一个是管理节点。</p>
<h4 id="4、部署服务到集群中"><a href="#4、部署服务到集群中" class="headerlink" title="4、部署服务到集群中"></a>4、部署服务到集群中</h4><p><strong>注意</strong>：跟集群管理有关的任何操作，都是在管理节点上操作的。</p>
<p>以下例子，在一个工作节点上创建一个名为 helloworld 的服务，这里是随机指派给一个工作节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --replicas 1 --name helloworld alpine ping docker.com</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/swarm6.png" alt=""></p>
<h4 id="5、查看服务部署情况"><a href="#5、查看服务部署情况" class="headerlink" title="5、查看服务部署情况"></a>5、查看服务部署情况</h4><p>查看 helloworld 服务运行在哪个节点上，可以看到目前是在 swarm-worker1 节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service ps helloworld</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/swarm7.png" alt=""></p>
<p>查看 helloworld 部署的具体信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service inspect --pretty helloworld</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/swarm8.png" alt=""></p>
<h4 id="6、扩展集群服务"><a href="#6、扩展集群服务" class="headerlink" title="6、扩展集群服务"></a>6、扩展集群服务</h4><p>将上述的 helloworld 服务扩展到俩个节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service scale helloworld=2</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/swarm9.png" alt=""></p>
<p>可以看到已经从一个节点，扩展到两个节点。</p>
<p><img src="https://image.rexking6.top/img/swarm10.png" alt=""></p>
<h4 id="7、删除服务"><a href="#7、删除服务" class="headerlink" title="7、删除服务"></a>7、删除服务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service rm helloworld</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/swarm11.png" alt=""></p>
<p>查看是否已删除：</p>
<p><img src="https://image.rexking6.top/img/swarm12.png" alt=""></p>
<h4 id="8、滚动升级服务"><a href="#8、滚动升级服务" class="headerlink" title="8、滚动升级服务"></a>8、滚动升级服务</h4><p>以下实例，我们将介绍 redis 版本如何滚动升级至更高版本。</p>
<p>创建一个 3.0.6 版本的 redis。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --replicas 1 --name redis --update-delay 10s redis:3.0.6</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/swarm13.png" alt=""></p>
<p>滚动升级 redis 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker@swarm-manager:~$ docker service update --image redis:3.0.7 redis</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/swarm14.png" alt=""></p>
<p>看图可以知道 redis 的版本已经从 3.0.6 升级到了 3.0.7，说明服务已经升级成功。</p>
<h4 id="9、停止某个节点接收新的任务"><a href="#9、停止某个节点接收新的任务" class="headerlink" title="9、停止某个节点接收新的任务"></a>9、停止某个节点接收新的任务</h4><p>查看所有的节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node ls</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/swarm16.png" alt=""></p>
<p>可以看到目前所有的节点都是 Active, 可以接收新的任务分配。</p>
<p>停止节点 swarm-worker1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node update --availability drain swarm-worker1</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/swarm17.png" alt=""></p>
<p><strong>注意</strong>：swarm-worker1 状态变为 Drain。不会影响到集群的服务，只是 swarm-worker1 节点不再接收新的任务，集群的负载能力有所下降。</p>
<p>可以通过以下命令重新激活节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node update --availability active swarm-worker1</span><br></pre></td></tr></table></figure>
<p><img src="https://image.rexking6.top/img/swarm19.png" alt=""></p>
<h1 id="OpenStack、Docker、k8s与Mesos"><a href="#OpenStack、Docker、k8s与Mesos" class="headerlink" title="OpenStack、Docker、k8s与Mesos"></a>OpenStack、Docker、k8s与Mesos</h1><p><strong><em>可以简单理解为OpenStack是对虚拟机的管理编排，k8s是对Docker容器的管理编排。</em></strong></p>
<ul>
<li>OpenStack：公认的云计算IaaS平台，其管理的核心目标对象是机器（虚拟机或物理机），当然也可以管理存储和网络，但那些也大都是围绕着机器所提供的配套资源。近年来容器技术火了之后，OpenStack也开始通过各种方式增加对容器的支持，但目前OpenStack还不被视为管理容器的主流平台。</li>
<li>Docker：这里假定指的是Docker engine（也叫做Docker daemon，或最新的名字：Moby），它是一种容器运行时（container runtime）的实现，而且是最主流的实现，几乎就是容器业界的事实标准。Docker是用来创建和管理容器的，它和容器的关系就好比Hypervisor（比如：KVM）和虚拟机之间的关系。当然，Docker公司对Docker engine本身的定位和期望不仅仅在于在单机上管理容器，所以近年来一直在向Docker engine中加入各种各样的高级功能，比如：组建多节点的Docker集群、容器编排、服务发现，等等。</li>
<li>Kubernetes（K8s）：搭建容器集群和进行容器编排的主流开源项目（亲爹是Google），适合搭建PaaS平台。容器是Kubernetes管理的核心目标对象，它和容器的关系就好比OpenStack和虚拟机之间的关系，而它和Docker的关系就好比OpenStack和Hypervisor之间的关系。一般来说，Kubernetes是和Docker配合使用的，Kubernetes调用每个节点上的Docker去创建和管理容器，所以，可以认为Kubernetes是大脑，而Docker是四肢。</li>
<li>Mesos：Mesos是一个通用资源管理平台，它所管理的核心目标对象既不是虚拟机/物理机，也不是容器，而是各种各样的计算资源（CPU、memory、disk、port、GPU等等）。Mesos会收集各个节点上的计算资源然后提供给运行在它之上的应用框架（比如：Spark、Marathon、甚至是Kubernetes）来使用，应用框架可以将收到的计算资源以自己喜欢的任何方式创建成计算任务来完成特定工作（比如：创建一个大数据任务计算个π什么的）。由于容器技术近年来的火热，Mesos也对容器进行非常深层次的支持，它内部完整地实现了一个容器运行时（类似于Docker），所以，上层的应用框架可以方便地把自己的计算任务以容器的方式在Mesos管理的计算集群中运行起来。使用Mesos的门槛相对较高（需要应用框架编写代码调用Mesos的API和其集成），但一旦用起来之后灵活性和可扩展性更高，因为Mesos并不限制应用框架如何使用计算资源（可以以容器的方式使用，也可以是其它方式，比如：传统的进程），主动权完全在应用框架自己手中。作为对比，Kubernetes只能管理容器，所有任务都必须以容器的方式来运行。为了解决门槛较高的问题（当然也是为了赚钱），Mesosphere（Mesos这个开源项目背后的商业公司）推出了DC/OS，其核心就是Mesos加一个内置的应用框架Marathon（可以用做容器编排），能够达到开箱即用的效果，安装好之后立刻就可以创建和管理容器和非容器类的任务了。</li>
</ul>
<h1 id="Kubernetes（k8s）"><a href="#Kubernetes（k8s）" class="headerlink" title="Kubernetes（k8s）"></a>Kubernetes（k8s）</h1><h2 id="1、为什么要-Kubernetes"><a href="#1、为什么要-Kubernetes" class="headerlink" title="1、为什么要 Kubernetes"></a>1、为什么要 Kubernetes</h2><p>尽管 Docker 为容器化的应用程序提供了开放标准，但随着容器越来越多出现了一系列新问题：</p>
<ul>
<li>单机不足以支持更多的容器</li>
<li>分布式环境下容器如何通信？</li>
<li>如何协调和调度这些容器？</li>
<li>如何在升级应用程序时不会中断服务？</li>
<li>如何监视应用程序的运行状况？</li>
<li>如何批量重新启动容器里的程序？</li>
<li>…</li>
</ul>
<p>Kubernetes 应运而生。</p>
<h2 id="2、什么是-Kubernetes"><a href="#2、什么是-Kubernetes" class="headerlink" title="2、什么是 Kubernetes"></a>2、什么是 Kubernetes</h2><p>Kubernetes 是一个全新的基于容器技术的分布式架构方案，这个方案虽然还很新，但却是 Google 十几年来大规模应用容器技术的经验积累和升华的重要成果，确切的说是 Google 一个久负盛名的内部使用的大规模集群管理系统——Borg 的开源版本，其目的是实现资源管理的自动化以及跨数据中心的资源利用率最大化。</p>
<p>Kubernetes 具有完备的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建的智能负载均衡器、强大的故障发现和自我修复能力、服务滚动升级和在线扩容能力、可扩展的资源自动调度机制，以及多力度的资源配额管理能力。同时，Kubernetes 提供了完善的管理工具，这些工具涵盖了包括开发、部署测试、运维监控在内的各个环节，不仅是一个全新的基于容器技术的分布式架构解决方案，还是一个一站式的完备分布式系统开发和支撑平台。</p>
<h2 id="3、Kubernetes-术语"><a href="#3、Kubernetes-术语" class="headerlink" title="3、Kubernetes 术语"></a>3、Kubernetes 术语</h2><h3 id="1-Pod"><a href="#1-Pod" class="headerlink" title="1. Pod"></a>1. Pod</h3><p>Pod 是 Kubernetes 最重要的基本概念，可由多个容器（一般而言一个容器一个进程，不建议一个容器多个进程）组成，它是系统中资源分配和调度的最小单位。下图是 Pod 的组成示意图，其中有一个特殊的 Pause 容器:</p>
<p><img src="https://image.rexking6.top/img/image-20210724210117858.png" alt=""></p>
<p>Pause 容器的状态标识了一个 Pod 的状态，也就是代表了 Pod 的生命周期。另外 Pod 中其余容器共享 Pause 容器的命名空间，使得 Pod 内的容器能够共享 Pause 容器的 IP，以及实现文件共享。以下是一个 Pod 的定义：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  <span class="comment"># 分组和版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>       <span class="comment"># 资源类型</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myWeb</span>   <span class="comment"># Pod名</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myWeb</span> <span class="comment"># Pod的标签</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myWeb</span> <span class="comment"># 容器名</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kubeguide/tomcat-app:v1</span>  <span class="comment"># 容器使用的镜像</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span> <span class="comment"># 容器监听的端口</span></span><br><span class="line">    <span class="attr">env:</span>  <span class="comment"># 容器内环境变量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_SERVICE_HOST</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&#x27;mysql&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_SERVICE_PORT</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&#x27;3306&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span>   <span class="comment"># 容器资源配置</span></span><br><span class="line">      <span class="attr">requests:</span>  <span class="comment"># 资源下限，m表示cpu配额的最小单位，为1/1000核</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;64Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;250m&quot;</span></span><br><span class="line">      <span class="attr">limits:</span>    <span class="comment"># 资源上限</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>EndPoint : PodIP + containerPort，代表一个服务进程的对外通信地址。一个 Pod 也存在具有多个 Endpoint 的情况，比如当我们把 Tomcat 定义为一个 Pod 时，可以对外暴露管理端口与服务端口这两个 Endpoint。</p>
</blockquote>
<h3 id="2-Label"><a href="#2-Label" class="headerlink" title="2. Label"></a>2. Label</h3><p>Label 是 Kubernetes 系统中的一个核心概念，一个 Label 表示一个 key=value 的键值对，key、value 的值由用户指定。Label 可以被附加到各种资源对象上，例如 Node、Pod、Service、RC 等，一个资源对象可以定义任意数量的 Label，同一个 Label 也可以被添加到任意数量的资源对象上。Label 通常在资源对象定义时确定，也可以在对象创建后动态添加或者删除。给一个资源对象定义了 Label 后，我们随后可以通过 Label Selector 查询和筛选拥有这个 Label 的资源对象，来实现多维度的资源分组管理功能，以便灵活、方便地进行资源分配、调 度、配置、部署等管理工作。</p>
<p>Label Selector 当前有两种表达式，基于等式的和基于集合的:</p>
<ul>
<li><code>name=redis-slave</code>：匹配所有具有标签<code>name=redis-slave</code>的资源对象。</li>
<li><code>env!=production</code>：匹配所有不具有标签<code>env=production</code>的资源对象。</li>
<li><code>name in(redis-master, redis-slave)</code>：<code>name=redis-master</code>或者<code>name=redis-slave</code>的资源对象。</li>
<li><code>name not in(php-frontend)</code>：匹配所有不具有标签<code>name=php-frontend</code>的资源对象。</li>
</ul>
<p>以 myWeb Pod 为例:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  <span class="comment"># 分组和版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>       <span class="comment"># 资源类型</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myWeb</span>   <span class="comment"># Pod名</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myWeb</span> <span class="comment"># Pod的标签</span></span><br></pre></td></tr></table></figure>
<p>当一个 Service 的 selector 中指明了这个 Pod 时，该 Pod 就会与该 Service 绑定</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myWeb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myWeb</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>
<h3 id="3-Replication-Controller"><a href="#3-Replication-Controller" class="headerlink" title="3. Replication Controller"></a>3. Replication Controller</h3><p>Replication Controller，简称 RC，简单来说，它其实定义了一个期望的场景，即声明某种 Pod 的副本数量在任意时刻都符合某个预期值。</p>
<p>RC 的定义包括如下几个部分：</p>
<ul>
<li>Pod 期待的副本数量</li>
<li>用于筛选目标 Pod 的 Label Selector</li>
<li>当 Pod 的副本数小于预期数量时，用于创建新 Pod 的模版（template）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span>  <span class="comment"># Pod 副本数量</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">template:</span>   <span class="comment"># Pod 模版</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">frontend</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat_demp</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">tomcat</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>
<p>当提交这个 RC 在集群中后，Controller Manager 会定期巡检，确保目标 Pod 实例的数量等于 RC 的预期值，过多的数量会被停掉，少了则会创建补充。通过<code>kubectl scale</code>可以动态指定 RC 的预期副本数量。</p>
<blockquote>
<p>目前，RC 已升级为新概念——Replica Set（RS），两者当前唯一区别是，RS 支持了基于集合的 Label Selector，而 RC 只支持基于等式的 Label Selector。RS 很少单独使用，更多是被 Deployment 这个更高层的资源对象所使用，所以可以视作 RS+Deployment 将逐渐取代 RC 的作用。</p>
</blockquote>
<h3 id="4-Deployment"><a href="#4-Deployment" class="headerlink" title="4. Deployment"></a>4. Deployment</h3><p>Deployment 和 RC 相似度超过 90%，无论是作用、目的、Yaml 定义还是具体命令行操作，所以可以将其看作是 RC 的升级。而 Deployment 相对于 RC 的一个最大区别是我们可以随时知道当前 Pod“部署”的进度。实际上由于一个 Pod 的创建、调度、绑定节点及在目 标 Node 上启动对应的容器这一完整过程需要一定的时间，所以我们期待系统启动 N 个 Pod 副本的目标状态，实际上是一个连续变化的“部署过程”导致的最终状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: frontend</span><br><span class="line">    matchExpressions:</span><br><span class="line">      - &#123;key: app, operator: In, values [frontend]&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: frontend</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: tomcat_demp</span><br><span class="line">        image: tomcat</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br></pre></td></tr></table></figure>
<h3 id="5-Horizontal-Pod-Autoscaler"><a href="#5-Horizontal-Pod-Autoscaler" class="headerlink" title="5. Horizontal Pod Autoscaler"></a>5. Horizontal Pod Autoscaler</h3><p>除了手动执行<code>kubectl scale</code>完成 Pod 的扩缩容之外，还可以通过 Horizontal Pod Autoscaling（HPA）横向自动扩容来进行自动扩缩容。其原理是追踪分析目标 Pod 的负载变化情况，来确定是否需要针对性地调整目标 Pod 数量。当前，HPA 有两种方式作为 Pod 负载的度量指标：</p>
<ul>
<li>CPUUtilizationPercentage，目标 Pod 所有副本自身的 CPU 利用率的平均值。</li>
<li>应用程序自定义的度量指标，比如服务在每秒内的相应请求数（TPS 或 QPS）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: autoscaling/v1</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  name: php-apache</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  maxReplicas: 3</span><br><span class="line">  minReplicas: 1</span><br><span class="line">  scaletargetRef:</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: php-apache</span><br><span class="line">  targetCPUUtilizationPercentage: 90</span><br></pre></td></tr></table></figure>
<p>根据上边定义，当 Pod 副本的 CPUUtilizationPercentage 超过 90%时就会出发自动扩容行为，数量约束为 1 ～ 3 个。</p>
<h3 id="6-StatefulSet"><a href="#6-StatefulSet" class="headerlink" title="6. StatefulSet"></a>6. StatefulSet</h3><p>在 Kubernetes 系统中，Pod 的管理对象 RC、Deployment、DaemonSet 和 Job 都面向无状态的服务。</p>
<blockquote>
<p>通常情况下，Deployment 被用来部署无状态服务，那么对于有状态服务的部署，使用 StatefulSet 进行有状态服务的部署。</p>
<p>什么是有状态服务?</p>
<ul>
<li>有实时的数据需要存储。</li>
<li>有状态服务集群中，把某一个服务抽离出去，一段时间后再加入机器网络，如果集群网络无法使用。</li>
</ul>
<p>什么是无状态服务?</p>
<ul>
<li>没有实时的数据需要存储。</li>
<li>无状态服务集群中，把某一个服务抽离出去，一段时间后再加入机器网络，对集群服务没有任何影响。</li>
</ul>
</blockquote>
<p>但现实中有很多服务是有状态的，特别是 一些复杂的中间件集群，例如 MySQL 集群、MongoDB 集群、Akka 集 群、ZooKeeper 集群等，这些应用集群有 4 个共同点。</p>
<ol>
<li>每个节点都有固定的身份 ID，通过这个 ID，集群中的成员可 以相互发现并通信。</li>
<li>集群的规模是比较固定的，集群规模不能随意变动。</li>
<li>集群中的每个节点都是有状态的，通常会持久化数据到永久存储中。</li>
<li>如果磁盘损坏，则集群里的某个节点无法正常运行，集群功能受损。</li>
</ol>
<p>因此，StatefulSet 具有以下特点：</p>
<ul>
<li>StatefulSet 里的每个 Pod 都有稳定、唯一的网络标识，可以用来发现集群内的其他成员。假设 StatefulSet 的名称为 kafka，那么第 1 个 Pod 叫 kafka-0，第 2 个叫 kafka-1，以此类推。</li>
<li>StatefulSet 控制的 Pod 副本的启停顺序是受控的，操作第 n 个 Pod 时，前 n-1 个 Pod 已经是运行且准备好的状态。</li>
<li>StatefulSet 里的 Pod 采用稳定的持久化存储卷，通过 PV 或 PVC 来 实现，删除 Pod 时默认不会删除与 StatefulSet 相关的存储卷（为了保证数据的安全）。</li>
<li>StatefulSet 除了要与 PV 卷捆绑使用以存储 Pod 的状态数据，还要与 Headless Service 配合使用。<br>Headless Service : Headless Service 与普通 Service 的关键区别在于，它没有 Cluster IP，如果解析 Headless Service 的 DNS 域名，则返回的是该 Service 对应的全部 Pod 的 Endpoint 列表。</li>
</ul>
<h3 id="7-Service"><a href="#7-Service" class="headerlink" title="7. Service"></a>7. Service</h3><p>Service 在 Kubernetes 中定义了一个服务的访问入口地址，前端的应用（Pod）通过这个入口地址访问其背后的一组由 Pod 副本组成的集群实例，Service 与其后端 Pod 副本集群之间则是通过 Label Selector 来实现无缝对接的。</p>
<p><img src="https://pic1.zhimg.com/80/v2-7305c00631afe335a217ad23af43a040_720w.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: service</span><br><span class="line">metadata:</span><br><span class="line">  name: tomcat_service</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 8080</span><br><span class="line">   name: service_port</span><br><span class="line">  - port: 8005</span><br><span class="line">   name: shutdown_port</span><br><span class="line">  selector:</span><br><span class="line">    app: backend</span><br></pre></td></tr></table></figure>
<h4 id="Service-的负载均衡"><a href="#Service-的负载均衡" class="headerlink" title="Service 的负载均衡"></a>Service 的负载均衡</h4><p>在 Kubernetes 集群中，每个 Node 上会运行着 kube-proxy 组件，这其实就是一个负载均衡器，负责把对 Service 的请求转发到后端的某个 Pod 实例上，并在内部实现服务的负载均衡和会话保持机制。其主要的实现就是每个 Service 在集群中都被分配了一个全局唯一的 Cluster IP，因此我们对 Service 的网络通信根据内部的负载均衡算法和会话机制，便能与 Pod 副本集群通信。</p>
<h4 id="Service-的服务发现"><a href="#Service-的服务发现" class="headerlink" title="Service 的服务发现"></a>Service 的服务发现</h4><p>因为 Cluster IP 在 Service 的整个声明周期内是固定的，所以在 Kubernetes 中，只需将 Service 的 Name 和 其 Cluster IP 做一个 DNS 域名映射即可解决。</p>
<h3 id="8-Volume"><a href="#8-Volume" class="headerlink" title="8. Volume"></a>8. Volume</h3><p>Volume 是 Pod 中能够被多个容器访问的共享目录，Kubernetes 中的 Volume 概念、用途、目的与 Docker 中的 Volumn 比较类似，但不等价。首先，其可被定义在 Pod 上，然后被 一个 Pod 里的多个容器挂载到具体的文件目录下；其次，Kubernetes 中的 Volume 与 Pod 的生命周期相同，但与容器的生命周期不相关，当容器终止或者重启时，Volume 中的数据也不会丢失。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template:</span><br><span class="line">  metadata:</span><br><span class="line">    labels:</span><br><span class="line">      app: frontend</span><br><span class="line">  spec:</span><br><span class="line">    volumes:  # 声明可挂载的volume</span><br><span class="line">      - name: dataVol</span><br><span class="line">       emptyDir: &#123;&#125;</span><br><span class="line">    containers:</span><br><span class="line">    - name: tomcat_demo</span><br><span class="line">      image: tomcat</span><br><span class="line">      ports:</span><br><span class="line">      - containerPort: 8080</span><br><span class="line">      volumeMounts:  # 将volume通过name挂载到容器内的/mydata-data目录</span><br><span class="line">        - mountPath: /mydata-data</span><br><span class="line">         name: dataVol</span><br></pre></td></tr></table></figure>
<p>Kubernetes 提供了非常丰富的 Volume 类型:</p>
<ul>
<li>emptyDir，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为这是 Kubernetes 自动分配的一个目录，当 Pod 从 Node 上移除 emptyDir 中的数据也会被永久删除，适用于临时数据。</li>
<li>hostPath，hostPath 为在 Pod 上挂载宿主机上的文件或目录，适用于持久化保存的数据，比如容器应用程序生成的日志文件。</li>
<li>NFS，可使用 NFS 网络文件系统提供的共享目录存储数据。</li>
<li>其他云持久化盘等</li>
</ul>
<h3 id="9-Persistent-Volume"><a href="#9-Persistent-Volume" class="headerlink" title="9. Persistent Volume"></a>9. Persistent Volume</h3><p>在使用虚拟机的情况下，我们通常会先定义一个网络存储，然后从中划出一个“网盘”并挂接到虚拟机上。Persistent Volume（PV）和与之相关联的 Persistent Volume Claim（PVC）也起到了类似的作用。PV 可以被理解成 Kubernetes 集群中的某个网络存储对应的一块存储，它与 Volume 类似，但有以下区别:</p>
<ul>
<li>PV 只能是网络存储，不属于任何 Node，但可以在每个 Node 上访问。</li>
<li>PV 并不是被定义在 Pod 上的，而是独立于 Pod 之外定义的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv001</span><br><span class="line">  spec:</span><br><span class="line">    capacity:</span><br><span class="line">      storage: 5Gi</span><br><span class="line">    accessMods:</span><br><span class="line">      - ReadWriteOnce</span><br><span class="line">    nfs:</span><br><span class="line">      path: /somePath</span><br><span class="line">      server: xxx.xx.xx.x</span><br></pre></td></tr></table></figure>
<p>accessModes，有几种类型：</p>
<ol>
<li>ReadWriteOnce：读写权限，并且只能被单个 Node 挂载。</li>
<li>ReadOnlyMany：只读权限，允许被多个 Node 挂载。</li>
<li>ReadWriteMany：读写权限，允许被多个 Node 挂载。</li>
</ol>
<p>如果 Pod 想申请某种类型的 PV，首先需要定义一个 PersistentVolumeClaim 对象，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim  # 声明PVC</span><br><span class="line">metadata:</span><br><span class="line">  name: pvc001</span><br><span class="line">  spec:</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        storage: 5Gi</span><br><span class="line">    accessMods:</span><br><span class="line">      - ReadWriteOnce</span><br></pre></td></tr></table></figure>
<p>然后在 Pod 的 Volume 中引用 PVC 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  - name: mypd</span><br><span class="line">   persistentVolumeClaim:</span><br><span class="line">     claimName: pvc001</span><br></pre></td></tr></table></figure>
<p>PV 有以下几种状态：</p>
<ul>
<li>Available：空闲</li>
<li>Bound：已绑定到 PVC</li>
<li>Relead：对应 PVC 被删除，但 PV 还没被回收</li>
<li>Faild： PV 自动回收失败</li>
</ul>
<h3 id="10-Namespace"><a href="#10-Namespace" class="headerlink" title="10. Namespace"></a>10. Namespace</h3><p>Namespace 在很多情况下用于实现多租户的资源隔离。分组的不同项目、小组或用户组，便于不同的分组在共享使用整个集群的资源的同时还能被分别管理。Kubernetes 集群在启动后会创建一个名为 default 的 Namespace，通过 kubectl 可以查看:</p>
<p><img src="https://pic1.zhimg.com/80/v2-0e673b996fb2541b72278e169c1afff4_720w.jpg" alt="img"></p>
<h3 id="11-ConfigMap"><a href="#11-ConfigMap" class="headerlink" title="11. ConfigMap"></a>11. ConfigMap</h3><p>我们知道，Docker 通过将程序、依赖库、数据及 配置文件“打包固化”到一个不变的镜像文件中的做法，解决了应用的部署的难题，但这同时带来了棘手的问题，即配置文件中的参数在运行期如何修改的问题。我们不可能在启动 Docker 容器后再修改容器里的配置文件，然后用新的配置文件重启容器里的用户主进程。为了解决这个问题，Docker 提供了两种方式:</p>
<ul>
<li>在运行时通过容器的环境变量来传递参数;</li>
<li>通过 Docker Volume 将容器外的配置文件映射到容器内。</li>
</ul>
<p>在大多数情况下，后一种方式更合适我们的系统，因为大多数应用通常从一个或多个配置文件中读取参数。但这种方式也有明显的缺陷：我们必须在目标主机上先创建好对应配置文件，然后才能映射到容器里。上述缺陷在分布式情况下变得更为严重，因为无论采用哪种方式， 写入（修改）多台服务器上的某个指定文件，并确保这些文件保持一致，都是一个很难完成的目标。针对上述问题， Kubernetes 给出了一个很巧妙的设计实现。</p>
<p>首先，把所有的配置项都当作 key-value 字符串，这些配置项可以作为 Map 表中的一个项，整个 Map 的数据可以被持久化存储在 Kubernetes 的 ETCD 数据库中，然后提供 API 以方便 Kubernetes 相关组件或客户应用 CRUD 操作这些数据，上述专门用来保存配置参数的 Map 就是 Kubernetes ConfigMap 资源对象。Kubernetes 提供了一种内建机制，将存储在 ETCD 中的 ConfigMap 通过 Volume 映射的方式变成目标 Pod 内的配置文件，不管目标 Pod 被调度到哪台服务器上，都会完成自动映射。进一步地，如果 ConfigMap 中的 key-value 数据被修改，则映射到 Pod 中的“配置文件”也会随之自动更新。</p>
<p><img src="https://image.rexking6.top/img/v2-df516572fbdf315050a91e6cace07604_720w.jpg" alt=""></p>
<h2 id="4、Kubernetes-的架构"><a href="#4、Kubernetes-的架构" class="headerlink" title="4、Kubernetes 的架构"></a>4、Kubernetes 的架构</h2><p><img src="https://image.rexking6.top/img/image-20210724234936410.png" alt=""></p>
<p>Kubernetes 由 Master 节点、 Node 节点以及外部的 ETCD 集群组成，集群的状态、资源对象、网络等信息存储在 ETCD 中，Mater 节点管控整个集群，包括通信、调度等，Node 节点为工作真正执行的节点，并向主节点报告。Master 节点由以下组件构成：</p>
<h3 id="1-Master-组件"><a href="#1-Master-组件" class="headerlink" title="1. Master 组件"></a>1. Master 组件</h3><ol>
<li><p>API Server——提供 HTTP Rest 接口，是所有资源增删改查和集群控制的唯一入口。在集群中表现为名称是 kubernetes 的 service。可以通过 Dashboard 的 UI 或 kubectl 工具来与其交互。</p>
<ol>
<li>集群管理的 API 入口；</li>
<li>资源配额控制入口；</li>
<li>提供完备的集群安全机制。</li>
</ol>
</li>
<li><p>Controller Manager——资源对象的控制自动化中心。即监控 Node，当故障时转移资源对象，自动修复集群到期望状态。</p>
</li>
<li><p>Scheduler——负责 Pod 的调度，调度到最优的 Node。</p>
</li>
</ol>
<h3 id="2-Node-组件"><a href="#2-Node-组件" class="headerlink" title="2. Node 组件"></a>2. Node 组件</h3><ol>
<li>kubelet——负责 Pod 内容器的创建、启停，并与 Master 密切协作实现集群管理（注册自己，汇报 Node 状态）。</li>
<li>kube-proxy——实现 k8s Service 的通信与负载均衡。</li>
<li>Docker Engine——Docker 引擎，负责本机容器的创建和管理。</li>
</ol>
<h2 id="5、Kubernetes-架构模块实现原理"><a href="#5、Kubernetes-架构模块实现原理" class="headerlink" title="5、Kubernetes 架构模块实现原理"></a>5、Kubernetes 架构模块实现原理</h2><h3 id="1-API-Server"><a href="#1-API-Server" class="headerlink" title="1. API Server"></a>1. API Server</h3><p>Kubernetes API Server 通过一个名为 kube-apiserver 的进程提供服务，该进程运行在 Master 上。在默认情况下，kube-apiserver 进程在本机的 8080 端口（对应参数—insecure-port）提供 REST 服务。我们可以同时启动 HTTPS 安全端口（—secure-port=6443）来启动安全机制，加强 REST API 访问的安全性。</p>
<p>由于 API Server 是 Kubernetes 集群数据的唯一访问入口，因此安全性与高性能就成为 API Server 设计和实现的两大核心目标。通过采用 HTTPS 安全传输通道与 CA 签名数字证书强制双向认证的方式，API Server 的安全性得以保障。此外，为了更细粒度地控制用户或应用对 Kubernetes 资源对象的访问权限，Kubernetes 启用了 RBAC 访问控制策略。Kubernetes 的设计者综合运用以下方式来最大程度地保证 API Server 的性 能。</p>
<ol>
<li>API Server 拥有大量高性能的底层代码。在 API Server 源码中使用协程（Coroutine）+队列（Queue）这种轻量级的高性能并发代码， 使得单进程的 API Server 具备了超强的多核处理能力，从而以很快的速度并发处理大量的请求。</li>
<li>普通 List 接口结合异步 Watch 接口，不但完美解决了 Kubernetes 中各种资源对象的高性能同步问题，也极大提升了 Kubernetes 集群实时响应各种事件的灵敏度。</li>
<li>采用了高性能的 etcd 数据库而非传统的关系数据库，不仅解决了数据的可靠性问题，也极大提升了 API Server 数据访问层的性能。在 常见的公有云环境中，一个 3 节点的 etcd 集群在轻负载环境中处理一个请 求的时间可以低于 1ms，在重负载环境中可以每秒处理超过 30000 个请求。</li>
</ol>
<h3 id="2-安全认证"><a href="#2-安全认证" class="headerlink" title="2. 安全认证"></a>2. 安全认证</h3><h4 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h4><p>Role-Based Access Control（RBAC），基于角色的访问控制。</p>
<h4 id="4-种资源对象"><a href="#4-种资源对象" class="headerlink" title="4 种资源对象"></a>4 种资源对象</h4><ol>
<li>Role</li>
<li>RoleBinding</li>
<li>ClusterRole</li>
<li>ClusterRoleBinding</li>
</ol>
<h4 id="Role-与-ClusterRole"><a href="#Role-与-ClusterRole" class="headerlink" title="Role 与 ClusterRole"></a>Role 与 ClusterRole</h4><p>一个角色就是一组权限的集合，都是以许可形式，不存在拒绝的规则。Role 作用于一个命名空间中，ClusterRole 作用于整个集群。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: Role</span><br><span class="line">metadata:</span><br><span class="line">  namespace: default #ClusterRole可以省略，毕竟是作用于整个集群</span><br><span class="line">  name: pod-reader</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;pod&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;,&quot;watch&quot;,&quot;list&quot;]</span><br></pre></td></tr></table></figure>
<p>RoleBinding 和 ClusterRoleBinding 是把 Role 和 ClusterRole 的权限绑定到 ServiceAccount 上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kind: ClusterRoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">    namespace: default</span><br><span class="line">    name: app-admin</span><br><span class="line">subjects:</span><br><span class="line">-   kind: ServiceAccount</span><br><span class="line">    name: app</span><br><span class="line">    apiGroup: &quot;&quot;</span><br><span class="line">    namespace: default</span><br><span class="line">roleRef:</span><br><span class="line">    kind: ClusterRole</span><br><span class="line">    name: cluster-admin</span><br><span class="line">    apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure>
<h4 id="ServiceAccount"><a href="#ServiceAccount" class="headerlink" title="ServiceAccount"></a>ServiceAccount</h4><p>Service Account 也是一种账号，但它并不是给 Kubernetes 集群的用户 (系统管理员、运维人员、租户用户等)用的，而是给运行在 Pod 里的进程用的，它为 Pod 里的进程提供了必要的身份证明。在每个 Namespace 下都有一个名为 default 的默认 Service Account 对象，在这个 Service Account 里面有一个名为 Tokens 的可以当作 Volume 被挂载到 Pod 里的 Secret，当 Pod 启动时，这个 Secret 会自动被挂载到 Pod 的指定目录下，用来协助完成 Pod 中的进程访问 API Server 时的身份鉴权。</p>
<h3 id="3-Controller-Manager"><a href="#3-Controller-Manager" class="headerlink" title="3. Controller Manager"></a>3. Controller Manager</h3><p>下边介绍几种 Controller Manager 的实现组件</p>
<h4 id="ResourceQuota-Controller"><a href="#ResourceQuota-Controller" class="headerlink" title="ResourceQuota Controller"></a>ResourceQuota Controller</h4><p>kubernetes 的配额管理使用过 Admission Control 来控制的，提供了两种约束，LimitRanger 和 ResourceQuota。LimitRanger 作用于 Pod 和 Container 之上（limit和request），ResourceQuota 则作用于 Namespace。 资源配额，分三个层次：</p>
<ol>
<li>容器级别，对容器的 CPU、memory 做限制</li>
<li>Pod 级别，对一个 Pod 内所有容器的可用资源做限制</li>
<li>Namespace 级别，为 namespace 做限制，包括：<ul>
<li>pod数量</li>
<li>RC数量</li>
<li>Service数量</li>
<li>ResourceQuota数量</li>
<li>Secrete数量</li>
<li>PV数量</li>
</ul>
</li>
</ol>
<h4 id="Namespace-Controller"><a href="#Namespace-Controller" class="headerlink" title="Namespace Controller"></a>Namespace Controller</h4><p>管理 Namespace 的创建删除.</p>
<h4 id="Endpoints-Controller"><a href="#Endpoints-Controller" class="headerlink" title="Endpoints Controller"></a>Endpoints Controller</h4><p>Endpoints 表示一个 service 对应的所有 Pod 副本的访问地址，而 Endpoints Controller 就是负责生成和维护所有 Endpoints 对象的控制器。</p>
<ul>
<li>负责监听 Service 和对应 Pod 副本的变化，若 Service 被创建、更新、删除，则相应创建、更新、删除与 Service 同名的 Endpoints 对象。</li>
<li>EndPoints 对象被 Node 上的 kube-proxy 使用。</li>
</ul>
<h3 id="4-Scheduler"><a href="#4-Scheduler" class="headerlink" title="4. Scheduler"></a>4. Scheduler</h3><p>Kubernetes Scheduler 的作用是将待调度的 Pod（API 新创建的 Pod、Controller Manager 为补足副本而创建的 Pod 等）按照特定的调度算法和调度策略绑定（Binding）到集群中某个合适的 Node 上，并将绑定信息写入 etcd 中。Kubernetes Scheduler 当前提供的默认调度流程分为以下两步。</p>
<ol>
<li>预选调度过程，即遍历所有目标 Node，筛选出符合要求的候选节点。为此，Kubernetes 内置了多种预选策略（xxx Predicates）供用户选择。</li>
<li>确定最优节点，在第 1 步的基础上，采用优选策略（xxx Priority）计算出每个候选节点的积分，积分最高者胜出。</li>
</ol>
<h3 id="5-网络"><a href="#5-网络" class="headerlink" title="5. 网络"></a>5. 网络</h3><p>Kubernetes 的网络利用了 Docker 的网络原理，并在此基础上实现了跨 Node 容器间的网络通信。</p>
<ol>
<li><p>同一个 Node 下 Pod 间通信模型：</p>
<p><img src="https://image.rexking6.top/img/image-20210724235918835.png" alt=""></p>
</li>
<li><p>不同 Node 下 Pod 间的通信模型（CNI 模型实现）：</p>
<p><img src="https://image.rexking6.top/img/v2-3ab9824b444f4ec4f17b3bdb95017881_720w.jpg" alt=""></p>
<p>CNI 提供了一种应用容器的插件化网络解决方案，定义对容器网络进行操作和配置的规范，通过插件的形式对 CNI 接口进行实现，以 Flannel 举例，完成了 Node 间容器的通信模型。</p>
<p><img src="https://image.rexking6.top/img/image-20210725000027235.png" alt=""></p>
<p>可以看到，Flannel 首先创建了一个名为 flannel0 的网桥，而且这个 网桥的一端连接 docker0 网桥，另一端连接一个叫作 flanneld 的服务进程。flanneld 进程并不简单，它上连 etcd，利用 etcd 来管理可分配的 IP 地 址段资源，同时监控 etcd 中每个 Pod 的实际地址，并在内存中建立了一 个 Pod 节点路由表；它下连 docker0 和物理网络，使用内存中的 Pod 节点 路由表，将 docker0 发给它的数据包包装起来，利用物理网络的连接将 数据包投递到目标 flanneld 上，从而完成 Pod 到 Pod 之间的直接地址通信。</p>
</li>
</ol>
<h3 id="6-服务发现"><a href="#6-服务发现" class="headerlink" title="6. 服务发现"></a>6. 服务发现</h3><p>从 Kubernetes 1.11 版本开始，Kubernetes 集群的 DNS 服务由 CoreDNS 提供。CoreDNS 是 CNCF 基金会的一个项目，是用 Go 语言实现的高性能、插件式、易扩展的 DNS 服务端。</p>
<p><img src="https://image.rexking6.top/img/image-20210725000128301.png" alt=""></p>
<h2 id="6、常用命令"><a href="#6、常用命令" class="headerlink" title="6、常用命令"></a>6、常用命令</h2><p><img src="https://image.rexking6.top/img/18885539-d5d52769d1469bfe.png" alt=""></p>
<h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><ul>
<li><p>create：根据文件或者输入来创建资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建Deployment和Service资源</span><br><span class="line">kubectl create -f javak8s-deployment.yaml</span><br><span class="line">kubectl create -f javak8s-service.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p>delete：删除资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 根据yaml文件删除对应的资源，但是yaml文件并不会被删除，这样更加高效</span><br><span class="line">kubectl delete -f javak8s-deployment.yaml </span><br><span class="line">kubectl delete -f javak8s-service.yaml</span><br><span class="line"># 也可以通过具体的资源名称来进行删除，使用这个删除资源，需要同时删除pod和service资源才行</span><br><span class="line">kubectl delete 具体的资源名称</span><br></pre></td></tr></table></figure>
</li>
<li><p>get：获得资源信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有的资源信息</span></span><br><span class="line">kubectl get all</span><br><span class="line"><span class="comment"># 查看pod列表</span></span><br><span class="line">kubectl get pod</span><br><span class="line"><span class="comment"># 显示pod节点的标签信息</span></span><br><span class="line">kubectl get pod --show-labels</span><br><span class="line"><span class="comment"># 根据指定标签匹配到具体的pod</span></span><br><span class="line">kubectl get pods -l app=example</span><br><span class="line"><span class="comment"># 查看node节点列表</span></span><br><span class="line">kubectl get node </span><br><span class="line"><span class="comment"># 显示node节点的标签信息</span></span><br><span class="line">kubectl get node --show-labels</span><br><span class="line"><span class="comment"># 查看pod详细信息，也就是可以查看pod具体运行在哪个节点上（ip地址信息）</span></span><br><span class="line">kubectl get pod -o wide</span><br><span class="line"><span class="comment"># 查看服务的详细信息，显示了服务名称，类型，集群ip，端口，时间等信息</span></span><br><span class="line">kubectl get svc</span><br><span class="line">NAME            TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">go-service      NodePort    10.10.10.247   &lt;none&gt;        8089:33702/TCP   29m</span><br><span class="line">java-service    NodePort    10.10.10.248   &lt;none&gt;        8082:32823/TCP   5h17m</span><br><span class="line">kubernetes      ClusterIP   10.10.10.1     &lt;none&gt;        443/TCP          5d16h</span><br><span class="line">nginx-service   NodePort    10.10.10.146   &lt;none&gt;        88:34823/TCP     2d19h</span><br><span class="line"><span class="comment"># 查看命名空间</span></span><br><span class="line">kubectl get ns</span><br><span class="line"><span class="comment"># 查看所有pod所属的命名空间</span></span><br><span class="line">kubectl get pod --all-namespaces</span><br><span class="line"><span class="comment"># 查看所有pod所属的命名空间并且查看都在哪些节点上运行</span></span><br><span class="line">kubectl get pod --all-namespaces  -o wide</span><br><span class="line"><span class="comment"># 查看目前所有的replica set，显示了所有的pod的副本数，以及他们的可用数量以及状态等信息</span></span><br><span class="line">kubectl get rs</span><br><span class="line">NAME                          DESIRED   CURRENT   READY   AGE</span><br><span class="line">go-deployment-58c76f7d5c      1         1         1       32m</span><br><span class="line">java-deployment-76889f56c5    1         1         1       5h21m</span><br><span class="line">nginx-deployment-58d6d6ccb8   3         3         3       2d19h</span><br><span class="line"><span class="comment"># 查看目前所有的deployment</span></span><br><span class="line">kubectl get deployment</span><br><span class="line">NAME               READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">go-deployment      1/1     1            1           34m</span><br><span class="line">java-deployment    1/1     1            1           5h23m</span><br><span class="line">nginx-deployment   3/3     3            3           2d19h</span><br><span class="line"><span class="comment"># 查看已经部署了的所有应用，可以看到容器，以及容器所用的镜像，标签等信息</span></span><br><span class="line">kubectl get deploy -o wide</span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES       SELECTOR</span><br><span class="line">nginx   3/3     3            3           16m   nginx        nginx:1.10   app=example</span><br></pre></td></tr></table></figure>
</li>
<li><p>run：在集群中创建并运行一个或多个容器镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">kubectl run NAME --image=image [--env=<span class="string">&quot;key=value&quot;</span>] [--port=port] [--replicas=replicas] [--dry-run=bool] [--overrides=inline-json] [--<span class="built_in">command</span>] -- [COMMAND] [args...]</span><br><span class="line"><span class="comment"># 示例，运行一个名称为nginx，副本数为3，标签为app=example，镜像为nginx:1.10，端口为80的容器实例</span></span><br><span class="line">kubectl run nginx --replicas=3 --labels=<span class="string">&quot;app=example&quot;</span> --image=nginx:1.10 --port=80</span><br></pre></td></tr></table></figure>
<p>其他用法参见：<a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/468.html">http://docs.kubernetes.org.cn/468.html</a></p>
</li>
<li><p>expose：创建一个service服务，并且暴露端口让外部可以访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个nginx服务并且暴露端口让外界可以访问</span><br><span class="line">kubectl expose deployment nginx --port=88 --type=NodePort --target-port=80 --name=nginx-service</span><br></pre></td></tr></table></figure>
<p>关于expose的详细用法参见：<a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/475.html">http://docs.kubernetes.org.cn/475.html</a></p>
</li>
<li><p>set： 配置应用的一些特定资源，也可以修改应用已有的资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 使用kubectl set --help查看，它的子命令，env，image，resources，selector，serviceaccount，subject。</span><br></pre></td></tr></table></figure>
<p>set命令详情参见：<a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/669.html">http://docs.kubernetes.org.cn/669.html</a></p>
<ul>
<li><p>kubectl set resources</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resources (-f FILENAME | TYPE NAME) ([--limits=LIMITS &amp; --requests=REQUESTS]</span><br></pre></td></tr></table></figure>
<p>这个命令用于设置资源的一些范围限制。</p>
<p>资源对象中的Pod可以指定计算资源需求（CPU-单位m、内存-单位Mi），即使用的最小资源请求（Requests），限制（Limits）的最大资源需求，Pod将保证使用在设置的资源数量范围。</p>
<p>对于每个Pod资源，如果指定了Limits（限制）值，并省略了Requests（请求），则Requests默认为Limits的值。</p>
<p>可用资源对象包括（支持大小写）：replicationcontroller、deployment、daemonset、job、replicaset。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将deployment的nginx容器cpu限制为“200m”，将内存设置为“512Mi”</span></span><br><span class="line">kubectl <span class="built_in">set</span> resources deployment nginx -c=nginx --limits=cpu=200m,memory=512Mi</span><br><span class="line"><span class="comment"># 为nginx中的所有容器设置 Requests和Limits</span></span><br><span class="line">kubectl <span class="built_in">set</span> resources deployment nginx --limits=cpu=200m,memory=512Mi --requests=cpu=100m,memory=256Mi</span><br><span class="line"><span class="comment"># 删除nginx中容器的计算资源值</span></span><br><span class="line">kubectl <span class="built_in">set</span> resources deployment nginx --limits=cpu=0,memory=0 --requests=cpu=0,memory=0</span><br></pre></td></tr></table></figure>
</li>
<li><p>kubectl set selector</p>
<p>设置资源的selector（选择器）。如果在调用”set selector”命令之前已经存在选择器，则新创建的选择器将覆盖原来的选择器。</p>
<p>selector必须以字母或数字开头，最多包含63个字符，可使用：字母、数字、连字符” - “ 、点”.”和下划线” _ “。如果指定了—resource-version，则更新将使用此资源版本，否则将使用现有的资源版本。</p>
<p>注意：目前selector命令只能用于Service对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl set selector (-f FILENAME | TYPE NAME) EXPRESSIONS [--resource-version=version]</span><br></pre></td></tr></table></figure>
</li>
<li><p>kubectl set image命令</p>
<p> 用于更新现有资源的容器镜像。</p>
<p>可用资源对象包括：pod (po)、replicationcontroller (rc)、deployment (deploy)、daemonset (ds)、job、replicaset (rs)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line">kubectl <span class="built_in">set</span> image (-f FILENAME | TYPE NAME) CONTAINER_NAME_1=CONTAINER_IMAGE_1 ... CONTAINER_NAME_N=CONTAINER_IMAGE_N</span><br><span class="line"><span class="comment"># 将deployment中的nginx容器镜像设置为“nginx：1.9.1”。</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployment/nginx busybox=busybox nginx=nginx:1.9.1</span><br><span class="line"><span class="comment"># 所有deployment和rc的nginx容器镜像更新为“nginx：1.9.1”</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployments,rc nginx=nginx:1.9.1 --all</span><br><span class="line"><span class="comment"># 将daemonset abc的所有容器镜像更新为“nginx：1.9.1”</span></span><br><span class="line">kubectl <span class="built_in">set</span> image daemonset abc *=nginx:1.9.1</span><br><span class="line"><span class="comment"># 从本地文件中更新nginx容器镜像</span></span><br><span class="line">kubectl <span class="built_in">set</span> image -f path/to/file.yaml nginx=nginx:1.9.1 --<span class="built_in">local</span> -o yaml</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>explain：用于显示资源文档信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl explain rs</span><br></pre></td></tr></table></figure>
</li>
<li><p>edit：用于编辑资源信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 编辑Deployment nginx的一些信息</span><br><span class="line">kubectl edit deployment nginx</span><br><span class="line"># 编辑service类型的nginx的一些信息</span><br><span class="line">kubectl edit service/nginx</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="设置命令"><a href="#设置命令" class="headerlink" title="设置命令"></a>设置命令</h3><ul>
<li><p>label：用于更新（增加、修改或删除）资源上的 label（标签）</p>
<ul>
<li>label 必须以字母或数字开头，可以使用字母、数字、连字符、点和下划线，最长63个字符。</li>
<li>如果—overwrite 为 true，则可以覆盖已有的 label，否则尝试覆盖 label 将会报错。</li>
<li>如果指定了—resource-version，则更新将使用此资源版本，否则将使用现有的资源版本。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">kubectl label [--overwrite] (-f FILENAME | TYPE NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--resource-version=version]</span><br><span class="line"># 给名为foo的Pod添加label unhealthy=true</span><br><span class="line">kubectl label pods foo unhealthy=true</span><br><span class="line"># 给名为foo的Pod修改label 为 &#x27;status&#x27; / value &#x27;unhealthy&#x27;，且覆盖现有的value</span><br><span class="line">kubectl label --overwrite pods foo status=unhealthy</span><br><span class="line"># 给 namespace 中的所有 pod 添加 label</span><br><span class="line">kubectl label  pods --all status=unhealthy</span><br><span class="line"># 仅当resource-version=1时才更新 名为foo的Pod上的label</span><br><span class="line">kubectl label pods foo status=unhealthy --resource-version=1</span><br><span class="line"># 删除名为“bar”的label 。（使用“ - ”减号相连）</span><br><span class="line">kubectl label pods foo bar-</span><br></pre></td></tr></table></figure>
</li>
<li><p>annotate：更新一个或多个资源的Annotations信息。也就是注解信息，可以方便的查看做了哪些操作。</p>
<ul>
<li>Annotations由key/value组成。</li>
<li>Annotations的目的是存储辅助数据，特别是通过工具和系统扩展操作的数据，更多介绍在<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fdocs.kubernetes.org.cn%2F255.html">这里</a>。</li>
<li>如果—overwrite为true，现有的annotations可以被覆盖，否则试图覆盖annotations将会报错。</li>
<li>如果设置了—resource-version，则更新将使用此resource version，否则将使用原有的resource version。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line">kubectl annotate [--overwrite] (-f FILENAME | TYPE NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--resource-version=version]</span><br><span class="line"><span class="comment"># 更新Pod“foo”，设置annotation “description”的value “my frontend”，如果同一个annotation多次设置，则只使用最后设置的value值</span></span><br><span class="line">kubectl annotate pods foo description=<span class="string">&#x27;my frontend&#x27;</span></span><br><span class="line"><span class="comment"># 根据“pod.json”中的type和name更新pod的annotation</span></span><br><span class="line">kubectl annotate -f pod.json description=<span class="string">&#x27;my frontend&#x27;</span></span><br><span class="line"><span class="comment"># 更新Pod&quot;foo&quot;，设置annotation“description”的value“my frontend running nginx”，覆盖现有的值</span></span><br><span class="line">kubectl annotate --overwrite pods foo description=<span class="string">&#x27;my frontend running nginx&#x27;</span></span><br><span class="line"><span class="comment"># 更新 namespace中的所有pod</span></span><br><span class="line">kubectl annotate pods --all description=<span class="string">&#x27;my frontend running nginx&#x27;</span></span><br><span class="line"><span class="comment"># 只有当resource-version为1时，才更新pod &#x27; foo &#x27;</span></span><br><span class="line">kubectl annotate pods foo description=<span class="string">&#x27;my frontend running nginx&#x27;</span> --resource-version=1</span><br><span class="line"><span class="comment"># 通过删除名为“description”的annotations来更新pod &#x27; foo &#x27;。#不需要- overwrite flag。</span></span><br><span class="line">kubectl annotate pods foo description-</span><br></pre></td></tr></table></figure>
</li>
<li><p>completion：用于设置kubectl命令自动补全</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> &lt;(kubectl completion bash) <span class="comment"># setup autocomplete in bash, bash-completion package should be installed first.</span></span><br><span class="line">$ <span class="built_in">source</span> &lt;(kubectl completion zsh)  <span class="comment"># setup autocomplete in zsh</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="部署命令"><a href="#部署命令" class="headerlink" title="部署命令"></a>部署命令</h3><ul>
<li><p>rollout：用于对资源进行管理</p>
<p>可用资源包括：deployments，daemonsets。</p>
<p>子命令：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fdocs.kubernetes.org.cn%2F645.html">history</a>（查看历史版本）</li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fdocs.kubernetes.org.cn%2F647.html">pause</a>（暂停资源）</li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fdocs.kubernetes.org.cn%2F650.html">resume</a>（恢复暂停资源）</li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fdocs.kubernetes.org.cn%2F652.html">status</a>（查看资源状态）</li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fdocs.kubernetes.org.cn%2F654.html">undo</a>（回滚版本）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">kubectl rollout SUBCOMMAND</span><br><span class="line"># 回滚到之前的deployment</span><br><span class="line">kubectl rollout undo deployment/abc</span><br><span class="line"># 查看daemonet的状态</span><br><span class="line">kubectl rollout status daemonset/foo</span><br></pre></td></tr></table></figure>
</li>
<li><p>rolling-update：执行指定ReplicationController的滚动更新。</p>
<p>该命令创建了一个新的RC， 然后一次更新一个pod方式逐步使用新的PodTemplate，最终实现Pod滚动更新，new-controller.json需要与之前RC在相同的namespace下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line">kubectl rolling-update OLD_CONTROLLER_NAME ([NEW_CONTROLLER_NAME] --image=NEW_CONTAINER_IMAGE | -f NEW_CONTROLLER_SPEC)</span><br><span class="line"><span class="comment"># 使用frontend-v2.json中的新RC数据更新frontend-v1的pod</span></span><br><span class="line">kubectl rolling-update frontend-v1 -f frontend-v2.json</span><br><span class="line"><span class="comment"># 使用JSON数据更新frontend-v1的pod</span></span><br><span class="line">cat frontend-v2.json | kubectl rolling-update frontend-v1 -f -</span><br><span class="line"><span class="comment"># 其他的一些滚动更新</span></span><br><span class="line">kubectl rolling-update frontend-v1 frontend-v2 --image=image:v2</span><br><span class="line">kubectl rolling-update frontend --image=image:v2</span><br><span class="line">kubectl rolling-update frontend-v1 frontend-v2 --rollback</span><br></pre></td></tr></table></figure>
</li>
<li><p>scale：扩容或缩容 Deployment、ReplicaSet、Replication Controller或 Job 中Pod数量</p>
<p>scale也可以指定多个前提条件，如：当前副本数量或 —resource-version ，进行伸缩比例设置前，系统会先验证前提条件是否成立。这个就是弹性伸缩策略</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line">kubectl scale [--resource-version=version] [--current-replicas=count] --replicas=COUNT (-f FILENAME | TYPE NAME)</span><br><span class="line"><span class="comment"># 将名为foo中的pod副本数设置为3。</span></span><br><span class="line">kubectl scale --replicas=3 rs/foo</span><br><span class="line">kubectl scale deploy/nginx --replicas=30</span><br><span class="line"><span class="comment"># 将由“foo.yaml”配置文件中指定的资源对象和名称标识的Pod资源副本设为3</span></span><br><span class="line">kubectl scale --replicas=3 -f foo.yaml</span><br><span class="line"><span class="comment"># 如果当前副本数为2，则将其扩展至3。</span></span><br><span class="line">kubectl scale --current-replicas=2 --replicas=3 deployment/mysql</span><br><span class="line"><span class="comment"># 设置多个RC中Pod副本数量</span></span><br><span class="line">kubectl scale --replicas=5 rc/foo rc/bar rc/baz</span><br></pre></td></tr></table></figure>
</li>
<li><p>autoscale： 这个比scale更加强大，也是弹性伸缩策略 ，它是根据流量的多少来自动进行扩展或者缩容</p>
<p>指定Deployment、ReplicaSet或ReplicationController，并创建已经定义好资源的自动伸缩器。使用自动伸缩器可以根据需要自动增加或减少系统中部署的pod数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">kubectl autoscale (-f FILENAME | TYPE NAME | TYPE/NAME) [--min=MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags]</span><br><span class="line"># 使用 Deployment “foo”设定，使用默认的自动伸缩策略，指定目标CPU使用率，使其Pod数量在2到10之间</span><br><span class="line">kubectl autoscale deployment foo --min=2 --max=10</span><br><span class="line"># 使用RC“foo”设定，使其Pod的数量介于1和5之间，CPU使用率维持在80％</span><br><span class="line">kubectl autoscale rc foo --max=5 --cpu-percent=80</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="集群管理命令"><a href="#集群管理命令" class="headerlink" title="集群管理命令"></a>集群管理命令</h3><ul>
<li><p>certificate：用于证书资源管理，授权等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kubectl certificate --help</span><br><span class="line">Modify certificate resources.</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  approve     Approve a certificate signing request</span><br><span class="line">  deny        Deny a certificate signing request</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  kubectl certificate SUBCOMMAND [options]</span><br><span class="line"></span><br><span class="line">Use &quot;kubectl &lt;command&gt; --help&quot; for more information about a given command.</span><br><span class="line">Use &quot;kubectl options&quot; for a list of global command-line options (applies to all commands).</span><br><span class="line"></span><br><span class="line"># 例如，当有node节点要向master请求，那么是需要master节点授权的</span><br><span class="line">kubectl  certificate approve node-csr-81F5uBehyEyLWco5qavBsxc1GzFcZk3aFM3XW5rT3mw node-csr-Ed0kbFhc_q7qx14H3QpqLIUs0uKo036O2SnFpIheM18</span><br></pre></td></tr></table></figure>
</li>
<li><p>cluster-info：显示集群信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl cluster-info</span><br><span class="line">Kubernetes master is running at http://localhost:8080</span><br><span class="line">To further debug and diagnose cluster problems, use &#x27;kubectl cluster-info dump&#x27;.</span><br></pre></td></tr></table></figure>
</li>
<li><p>top：用于查看资源的cpu，内存磁盘等资源的使用率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl top pod --all-namespaces</span><br></pre></td></tr></table></figure>
<p>它需要heapster运行才行。</p>
</li>
<li><p>cordon：用于标记某个节点不可调度</p>
</li>
<li><p>uncordon：用于标签节点可以调度</p>
</li>
<li><p>drain： 用于在维护期间排除节点。</p>
</li>
<li><p>taint：参见：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.frognew.com%2F2018%2F05%2Ftaint-and-toleration.html">https://blog.frognew.com/2018/05/taint-and-toleration.html</a></p>
</li>
</ul>
<h3 id="故障诊断和调试命令"><a href="#故障诊断和调试命令" class="headerlink" title="故障诊断和调试命令"></a>故障诊断和调试命令</h3><ul>
<li><p>describe：显示特定资源的详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">kubectl describe TYPE NAME_PREFIX</span><br><span class="line">（首先检查是否有精确匹配TYPE和NAME_PREFIX的资源，如果没有，将会输出所有名称以NAME_PREFIX开头的资源详细信息）</span><br><span class="line">支持的资源包括但不限于（大小写不限）：pods (po)、services (svc)、 replicationcontrollers (rc)、nodes (no)、events (ev)、componentstatuses (cs)、 limitranges (limits)、persistentvolumes (pv)、persistentvolumeclaims (pvc)、 resourcequotas (quota)和secrets。</span><br><span class="line">#查看my-nginx pod的详细状态</span><br><span class="line">kubectl describe po my-nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>logs：用于在一个pod中打印一个容器的日志，如果pod中只有一个容器，可以省略容器名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">kubectl logs [-f] [-p] POD [-c CONTAINER]</span><br><span class="line"># 返回仅包含一个容器的pod nginx的日志快照</span><br><span class="line">$ kubectl logs nginx</span><br><span class="line"># 返回pod ruby中已经停止的容器web-1的日志快照</span><br><span class="line">$ kubectl logs -p -c ruby web-1</span><br><span class="line"># 持续输出pod ruby中的容器web-1的日志</span><br><span class="line">$ kubectl logs -f -c ruby web-1</span><br><span class="line"># 仅输出pod nginx中最近的20条日志</span><br><span class="line">$ kubectl logs --tail=20 nginx</span><br><span class="line"># 输出pod nginx中最近一小时内产生的所有日志</span><br><span class="line">$ kubectl logs --since=1h nginx</span><br><span class="line"># 参数选项</span><br><span class="line">  -c, --container=&quot;&quot;: 容器名。</span><br><span class="line">  -f, --follow[=false]: 指定是否持续输出日志（实时日志）。</span><br><span class="line">      --interactive[=true]: 如果为true，当需要时提示用户进行输入。默认为true。</span><br><span class="line">      --limit-bytes=0: 输出日志的最大字节数。默认无限制。</span><br><span class="line">  -p, --previous[=false]: 如果为true，输出pod中曾经运行过，但目前已终止的容器的日志。</span><br><span class="line">      --since=0: 仅返回相对时间范围，如5s、2m或3h，之内的日志。默认返回所有日志。只能同时使用since和since-time中的一种。</span><br><span class="line">      --since-time=&quot;&quot;: 仅返回指定时间（RFC3339格式）之后的日志。默认返回所有日志。只能同时使用since和since-time中的一种。</span><br><span class="line">      --tail=-1: 要显示的最新的日志条数。默认为-1，显示所有的日志。</span><br><span class="line">      --timestamps[=false]: 在日志中包含时间戳。</span><br></pre></td></tr></table></figure>
</li>
<li><p>exec：进入容器进行交互，在容器中执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">kubectl exec POD [-c CONTAINER] -- COMMAND [args...]</span><br><span class="line">#命令选项</span><br><span class="line">  -c, --container=&quot;&quot;: 容器名。如果未指定，使用pod中的一个容器。</span><br><span class="line">  -p, --pod=&quot;&quot;: Pod名。</span><br><span class="line">  -i, --stdin[=false]: 将控制台输入发送到容器。</span><br><span class="line">  -t, --tty[=false]: 将标准输入控制台作为容器的控制台输入。</span><br><span class="line"># 进入nginx容器，执行一些命令操作</span><br><span class="line">kubectl exec -it nginx-deployment-58d6d6ccb8-lc5fp bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>attach：连接到一个正在运行的容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#语法</span><br><span class="line">kubectl attach POD -c CONTAINER</span><br><span class="line"># 参数选项</span><br><span class="line">-c, --container=&quot;&quot;: 容器名。如果省略，则默认选择第一个 pod</span><br><span class="line">  -i, --stdin[=false]: 将控制台输入发送到容器。</span><br><span class="line">  -t, --tty[=false]: 将标准输入控制台作为容器的控制台输入。</span><br><span class="line"></span><br><span class="line"># 获取正在运行中的pod 123456-7890的输出，默认连接到第一个容器</span><br><span class="line">kubectl attach 123456-7890</span><br><span class="line"># 获取pod 123456-7890中ruby-container的输出</span><br><span class="line">kubectl attach 123456-7890 -c ruby-container</span><br><span class="line"># 切换到终端模式，将控制台输入发送到pod 123456-7890的ruby-container的“bash”命令，并将其输出到控制台/</span><br><span class="line"># 错误控制台的信息发送回客户端。</span><br><span class="line">kubectl attach 123456-7890 -c ruby-container -i -t</span><br></pre></td></tr></table></figure>
</li>
<li><p>cp：拷贝文件或者目录到pod容器中</p>
<p>用于pod和外部的文件交换，类似于docker 的cp，就是将容器中的内容和外部的内容进行交换。</p>
</li>
</ul>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ul>
<li><p>api-servions：打印受支持的api版本信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">kubectl api-versions</span><br><span class="line">admissionregistration.k8s.io/v1beta1</span><br><span class="line">apiextensions.k8s.io/v1beta1</span><br><span class="line">apiregistration.k8s.io/v1beta1</span><br><span class="line">apps/v1</span><br><span class="line">apps/v1beta1</span><br><span class="line">apps/v1beta2</span><br><span class="line">authentication.k8s.io/v1</span><br><span class="line">authentication.k8s.io/v1beta1</span><br><span class="line">authorization.k8s.io/v1</span><br><span class="line">authorization.k8s.io/v1beta1</span><br><span class="line">autoscaling/v1</span><br><span class="line">autoscaling/v2beta1</span><br><span class="line">batch/v1</span><br><span class="line">batch/v1beta1</span><br><span class="line">certificates.k8s.io/v1beta1</span><br><span class="line">events.k8s.io/v1beta1</span><br><span class="line">extensions/v1beta1</span><br><span class="line">networking.k8s.io/v1</span><br><span class="line">policy/v1beta1</span><br><span class="line">rbac.authorization.k8s.io/v1</span><br><span class="line">rbac.authorization.k8s.io/v1beta1</span><br><span class="line">storage.k8s.io/v1</span><br><span class="line">storage.k8s.io/v1beta1</span><br><span class="line">v1</span><br></pre></td></tr></table></figure>
</li>
<li><p>help：用于查看命令帮助</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 显示全部的命令帮助提示</span><br><span class="line">kubectl --help</span><br><span class="line"># 具体的子命令帮助，例如</span><br><span class="line">kubectl create --help</span><br></pre></td></tr></table></figure>
</li>
<li><p>config：用于修改kubeconfig配置文件（用于访问api，例如配置认证信息）</p>
</li>
<li><p>version：打印客户端和服务端版本信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl version</span><br><span class="line">Client Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;15&quot;, GitVersion:&quot;v1.15.3&quot;, GitCommit:&quot;2d3c76f9091b6bec110a5e63777c332469e0cba2&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2019-08-19T11:13:54Z&quot;, GoVersion:&quot;go1.12.9&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br><span class="line">Server Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;9&quot;, GitVersion:&quot;v1.9.0&quot;, GitCommit:&quot;925c127ec6b946659ad0fd596fa959be43f0cc05&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2017-12-15T20:55:30Z&quot;, GoVersion:&quot;go1.9.2&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>plugin：运行一个命令行插件</p>
</li>
</ul>
<h3 id="高级命令"><a href="#高级命令" class="headerlink" title="高级命令"></a>高级命令</h3><ul>
<li><p>apply： 通过文件名或者标准输入对资源应用配置</p>
<p>通过文件名或控制台输入，对资源进行配置。 如果资源不存在，将会新建一个。可以使用 JSON 或者 YAML 格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">kubectl apply -f FILENAME</span><br><span class="line"></span><br><span class="line"># 将pod.json中的配置应用到pod</span><br><span class="line">kubectl apply -f ./pod.json</span><br><span class="line"># 将控制台输入的JSON配置应用到Pod</span><br><span class="line">cat pod.json | kubectl apply -f -</span><br><span class="line"></span><br><span class="line">选项</span><br><span class="line">-f, --filename=[]: 包含配置信息的文件名，目录名或者URL。</span><br><span class="line">      --include-extended-apis[=true]: If true, include definitions of new APIs via calls to the API server. [default true]</span><br><span class="line">  -o, --output=&quot;&quot;: 输出模式。&quot;-o name&quot;为快捷输出(资源/name).</span><br><span class="line">      --record[=false]: 在资源注释中记录当前 kubectl 命令。</span><br><span class="line">  -R, --recursive[=false]: Process the directory used in -f, --filename recursively. Useful when you want to manage related manifests organized within the same directory.</span><br><span class="line">      --schema-cache-dir=&quot;~/.kube/schema&quot;: 非空则将API schema缓存为指定文件，默认缓存到&#x27;$HOME/.kube/schema&#x27;</span><br><span class="line">      --validate[=true]: 如果为true，在发送到服务端前先使用schema来验证输入。</span><br></pre></td></tr></table></figure>
</li>
<li><p>patch： 使用补丁修改，更新资源的字段，也就是修改资源的部分内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">kubectl patch (-f FILENAME | TYPE NAME) -p PATCH</span><br><span class="line"></span><br><span class="line"># Partially update a node using strategic merge patch</span><br><span class="line">kubectl patch node k8s-node-1 -p &#x27;&#123;&quot;spec&quot;:&#123;&quot;unschedulable&quot;:true&#125;&#125;&#x27;</span><br><span class="line"># Update a container&#x27;s image; spec.containers[*].name is required because it&#x27;s a merge key</span><br><span class="line">kubectl patch pod valid-pod -p &#x27;&#123;&quot;spec&quot;:&#123;&quot;containers&quot;:[&#123;&quot;name&quot;:&quot;kubernetes-serve-hostname&quot;,&quot;image&quot;:&quot;new image&quot;&#125;]&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>replace： 通过文件或者标准输入替换原有资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">kubectl replace -f FILENAME</span><br><span class="line"></span><br><span class="line"># Replace a pod using the data in pod.json.</span><br><span class="line">kubectl replace -f ./pod.json</span><br><span class="line"># Replace a pod based on the JSON passed into stdin.</span><br><span class="line">cat pod.json | kubectl replace -f -</span><br><span class="line"># Update a single-container pod&#x27;s image version (tag) to v4</span><br><span class="line">kubectl get pod mypod -o yaml | sed &#x27;s/\(image: myimage\):.*$/\1:v4/&#x27; | kubectl replace -f -</span><br><span class="line"># Force replace, delete and then re-create the resource</span><br><span class="line">kubectl replace --force -f ./pod.json</span><br></pre></td></tr></table></figure>
</li>
<li><p>convert： 不同的版本之间转换配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">kubectl convert -f FILENAME</span><br><span class="line"></span><br><span class="line"># Convert &#x27;pod.yaml&#x27; to latest version and print to stdout.</span><br><span class="line">kubectl convert -f pod.yaml</span><br><span class="line"># Convert the live state of the resource specified by &#x27;pod.yaml&#x27; to the latest version</span><br><span class="line"># and print to stdout in json format.</span><br><span class="line">kubectl convert -f pod.yaml --local -o json</span><br><span class="line"># Convert all files under current directory to latest version and create them all.</span><br><span class="line">kubectl convert -f . | kubectl create -f -</span><br></pre></td></tr></table></figure>
</li>
</ul>

    </div>

    
    
    
      

        <div class="reward-container">
  <div>一分一毛，也是心意。</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Run-Qing Chen 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Run-Qing Chen 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Run-Qing Chen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://blog.rexking6.top/2021/07/24/Docker-k8s/" title="Docker &amp; k8s">https://blog.rexking6.top/2021/07/24/Docker-k8s/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Docker/" rel="tag"># Docker</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/20/Transformer/" rel="prev" title="Transformer">
      <i class="fa fa-chevron-left"></i> Transformer
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/25/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="next" title="图数据库">
      图数据库 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

    <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#On-Premises%E3%80%81IaaS%E3%80%81PaaS%E3%80%81SaaS%E4%B8%8EServerless"><span class="nav-number">2.</span> <span class="nav-text">On-Premises、IaaS、PaaS、SaaS与Serverless</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%91%E5%8E%9F%E7%94%9F"><span class="nav-number">2.1.</span> <span class="nav-text">云原生</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker"><span class="nav-number">3.</span> <span class="nav-text">Docker</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDocker"><span class="nav-number">3.1.</span> <span class="nav-text">什么是Docker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker%E6%9E%B6%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">Docker架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker%E5%AE%89%E8%A3%85"><span class="nav-number">3.3.</span> <span class="nav-text">Docker安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">3.4.</span> <span class="nav-text">容器使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">3.4.1.</span> <span class="nav-text">Docker 客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F"><span class="nav-number">3.4.2.</span> <span class="nav-text">获取镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-Hello-World"><span class="nav-number">3.4.3.</span> <span class="nav-text">Docker Hello World</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">3.4.4.</span> <span class="nav-text">启动容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="nav-number">3.4.5.</span> <span class="nav-text">后台运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8"><span class="nav-number">3.4.6.</span> <span class="nav-text">停止一个容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="nav-number">3.4.7.</span> <span class="nav-text">进入容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="nav-number">3.4.8.</span> <span class="nav-text">导出容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="nav-number">3.4.9.</span> <span class="nav-text">导入容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="nav-number">3.4.10.</span> <span class="nav-text">删除容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA-web-%E5%BA%94%E7%94%A8"><span class="nav-number">3.4.11.</span> <span class="nav-text">运行一个 web 应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8Bweb%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">3.4.12.</span> <span class="nav-text">查看web应用容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F"><span class="nav-number">3.4.13.</span> <span class="nav-text">网络端口的快捷方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8Bweb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%97%A5%E5%BF%97"><span class="nav-number">3.4.14.</span> <span class="nav-text">查看web应用程序日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8Bweb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.4.15.</span> <span class="nav-text">查看web应用程序容器的进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.4.16.</span> <span class="nav-text">检查web应用程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4web%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">3.4.17.</span> <span class="nav-text">移除web应用容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8"><span class="nav-number">3.5.</span> <span class="nav-text">镜像使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E5%87%BA%E9%95%9C%E5%83%8F%E5%88%97%E8%A1%A8"><span class="nav-number">3.5.1.</span> <span class="nav-text">列出镜像列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B0%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-number">3.5.2.</span> <span class="nav-text">获取新的镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E9%95%9C%E5%83%8F"><span class="nav-number">3.5.3.</span> <span class="nav-text">查找镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="nav-number">3.5.4.</span> <span class="nav-text">删除镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="nav-number">3.5.5.</span> <span class="nav-text">创建镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E9%95%9C%E5%83%8F"><span class="nav-number">3.5.6.</span> <span class="nav-text">更新镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="nav-number">3.5.7.</span> <span class="nav-text">构建镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E9%95%9C%E5%83%8F%E6%A0%87%E7%AD%BE"><span class="nav-number">3.5.8.</span> <span class="nav-text">设置镜像标签</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.6.</span> <span class="nav-text">容器连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84"><span class="nav-number">3.6.1.</span> <span class="nav-text">网络端口映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94"><span class="nav-number">3.6.2.</span> <span class="nav-text">容器互联</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%91%BD%E5%90%8D"><span class="nav-number">3.6.2.1.</span> <span class="nav-text">容器命名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">3.6.2.2.</span> <span class="nav-text">新建网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%AE%B9%E5%99%A8"><span class="nav-number">3.6.2.3.</span> <span class="nav-text">连接容器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE-DNS"><span class="nav-number">3.6.3.</span> <span class="nav-text">配置 DNS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%8C%87%E5%AE%9A%E5%AE%B9%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">3.6.3.1.</span> <span class="nav-text">手动指定容器的配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86"><span class="nav-number">3.7.</span> <span class="nav-text">仓库管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-Hub"><span class="nav-number">3.7.1.</span> <span class="nav-text">Docker Hub</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C"><span class="nav-number">3.7.2.</span> <span class="nav-text">注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%99%BB%E5%BD%95"><span class="nav-number">3.7.3.</span> <span class="nav-text">登录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%80%E5%87%BA"><span class="nav-number">3.7.4.</span> <span class="nav-text">退出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="nav-number">3.7.5.</span> <span class="nav-text">拉取镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F"><span class="nav-number">3.7.6.</span> <span class="nav-text">推送镜像</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dockerfile"><span class="nav-number">3.8.</span> <span class="nav-text">Dockerfile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDockerfile%EF%BC%9F"><span class="nav-number">3.8.1.</span> <span class="nav-text">什么是Dockerfile？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Dockerfile%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F"><span class="nav-number">3.8.2.</span> <span class="nav-text">使用Dockerfile定制镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="nav-number">3.8.3.</span> <span class="nav-text">开始构建镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B7%AF%E5%BE%84"><span class="nav-number">3.8.4.</span> <span class="nav-text">上下文路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.8.5.</span> <span class="nav-text">指令详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#COPY"><span class="nav-number">3.8.5.1.</span> <span class="nav-text">COPY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ADD"><span class="nav-number">3.8.5.2.</span> <span class="nav-text">ADD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMD"><span class="nav-number">3.8.5.3.</span> <span class="nav-text">CMD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ENTRYPOINT"><span class="nav-number">3.8.5.4.</span> <span class="nav-text">ENTRYPOINT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ENV"><span class="nav-number">3.8.5.5.</span> <span class="nav-text">ENV</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ARG"><span class="nav-number">3.8.5.6.</span> <span class="nav-text">ARG</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VOLUME"><span class="nav-number">3.8.5.7.</span> <span class="nav-text">VOLUME</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EXPOSE"><span class="nav-number">3.8.5.8.</span> <span class="nav-text">EXPOSE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WORKDIR"><span class="nav-number">3.8.5.9.</span> <span class="nav-text">WORKDIR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#USER"><span class="nav-number">3.8.5.10.</span> <span class="nav-text">USER</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HEALTHCHECK"><span class="nav-number">3.8.5.11.</span> <span class="nav-text">HEALTHCHECK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ONBUILD"><span class="nav-number">3.8.5.12.</span> <span class="nav-text">ONBUILD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LABEL"><span class="nav-number">3.8.5.13.</span> <span class="nav-text">LABEL</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.9.</span> <span class="nav-text">实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Namespace"><span class="nav-number">3.9.1.</span> <span class="nav-text">1、Namespace</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-number">3.9.1.1.</span> <span class="nav-text">网络</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Control-Groups%EF%BC%88CGroups%EF%BC%89"><span class="nav-number">3.9.2.</span> <span class="nav-text">2、Control Groups（CGroups）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81UnionFS"><span class="nav-number">3.9.3.</span> <span class="nav-text">3、UnionFS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-Compose"><span class="nav-number">3.10.</span> <span class="nav-text">Docker Compose</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Compose%E7%AE%80%E4%BB%8B"><span class="nav-number">3.10.1.</span> <span class="nav-text">Compose简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Compose-%E5%AE%89%E8%A3%85"><span class="nav-number">3.10.2.</span> <span class="nav-text">Compose 安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">3.10.3.</span> <span class="nav-text">使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%87%86%E5%A4%87"><span class="nav-number">3.10.3.1.</span> <span class="nav-text">1、准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%88%9B%E5%BB%BA-Dockerfile-%E6%96%87%E4%BB%B6"><span class="nav-number">3.10.3.2.</span> <span class="nav-text">2、创建 Dockerfile 文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%88%9B%E5%BB%BA-docker-compose-yml"><span class="nav-number">3.10.3.3.</span> <span class="nav-text">3、创建 docker-compose.yml</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E4%BD%BF%E7%94%A8-Compose-%E5%91%BD%E4%BB%A4%E6%9E%84%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%82%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">3.10.3.4.</span> <span class="nav-text">4、使用 Compose 命令构建和运行您的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#yml-%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E5%8F%82%E8%80%83"><span class="nav-number">3.10.4.</span> <span class="nav-text">yml 配置指令参考</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#version"><span class="nav-number">3.10.4.1.</span> <span class="nav-text">version</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#build"><span class="nav-number">3.10.4.2.</span> <span class="nav-text">build</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cap-add%EF%BC%8Ccap-drop"><span class="nav-number">3.10.4.3.</span> <span class="nav-text">cap_add，cap_drop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cgroup-parent"><span class="nav-number">3.10.4.4.</span> <span class="nav-text">cgroup_parent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#command"><span class="nav-number">3.10.4.5.</span> <span class="nav-text">command</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#container-name"><span class="nav-number">3.10.4.6.</span> <span class="nav-text">container_name</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#depends-on"><span class="nav-number">3.10.4.7.</span> <span class="nav-text">depends_on</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deploy"><span class="nav-number">3.10.4.8.</span> <span class="nav-text">deploy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#devices"><span class="nav-number">3.10.4.9.</span> <span class="nav-text">devices</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dns"><span class="nav-number">3.10.4.10.</span> <span class="nav-text">dns</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dns-search"><span class="nav-number">3.10.4.11.</span> <span class="nav-text">dns_search</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#entrypoint"><span class="nav-number">3.10.4.12.</span> <span class="nav-text">entrypoint</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#env-file"><span class="nav-number">3.10.4.13.</span> <span class="nav-text">env_file</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#environment"><span class="nav-number">3.10.4.14.</span> <span class="nav-text">environment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#expose"><span class="nav-number">3.10.4.15.</span> <span class="nav-text">expose</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#extra-hosts"><span class="nav-number">3.10.4.16.</span> <span class="nav-text">extra_hosts</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#healthcheck"><span class="nav-number">3.10.4.17.</span> <span class="nav-text">healthcheck</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#image"><span class="nav-number">3.10.4.18.</span> <span class="nav-text">image</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#logging"><span class="nav-number">3.10.4.19.</span> <span class="nav-text">logging</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#network-mode"><span class="nav-number">3.10.4.20.</span> <span class="nav-text">network_mode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#restart"><span class="nav-number">3.10.4.21.</span> <span class="nav-text">restart</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#secrets"><span class="nav-number">3.10.4.22.</span> <span class="nav-text">secrets</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#security-opt"><span class="nav-number">3.10.4.23.</span> <span class="nav-text">security_opt</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stop-grace-period"><span class="nav-number">3.10.4.24.</span> <span class="nav-text">stop_grace_period</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stop-signal"><span class="nav-number">3.10.4.25.</span> <span class="nav-text">stop_signal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sysctls"><span class="nav-number">3.10.4.26.</span> <span class="nav-text">sysctls</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tmpfs"><span class="nav-number">3.10.4.27.</span> <span class="nav-text">tmpfs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ulimits"><span class="nav-number">3.10.4.28.</span> <span class="nav-text">ulimits</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volumes"><span class="nav-number">3.10.4.29.</span> <span class="nav-text">volumes</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-Machine"><span class="nav-number">3.11.</span> <span class="nav-text">Docker Machine</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="nav-number">3.11.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">3.11.2.</span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4"><span class="nav-number">3.11.2.1.</span> <span class="nav-text">安装命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="nav-number">3.11.3.</span> <span class="nav-text">使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%88%97%E5%87%BA%E5%8F%AF%E7%94%A8%E7%9A%84%E6%9C%BA%E5%99%A8"><span class="nav-number">3.11.3.1.</span> <span class="nav-text">1、列出可用的机器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%88%9B%E5%BB%BA%E6%9C%BA%E5%99%A8"><span class="nav-number">3.11.3.2.</span> <span class="nav-text">2、创建机器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%9F%A5%E7%9C%8B%E6%9C%BA%E5%99%A8%E7%9A%84-ip"><span class="nav-number">3.11.3.3.</span> <span class="nav-text">3、查看机器的 ip</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%81%9C%E6%AD%A2%E6%9C%BA%E5%99%A8"><span class="nav-number">3.11.3.4.</span> <span class="nav-text">4、停止机器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%90%AF%E5%8A%A8%E6%9C%BA%E5%99%A8"><span class="nav-number">3.11.3.5.</span> <span class="nav-text">5、启动机器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E8%BF%9B%E5%85%A5%E6%9C%BA%E5%99%A8"><span class="nav-number">3.11.3.6.</span> <span class="nav-text">6、进入机器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="nav-number">3.11.4.</span> <span class="nav-text">参数说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Swarm-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86"><span class="nav-number">3.12.</span> <span class="nav-text">Swarm 集群管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="nav-number">3.12.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">3.12.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-2"><span class="nav-number">3.12.3.</span> <span class="nav-text">使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA-swarm-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E8%8A%82%E7%82%B9%EF%BC%88manager%EF%BC%89"><span class="nav-number">3.12.3.1.</span> <span class="nav-text">1、创建 swarm 集群管理节点（manager）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%88%9B%E5%BB%BA-swarm-%E9%9B%86%E7%BE%A4%E5%B7%A5%E4%BD%9C%E8%8A%82%E7%82%B9%EF%BC%88worker%EF%BC%89"><span class="nav-number">3.12.3.2.</span> <span class="nav-text">2、创建 swarm 集群工作节点（worker）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%9F%A5%E7%9C%8B%E9%9B%86%E7%BE%A4%E4%BF%A1%E6%81%AF"><span class="nav-number">3.12.3.3.</span> <span class="nav-text">3、查看集群信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%88%B0%E9%9B%86%E7%BE%A4%E4%B8%AD"><span class="nav-number">3.12.3.4.</span> <span class="nav-text">4、部署服务到集群中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E6%83%85%E5%86%B5"><span class="nav-number">3.12.3.5.</span> <span class="nav-text">5、查看服务部署情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E6%89%A9%E5%B1%95%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.12.3.6.</span> <span class="nav-text">6、扩展集群服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E5%88%A0%E9%99%A4%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.12.3.7.</span> <span class="nav-text">7、删除服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E6%BB%9A%E5%8A%A8%E5%8D%87%E7%BA%A7%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.12.3.8.</span> <span class="nav-text">8、滚动升级服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81%E5%81%9C%E6%AD%A2%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E6%8E%A5%E6%94%B6%E6%96%B0%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="nav-number">3.12.3.9.</span> <span class="nav-text">9、停止某个节点接收新的任务</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#OpenStack%E3%80%81Docker%E3%80%81k8s%E4%B8%8EMesos"><span class="nav-number">4.</span> <span class="nav-text">OpenStack、Docker、k8s与Mesos</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kubernetes%EF%BC%88k8s%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">Kubernetes（k8s）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81-Kubernetes"><span class="nav-number">5.1.</span> <span class="nav-text">1、为什么要 Kubernetes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Kubernetes"><span class="nav-number">5.2.</span> <span class="nav-text">2、什么是 Kubernetes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81Kubernetes-%E6%9C%AF%E8%AF%AD"><span class="nav-number">5.3.</span> <span class="nav-text">3、Kubernetes 术语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Pod"><span class="nav-number">5.3.1.</span> <span class="nav-text">1. Pod</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Label"><span class="nav-number">5.3.2.</span> <span class="nav-text">2. Label</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Replication-Controller"><span class="nav-number">5.3.3.</span> <span class="nav-text">3. Replication Controller</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Deployment"><span class="nav-number">5.3.4.</span> <span class="nav-text">4. Deployment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Horizontal-Pod-Autoscaler"><span class="nav-number">5.3.5.</span> <span class="nav-text">5. Horizontal Pod Autoscaler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-StatefulSet"><span class="nav-number">5.3.6.</span> <span class="nav-text">6. StatefulSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Service"><span class="nav-number">5.3.7.</span> <span class="nav-text">7. Service</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Service-%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">5.3.7.1.</span> <span class="nav-text">Service 的负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Service-%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="nav-number">5.3.7.2.</span> <span class="nav-text">Service 的服务发现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Volume"><span class="nav-number">5.3.8.</span> <span class="nav-text">8. Volume</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Persistent-Volume"><span class="nav-number">5.3.9.</span> <span class="nav-text">9. Persistent Volume</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Namespace"><span class="nav-number">5.3.10.</span> <span class="nav-text">10. Namespace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-ConfigMap"><span class="nav-number">5.3.11.</span> <span class="nav-text">11. ConfigMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81Kubernetes-%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="nav-number">5.4.</span> <span class="nav-text">4、Kubernetes 的架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Master-%E7%BB%84%E4%BB%B6"><span class="nav-number">5.4.1.</span> <span class="nav-text">1. Master 组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Node-%E7%BB%84%E4%BB%B6"><span class="nav-number">5.4.2.</span> <span class="nav-text">2. Node 组件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81Kubernetes-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">5.5.</span> <span class="nav-text">5、Kubernetes 架构模块实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-API-Server"><span class="nav-number">5.5.1.</span> <span class="nav-text">1. API Server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81"><span class="nav-number">5.5.2.</span> <span class="nav-text">2. 安全认证</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RBAC"><span class="nav-number">5.5.2.1.</span> <span class="nav-text">RBAC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E7%A7%8D%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.5.2.2.</span> <span class="nav-text">4 种资源对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Role-%E4%B8%8E-ClusterRole"><span class="nav-number">5.5.2.3.</span> <span class="nav-text">Role 与 ClusterRole</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ServiceAccount"><span class="nav-number">5.5.2.4.</span> <span class="nav-text">ServiceAccount</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Controller-Manager"><span class="nav-number">5.5.3.</span> <span class="nav-text">3. Controller Manager</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ResourceQuota-Controller"><span class="nav-number">5.5.3.1.</span> <span class="nav-text">ResourceQuota Controller</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Namespace-Controller"><span class="nav-number">5.5.3.2.</span> <span class="nav-text">Namespace Controller</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Endpoints-Controller"><span class="nav-number">5.5.3.3.</span> <span class="nav-text">Endpoints Controller</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Scheduler"><span class="nav-number">5.5.4.</span> <span class="nav-text">4. Scheduler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%BD%91%E7%BB%9C"><span class="nav-number">5.5.5.</span> <span class="nav-text">5. 网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="nav-number">5.5.6.</span> <span class="nav-text">6. 服务发现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">5.6.</span> <span class="nav-text">6、常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="nav-number">5.6.1.</span> <span class="nav-text">基础命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%91%BD%E4%BB%A4"><span class="nav-number">5.6.2.</span> <span class="nav-text">设置命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2%E5%91%BD%E4%BB%A4"><span class="nav-number">5.6.3.</span> <span class="nav-text">部署命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4"><span class="nav-number">5.6.4.</span> <span class="nav-text">集群管理命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E5%92%8C%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="nav-number">5.6.5.</span> <span class="nav-text">故障诊断和调试命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="nav-number">5.6.6.</span> <span class="nav-text">其他命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4"><span class="nav-number">5.6.7.</span> <span class="nav-text">高级命令</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Run-Qing Chen"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Run-Qing Chen</p>
  <div class="site-description" itemprop="description">覆苍天以为衾，卧大地以为庐。</div>
</div>


   <div class="feed-link motion-element">
     <a href="/atom.xml" rel="alternate">
       <i class="fa fa-rss"></i>
       RSS
     </a>
   </div>
 
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">181</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RexKing6" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RexKing6" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1010026261@qq.com" title="E-Mail → mailto:1010026261@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.zxpblog.cn/" title="https:&#x2F;&#x2F;www.zxpblog.cn&#x2F;" rel="noopener" target="_blank">赵小平</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://whitepuffer.github.io/" title="https:&#x2F;&#x2F;whitepuffer.github.io&#x2F;" rel="noopener" target="_blank">江斓</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kexue.fm/" title="https:&#x2F;&#x2F;kexue.fm&#x2F;" rel="noopener" target="_blank">科学空间</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yongyuan.name/" title="https:&#x2F;&#x2F;yongyuan.name&#x2F;" rel="noopener" target="_blank">袁勇</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/abcjennifer" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;abcjennifer" rel="noopener" target="_blank">Rachel Zhang</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://dmkf.xyz/" title="http:&#x2F;&#x2F;dmkf.xyz&#x2F;" rel="noopener" target="_blank">代码咖啡</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://wuxiaolong.me/" title="http:&#x2F;&#x2F;wuxiaolong.me&#x2F;" rel="noopener" target="_blank">吴小龙同学</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.tennfy.com/" title="http:&#x2F;&#x2F;www.tennfy.com&#x2F;" rel="noopener" target="_blank">TENNFY WU</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fab fa-accessible-icon"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Run-Qing Chen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">2.8m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">43:03</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"6XDsO3aHIjDk3nV6eLJCufbl-MdYXbMMI","app_key":"YK4qOc0TpkazN6exhuqsnwmB","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
