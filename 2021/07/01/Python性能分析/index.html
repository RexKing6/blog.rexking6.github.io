<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.rexking6.top","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#37c6c0","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"YS7HT61SEB","apiKey":"0fd1eba022e7883c76ff4a71aee2acdc","indexName":"blog_NAME","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"找不到关于 ${query} 的文章","hits_stats":"共找到 ${hits} 篇文章，花了 ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="...">
<meta property="og:type" content="article">
<meta property="og:title" content="Python性能分析">
<meta property="og:url" content="https://blog.rexking6.top/2021/07/01/Python%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">
<meta property="og:site_name" content="RexKing6&#39;s Note">
<meta property="og:description" content="...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.rexking6.top/img/0c467aacda251beb4b2541823088d427.png">
<meta property="article:published_time" content="2021-07-01T00:43:52.000Z">
<meta property="article:modified_time" content="2024-08-03T16:34:22.037Z">
<meta property="article:author" content="Run-Qing Chen">
<meta property="article:tag" content="开发">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.rexking6.top/img/0c467aacda251beb4b2541823088d427.png">

<link rel="canonical" href="https://blog.rexking6.top/2021/07/01/Python%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Python性能分析 | RexKing6's Note</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="RexKing6's Note" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RexKing6's Note</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/rexking6" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.rexking6.top/2021/07/01/Python%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Run-Qing Chen">
      <meta itemprop="description" content="覆苍天以为衾，卧大地以为庐。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RexKing6's Note">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python性能分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-01 08:43:52" itemprop="dateCreated datePublished" datetime="2021-07-01T08:43:52+08:00">2021-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-04 00:34:22" itemprop="dateModified" datetime="2024-08-04T00:34:22+08:00">2024-08-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E5%8F%91/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          
            <span id="/2021/07/01/Python%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" class="post-meta-item leancloud_visitors" data-flag-title="Python性能分析" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>34k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>30 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>综合转载于：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39949889/article/details/111436628">python 存储文件加速_如何加速 Python 代码？</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15127648/4162070">Effective Python 并行与并发</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ctwy291314/article/details/89358144">Python multiprocessing使用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15474913/5395326">Python之mmap内存映射模块（大文本处理）说明</a></li>
</ul>
<h1 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h1><ul>
<li><p>测量，不要猜测。 测量代码中哪些部分运行时间最长，先把重点放在那些部分上。</p>
</li>
<li><p>实现缓存。 如果你从磁盘、网络和数据库执行多次重复的查找，这可能是一个很大的优化之处。</p>
</li>
<li><p>重用对象，而不是在每次迭代中创建一个新对象。Python 必须清理你创建的每个对象才能释放内存，这就是所谓的“垃圾回收”。许多未使用对象的垃圾回收会大大降低软件速度。</p>
</li>
<li><p>尽可能减少代码中的迭代次数，特别是减少迭代中的操作次数。</p>
</li>
<li><p>避免(深度)递归。 对于 Python 解释器来说，它需要大量的内存和维护(Housekeeping)。改用生成器和迭代之类的工具。</p>
</li>
<li><p>减少内存使用。 一般来说，尽量减少内存的使用。例如，对一个巨大的文件进行逐行解析，而不是先将其加载到内存中。</p>
</li>
<li><p>使用PyPy等方案</p>
</li>
<li><p>使用多线程</p>
<p>在等待来自网络或磁盘的应答时，你可以使用多个线程使其他部分保持运行状态。一个线程是一个独立的执行序列。默认情况下，Python 程序有一个主线程。但你可以创建更多的主线程，并让 Python 在它们之间切换。这种切换发生得如此之快，以至于它们看上去就好像是在同时并排运行一样。但与其他编程语言不同的是，Python 并不是同时运行的，而是轮流运行。这是因为 Python 中有一种全局解释器锁（Global Interpreter Lock，GIL）机制。我们得到的结论是，线程对于 IO 密集型的软件有很大的影响，但对 CPU 密集型的软件毫无用处。这是为什么呢？很简单。当一个线程在等待来自网络的答复时，其他线程可以继续运行。如果你要执行大量的网络请求，线程可以带来巨大的差异。如果你的线程正在进行繁重的计算，那么它们只是等待轮到它们继续计算，线程化只会带来更多的开销。</p>
</li>
<li><p>使用Asyncio</p>
<p>Asyncio 是 Python 中一个相对较新的核心库。它解决了与线程相同的问题：它加快了 IO 密集型软件的速度，但这是以不同的方式实现的。它相当复杂，特别是对于初学者来说。我遇到的另一个问题是， asyncio 库在过去几年中有了很大的发展。网上的教程和示例代码常常已经过时。不过，这并不意味着它就毫无用处。</p>
</li>
<li><p>使用多进程</p>
<p>如果你的软件是 CPU 密集型的，你通常可以用一种可以同时使用更多处理器的方式重写你的代码。通过这种方式，你就可以线性地调整执行速度。这就是所谓的并行性，但并不是所有的算法都可以并行运行。例如，简单的将递归算法进行并行化是不可能的。但是几乎总有一种替代算法可以很好地并行工作。使用更多处理处理器有两种方式：</p>
<ul>
<li>在同一台机器内使用多个处理器和 / 或内核。在 Python 中，这可以通过 multiprocessing 库来完成。</li>
<li>使用计算机网络来使用多个处理器，分布在多台计算机上。我们称之为分布式计算。</li>
</ul>
<p>与 threading 库不同， multiprocessing 库绕过了 Python 的全局解释器锁。它实际上是通过派生多个 Python 实例来实现这一点的。因此，现在你可以让多个 Python 进程同时运行你的代码，而不是在单个 Python 进程中轮流运行线程。</p>
<p>multiprocessing 库和 threading 库非常相似。可能出现的问题是：为什么还要考虑线程呢？答案是可以猜得到的。线程是“轻量”的：它需要更少的内存，因为它只需要一个正在运行的 Python 解释器。产生新进程也还有其开销。因此，如果你的代码是 IO 密集型的，线程可能就足够好了。</p>
<p>一旦你实现了软件的并行工作，那么在使用 Hadoop 之类的分布式计算方面就前进了一小步。通过利用云计算平台，你可以相对轻松地进行扩展规模。例如，你可以在云端中处理大型数据集，并在本地使用结果。使用混合操作的方式，你可以节省一些资金，因为云端中的算力非常昂贵。</p>
</li>
</ul>
<h1 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="性能分析工具"></a>性能分析工具</h1><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><div class="table-container">
<table>
<thead>
<tr>
<th>工具</th>
<th>特点</th>
<th>文档</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>cProfile</td>
<td>Python标准库自带的分析工具</td>
<td><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/profile.html#module-cProfile">https://docs.python.org/3/library/profile.html#module-cProfile</a></td>
<td>比较简单方便，快速找出耗时较高的函数</td>
</tr>
<tr>
<td>timeit</td>
<td>Python标准库自带分析工具，分析短代码块的执行时间</td>
<td><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/timeit.html">https://docs.python.org/3/library/timeit.html</a></td>
<td></td>
</tr>
<tr>
<td>vmprof</td>
<td>具备一定可视化能力</td>
<td><a target="_blank" rel="noopener" href="https://vmprof.readthedocs.io/en/latest/vmprof.html">https://vmprof.readthedocs.io/en/latest/vmprof.html</a></td>
<td>可视化不错</td>
</tr>
<tr>
<td>pycharm profile工具</td>
<td>可视化强（需要专业版）</td>
<td><a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/pycharm/profiler.html#start-profiling">https://www.jetbrains.com/help/pycharm/profiler.html#start-profiling</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="cProfile"><a href="#cProfile" class="headerlink" title="cProfile"></a>cProfile</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from cProfile import Profile</span><br><span class="line">from pstats import Stats</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def do():</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        print(&quot;11111&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">profiler = Profile()</span><br><span class="line">profiler.runcall(do)</span><br><span class="line">stats = Stats(profiler)</span><br><span class="line"># 清除路径前缀</span><br><span class="line">stats.strip_dirs()</span><br><span class="line"># 按累计时间排序</span><br><span class="line">stats.sort_stats(&#x27;cumulative&#x27;)</span><br><span class="line">stats.print_stats(100)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      100002 function calls in 10.191 seconds</span><br><span class="line"></span><br><span class="line">Ordered by: cumulative time</span><br><span class="line"></span><br><span class="line">ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">     1    0.106    0.106   10.191   10.191 test.py:25(do)</span><br><span class="line">100000   10.085    0.000   10.085    0.000 &#123;built-in method builtins.print&#125;</span><br><span class="line">     1    0.000    0.000    0.000    0.000 &#123;method &#x27;disable&#x27; of &#x27;_lsprof.Profiler&#x27; objects&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vmprof"><a href="#vmprof" class="headerlink" title="vmprof"></a>vmprof</h4><ol>
<li><p>首先需要参考 <a target="_blank" rel="noopener" href="https://github.com/vmprof/vmprof-server">https://github.com/vmprof/vmprof-server</a> 起一个可视化服务端</p>
</li>
<li><p>运行profile程序</p>
<p><code>python -m vmprof --web --web-url=http://127.0.0.1:8000/ XXX</code></p>
</li>
<li><p>在本地查看可视化结果</p>
</li>
</ol>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><div class="table-container">
<table>
<thead>
<tr>
<th>工具</th>
<th>特点</th>
<th>文档</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>memory_profiler</td>
<td>纯python实现的逐行内存占用分析工具</td>
<td><a target="_blank" rel="noopener" href="https://pypi.org/project/memory-profiler">https://pypi.org/project/memory-profiler</a></td>
<td></td>
</tr>
<tr>
<td>obj_graph</td>
<td>用于分析python对象之间的调用关系，主要用于排查内存泄漏等；可结合graphviz做可视化</td>
<td><a target="_blank" rel="noopener" href="https://mg.pov.lt/objgraph">https://mg.pov.lt/objgraph</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><h4 id="memory-profiler"><a href="#memory-profiler" class="headerlink" title="memory_profiler"></a>memory_profiler</h4><ol>
<li><p>首先用profile装饰需要分析的代码块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from cProfile import Profile</span><br><span class="line">from pstats import Stats</span><br><span class="line">from memory_profiler import profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@profile</span><br><span class="line">def do():</span><br><span class="line">    for i in range(10000):</span><br><span class="line">        print(&quot;11111&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">profiler = Profile()</span><br><span class="line">profiler.runcall(do)</span><br><span class="line">stats = Stats(profiler)</span><br><span class="line"># 清除路径前缀</span><br><span class="line">stats.strip_dirs()</span><br><span class="line"># 按累计时间排序</span><br><span class="line">stats.sort_stats(&#x27;cumulative&#x27;)</span><br><span class="line">stats.print_stats(100)</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后运行命令行分析：</p>
</li>
</ol>
<p>​    <code>python -m memory-profiler XXXX.py</code></p>
<ol>
<li><p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Line #    Mem usage    Increment  Occurrences   Line Contents</span><br><span class="line">=============================================================</span><br><span class="line">    26     41.0 MiB     41.0 MiB           1   @profile</span><br><span class="line">    27                                         def do():</span><br><span class="line">    28     41.0 MiB      0.0 MiB       10001       for i in range(10000):</span><br><span class="line">    29     41.0 MiB      0.0 MiB       10000           print(&quot;11111&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="CPU-1"><a href="#CPU-1" class="headerlink" title="CPU"></a>CPU</h2><p>Python为什么慢？</p>
<p>​    Source code-&gt;Compiler-&gt;Byte code+Library modules-&gt;Virtual machine-&gt;Running code</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>原因</th>
<th>解决方案</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>解释型</td>
<td>1. 换解释器 2. 编译</td>
<td>1. pypy 2. numba, jax, taichi(图形学)</td>
</tr>
<tr>
<td>GIL</td>
<td>1. 去掉GIL</td>
<td>1. nogil 2. numba(nogil模式)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><div class="table-container">
<table>
<thead>
<tr>
<th>工具</th>
<th>AOT(提前编译)/JIT(即时编译)</th>
<th>中间产物</th>
<th>简介</th>
<th>上手难度</th>
<th>文档</th>
<th>支持的语法</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Numba</td>
<td>JIT&amp;AOT</td>
<td>LLVM IR</td>
<td>Numba is an open source JIT compiler that translates a subset of Python and NumPy code into fast machine code.</td>
<td>** 简单（不过对于部分场景需要特殊编码）</td>
<td><a target="_blank" rel="noopener" href="http://numba.pydata.org/">http://numba.pydata.org/</a></td>
<td><a target="_blank" rel="noopener" href="https://numba.readthedocs.io/en/stable/reference/pysupported.html">https://numba.readthedocs.io/en/stable/reference/pysupported.html</a></td>
<td>数值计算场景加速明显</td>
</tr>
<tr>
<td>jax</td>
<td>JIT</td>
<td>LLVM IR</td>
<td>JAX is NumPy on the CPU, GPU, and TPU, with great automatic differentiation for high-performance machine learning research.</td>
<td><em>*</em> 较为简单 和numpy API类似</td>
<td><a target="_blank" rel="noopener" href="https://jax.readthedocs.io/en/latest/notebooks/quickstart.html">https://jax.readthedocs.io/en/latest/notebooks/quickstart.html</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>taichi</td>
<td>JIT</td>
<td>LLVM IR</td>
<td>Taichi Lang is an open-source, imperative, parallel programming language for high-performance numerical computation.</td>
<td><em>*</em> 较为简单</td>
<td><a target="_blank" rel="noopener" href="https://github.com/taichi-dev/taichi">https://github.com/taichi-dev/taichi</a></td>
<td></td>
<td>数值计算</td>
</tr>
<tr>
<td>PyPy</td>
<td>JIT</td>
<td>-</td>
<td>a fast, compliant alternative implementation of the Python language</td>
<td>* 简单（无需修改任何代码）</td>
<td><a target="_blank" rel="noopener" href="https://doc.pypy.org/en/latest">https://doc.pypy.org/en/latest</a></td>
<td></td>
<td>平均比Cython快4.5倍，实测似乎没太大区别</td>
</tr>
<tr>
<td>Cython</td>
<td>AOT</td>
<td>C/C++</td>
<td>is a programming language that makes writing C extensions for the Python language as easy as Python itself</td>
<td><em>**</em> 复杂，需要有C基础</td>
<td><a target="_blank" rel="noopener" href="https://cython.readthedocs.io/en/latest/src/quickstart/overview.html">https://cython.readthedocs.io/en/latest/src/quickstart/overview.html</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nogil</td>
<td>AOT</td>
<td>-</td>
<td>Python Multithreading without GIL</td>
<td>* 简单</td>
<td><a target="_blank" rel="noopener" href="https://github.com/colesbury/nogil">https://github.com/colesbury/nogil</a></td>
<td></td>
<td>单线程有一点点性能损失，适用于多核多线程场景（比Cython的多核多进程轻量）</td>
</tr>
<tr>
<td>pyjion</td>
<td>JIT</td>
<td>IL(ECMA335CIL) instructions</td>
<td>Pyjion is a drop-in JIT Compiler for Python 3.10</td>
<td>* 简单</td>
<td><a target="_blank" rel="noopener" href="https://www.trypyjion.com/">https://www.trypyjion.com/</a></td>
<td>只支持python 3.10</td>
<td>比python快约1-2倍</td>
</tr>
</tbody>
</table>
</div>
<h4 id="numba例子"><a href="#numba例子" class="headerlink" title="numba例子"></a>numba例子</h4><p>测试环境：Python3.8 13寸M1 MAC</p>
<p>测试结果：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>条件</th>
<th>平均耗时</th>
<th>加速比</th>
</tr>
</thead>
<tbody>
<tr>
<td>不使用numba加速</td>
<td>2000ms</td>
<td>x1</td>
</tr>
<tr>
<td>njit</td>
<td>20ms</td>
<td>x100</td>
</tr>
<tr>
<td>pelt_helper函数不用njit，其他函数用</td>
<td>320ms</td>
<td>x7</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.util <span class="keyword">import</span> change_root</span><br><span class="line"><span class="keyword">import</span> enum</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> pdist, squareform</span><br><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> njit</span><br><span class="line"></span><br><span class="line"><span class="meta">@njit(<span class="params">fastmath=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sum_prefix</span>(<span class="params">gram: np.array</span>) -&gt; np.array:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    二维数组前缀和</span></span><br><span class="line"><span class="string">    :param gram:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    row, col = gram.shape</span><br><span class="line">    res = np.zeros((row+<span class="number">1</span>, col+<span class="number">1</span>), dtype=np.float32)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col+<span class="number">1</span>):</span><br><span class="line">            res[i][j] = res[i-<span class="number">1</span>][j] + res[i][j-<span class="number">1</span>] + gram[i-<span class="number">1</span>][j-<span class="number">1</span>] - res[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="meta">@njit(<span class="params">fastmath=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sum</span>(<span class="params">sum_array: np.array, s: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    区间求和</span></span><br><span class="line"><span class="string">    :param sum_array:</span></span><br><span class="line"><span class="string">    :param s:</span></span><br><span class="line"><span class="string">    :param t:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    s += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sum_array[t][t] - sum_array[t][s-<span class="number">1</span>] - sum_array[s-<span class="number">1</span>][t] + sum_array[s-<span class="number">1</span>][s-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">@njit(<span class="params">fastmath=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_min</span>(<span class="params">arr: np.array, val=<span class="number">0.0</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(np.<span class="built_in">min</span>(arr)) + val, np.argmin(arr)</span><br><span class="line"></span><br><span class="line"><span class="meta">@njit(<span class="params">fastmath=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pelt_helper</span>(<span class="params">gram: np.array, length: <span class="built_in">int</span>, pen: <span class="built_in">float</span></span>):</span><br><span class="line">    <span class="keyword">if</span> pen <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        pen = np.log(length)</span><br><span class="line"></span><br><span class="line">    F = np.zeros(length + <span class="number">1</span>)</span><br><span class="line">    R = np.array([<span class="number">0</span>], dtype=np.int64)</span><br><span class="line">    candidates = np.zeros(length+<span class="number">1</span>， dtype=np.int64)</span><br><span class="line"></span><br><span class="line">    F[<span class="number">0</span>] = -pen</span><br><span class="line"></span><br><span class="line">    sum_array = get_sum_prefix(gram)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> tstar <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, length+<span class="number">1</span>):</span><br><span class="line">        cpt_cands = R</span><br><span class="line">        seg_costs = np.zeros(<span class="built_in">len</span>(cpt_cands))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(cpt_cands)):</span><br><span class="line">            seg_costs[i] = (tstar - cpt_cands[i]) - (get_sum(sum_array, cpt_cands[i], tstar) / (tstar - cpt_cands[i]))</span><br><span class="line"></span><br><span class="line">        F_cost = F[cpt_cands] + seg_costs</span><br><span class="line">        F[tstar], tau  =find_min(F_cost, pen)</span><br><span class="line">        candidates[tstar] = cpt_cands[tau]</span><br><span class="line"></span><br><span class="line">        ineq_prune = [val &lt; F[tstar] <span class="keyword">for</span> val <span class="keyword">in</span> F_cost]</span><br><span class="line">        R = [cpt_cands[j] <span class="keyword">for</span> j, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(ineq_prune) <span class="keyword">if</span> val]</span><br><span class="line">        R.append(tstar - <span class="number">1</span>)</span><br><span class="line">        R = np.array(R, dtype=np.int64)</span><br><span class="line"></span><br><span class="line">    last = candidates[-<span class="number">1</span>]</span><br><span class="line">    changepoints = [last]</span><br><span class="line">    <span class="keyword">while</span> last &gt; <span class="number">0</span>:</span><br><span class="line">        last = candidates[last]</span><br><span class="line">        changepoints.append(last)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(changepoints)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pelt</span>(<span class="params">data, length, pen=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    pelt算法</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :param length:</span></span><br><span class="line"><span class="string">    :param pen:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> data.ndim == <span class="number">1</span>:</span><br><span class="line">        data = data.reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    K = pdist(data, metric=<span class="string">&quot;sqeuclidean&quot;</span>)</span><br><span class="line">    gamma = <span class="number">1.0</span></span><br><span class="line">    K_median = np.median(K)</span><br><span class="line">    <span class="keyword">if</span> K_median != <span class="number">0</span>:</span><br><span class="line">        gamma = <span class="number">1</span> / K_median</span><br><span class="line">    k *= gamma</span><br><span class="line">    np.clip(K, <span class="number">1e-2</span>, <span class="number">1e2</span>, K)</span><br><span class="line">    gram = np.exp(squareform(-K))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pelt_helper(gram, length, pen)</span><br></pre></td></tr></table></figure>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>通常在UNIX下面处理文本文件的方法是sed、awk等shell命令，对于处理大文件受CPU，IO等因素影响，对服务器也有一定的压力。关于sed的说明可以看 了解sed的工作原理，本文将介绍通过python的mmap模块来实现对大文件的处理，来对比看他们的差异。</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>mmap是一种虚拟内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。关于系统中mmap的理论说明可以看 百度百科和 维基百科说明以及mmap函数介绍，这里的说明是针对在Python下 mmap模块的使用说明。</p>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m=mmap.mmap(fileno, length[, flags[, prot[, access[, offset]]]])</span><br></pre></td></tr></table></figure>
<ul>
<li><p>fileno：文件描述符，可以是file对象的<code>fileno()</code>方法，或者来自<code>os.open()</code>，在调用<code>mmap()</code>之前打开文件，不再需要文件时要关闭</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">os.O_RDONLY   以只读的方式打开 Read only</span><br><span class="line">os.O_WRONLY   以只写的方式打开 Write only</span><br><span class="line">os.O_RDWR     以读写的方式打开 Read and write</span><br><span class="line">os.O_APPEND  以追加的方式打开  </span><br><span class="line">os.O_CREAT   创建并打开一个新文件</span><br><span class="line">os.O_EXCL     os.O_CREAT| os.O_EXCL 如果指定的文件存在，返回错误</span><br><span class="line">os.O_TRUNC    打开一个文件并截断它的长度为零（必须有写权限）</span><br><span class="line">os.O_BINARY          以二进制模式打开文件（不转换）</span><br><span class="line">os.O_NOINHERIT        阻止创建一个共享的文件描述符</span><br><span class="line">os.O_SHORT_LIVED</span><br><span class="line">os.O_TEMPORARY        与O_CREAT一起创建临时文件</span><br><span class="line">os.O_RANDOM         缓存优化,但不限制从磁盘中随机存取</span><br><span class="line">os.O_SEQUENTIAL   缓存优化,但不限制从磁盘中序列存取</span><br><span class="line">os.O_TEXT           以文本的模式打开文件（转换）</span><br></pre></td></tr></table></figure>
</li>
<li><p>length：要映射文件部分的大小（以字节为单位），这个值为0，则映射整个文件，如果大小大于文件当前大小，则扩展这个文件</p>
</li>
<li>flags：<code>MAP_PRIVATE</code>：这段内存映射只有本进程可用；<code>mmap.MAP_SHARED</code>：将内存映射和其他进程共享，所有映射了同一文件的进程，都能够看到其中一个所做的更改</li>
<li>prot：<code>mmap.PROT_READ</code>, <code>mmap.PROT_WRITE</code> 和 <code>mmap.PROT_WRITE | mmap.PROT_READ</code>。最后一者的含义是同时可读可写</li>
<li>access：在mmap中有可选参数access的值有<ul>
<li>ACCESS_READ：读访问。</li>
<li>ACCESS_WRITE：写访问，默认。</li>
<li>ACCESS_COPY：拷贝访问，不会把更改写入到文件，使用flush把更改写到文件。</li>
</ul>
</li>
</ul>
<h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">m.close()</span><br><span class="line">关闭 m 对应的文件；</span><br><span class="line"></span><br><span class="line">m.find(str, start=0)</span><br><span class="line">从 start 下标开始，在 m 中从左往右寻找子串 str 最早出现的下标；</span><br><span class="line"></span><br><span class="line">m.flush([offset, n])</span><br><span class="line">把 m 中从offset开始的n个字节刷到对应的文件中；</span><br><span class="line"></span><br><span class="line">m.move(dstoff, srcoff, n)</span><br><span class="line">等于 m[dstoff:dstoff+n] = m[srcoff:srcoff+n]，把从 srcoff 开始的 n 个字节复制到从 dstoff 开始的n个字节，可能会覆盖重叠的部分。</span><br><span class="line"></span><br><span class="line">m.read(n)</span><br><span class="line">返回一个字符串，从 m 对应的文件中最多读取 n 个字节，将会把 m 对应文件的位置指针向后移动；</span><br><span class="line"></span><br><span class="line">m.read_byte() </span><br><span class="line">返回一个1字节长的字符串，从 m 对应的文件中读1个字节，要是已经到了EOF还调用 read_byte()，则抛出异常 ValueError；</span><br><span class="line"></span><br><span class="line">m.readline()</span><br><span class="line">返回一个字符串，从 m 对应文件的当前位置到下一个&#x27;\n&#x27;，当调用 readline() 时文件位于 EOF，则返回空字符串；</span><br><span class="line"></span><br><span class="line">m.resize(n) ***有问题，执行不了***</span><br><span class="line">把 m 的长度改为 n，m 的长度和 m 对应文件的长度是独立的；</span><br><span class="line"></span><br><span class="line">m.seek(pos, how=0)</span><br><span class="line">同 file 对象的 seek 操作，改变 m 对应的文件的当前位置；</span><br><span class="line"></span><br><span class="line">m.size()</span><br><span class="line">返回 m 对应文件的长度（不是 m 对象的长度len(m)）；</span><br><span class="line"></span><br><span class="line">m.tell()</span><br><span class="line">返回 m 对应文件的当前位置；</span><br><span class="line"></span><br><span class="line">m.write(str)</span><br><span class="line">把 str 写到 m 对应文件的当前位置，如果从 m 对应文件的当前位置到 m 结尾剩余的空间不足len(str)，则抛出 ValueError；</span><br><span class="line"></span><br><span class="line">m.write_byte(byte)</span><br><span class="line">把1个字节（对应一个字符）写到 m 对应文件的当前位置，实际上 m.write_byte(ch) 等于 m.write(ch)。如果 m 对应文件的当前位置在 m 的结尾，也就是 m 对应文件的当前位置到 m 结尾剩余的空间不足1个字节，write() 抛出异常ValueError，而 write_byte() 什么都不做。</span><br></pre></td></tr></table></figure>
<h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><p>测试文本：test.txt，mmap对象m</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- MySQL dump 10.13  Distrib 5.6.19, for osx10.7 (x86_64)</span><br><span class="line">--</span><br><span class="line">-- Host: localhost    Database: test</span><br><span class="line">-- ------------------------------------------------------</span><br><span class="line">-- Server version       5.6.19</span><br><span class="line"></span><br><span class="line">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;</span><br><span class="line">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;</span><br><span class="line">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;</span><br><span class="line">/*!40101 SET NAMES utf8 */;</span><br><span class="line">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;</span><br><span class="line">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */;</span><br><span class="line">/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;</span><br><span class="line">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;</span><br><span class="line">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */;</span><br><span class="line">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>m.close()，关闭对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os,mmap</span><br><span class="line">&gt;&gt;&gt; m=mmap.mmap(os.open(&#x27;test.txt&#x27;,os.O_RDWR),0)  #创建内存映射对象，</span><br><span class="line">&gt;&gt;&gt; m.read(10)                                    #可以使用方法</span><br><span class="line">&#x27;-- MySQL d&#x27;</span><br><span class="line">&gt;&gt;&gt; m.close()                                     #关闭对象</span><br><span class="line">&gt;&gt;&gt; m.read(10)                                    #方法不可用</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">ValueError: mmap closed or invalid</span><br></pre></td></tr></table></figure>
</li>
<li><p>m.find(str, start=0)，从start的位置开始寻找第一次出现的str。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m.find(&#x27;SET&#x27;,0)      #从头开始查找第一次出现SET的字符串</span><br><span class="line">197</span><br></pre></td></tr></table></figure>
</li>
<li><p>m.read(n)，返回一个从 m对象文件中读取的n个字节的字符串，将会把 m 对象的位置指针向后移动，后续读取会继续往下读。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m.read(10)         #读取10字节的字符串</span><br><span class="line">&#x27;-- MySQL d&#x27;</span><br><span class="line">&gt;&gt;&gt; m.read(10)         #读取上面10字节后，再往后的10字节数据</span><br><span class="line">&#x27;ump 10.13 &#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>m.read_byte()，返回一个1字节长的字符串，从 m 对应的文件中读1个字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m.read_byte()   #读取第一个字节</span><br><span class="line">&#x27;-&#x27;</span><br><span class="line">&gt;&gt;&gt; m.read_byte()   #读取第二个字节</span><br><span class="line">&#x27;-&#x27;</span><br><span class="line">&gt;&gt;&gt; m.read_byte()   #读取第三个字节</span><br><span class="line">&#x27; &#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>m.readline()：返回一个字符串，从 m 对应文件的当前位置到下一个’\n’，当调用 readline() 时文件位于 EOF，则返回空字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m.readline()             #读取一正行</span><br><span class="line">&#x27;-- MySQL dump 10.13  Distrib 5.6.19, for osx10.7 (x86_64)\n&#x27;</span><br><span class="line">&gt;&gt;&gt; m.readline()             #读取下一正行</span><br><span class="line">&#x27;--\n&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>m.size()：返回 m 对应文件的长度（不是 m 对象的长度len(m)）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m.size()            #整个文件的大小</span><br><span class="line">782</span><br></pre></td></tr></table></figure>
</li>
<li><p>m.tell()：返回 m 对应文件的当前光标位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m.tell()        #当前光标的位置0</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; m.read(10)      #读取10个字节</span><br><span class="line">&#x27;-- MySQL d&#x27;</span><br><span class="line">&gt;&gt;&gt; m.tell()        #当前光标位置10</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
</li>
<li><p>m.seek(pos, how=0)，改变 m 对应的文件的当前位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m.seek(10)        #当前光标定位到10</span><br><span class="line">&gt;&gt;&gt; m.tell()          #读取当前光标的位置</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; m.read(10)        #读取当前光标之后的10字节内容</span><br><span class="line">&#x27;ump 10.13 &#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>m.move(dstoff, srcoff, n)：等于 m[dstoff:dstoff+n] = m[srcoff:srcoff+n]，把从 srcoff 开始的 n 个字节复制到从 dstoff 开始的n个字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m[101:108]            #切片101到108的值</span><br><span class="line">&#x27;-------&#x27;</span><br><span class="line">&gt;&gt;&gt; m[1:8]                #切片1到8的值</span><br><span class="line">&#x27;- MySQL&#x27;</span><br><span class="line">&gt;&gt;&gt; m.move(1,101,8)       #从101开始到后面的8字节（108），替换从1开始到后面的8字节（8）效果：m[1:8]=m[101:108] </span><br><span class="line">&gt;&gt;&gt; m[1:8]                #被替换后</span><br><span class="line">&#x27;-------&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>m.write(str)：把 str 写到 m 对应文件的当前光标位置（覆盖对应长度），如果从 m 对应文件的当前光标位置到 m 结尾剩余的空间不足len(str)，则抛出 ValueError</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m.tell()                #当前光标位置</span><br><span class="line">0 </span><br><span class="line">&gt;&gt;&gt; m.write(&#x27;zhoujy&#x27;)       #写入str，要是写入的大小大于原本的文件，会报错。m.write_byte(byte)不会报错。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m.tell()                #写入后光标位置 </span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m.seek(0)               #重置，光标从头开始</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m.read(10)              #查看10个字节，确定是否被修改成功 </span><br><span class="line">&#x27;zhoujy---d&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>m.flush()：把 m 中从offset开始的n个字节刷到对应的文件中</p>
<p>注意：对于m的修改操作，可以当成一个列表进行切片操作，但是对于切片操作的修改需要改成同样长度的字符串，否则都会报错。如m中的10个字符串进行修改，必须改成10个字符的长度。</p>
</li>
</ul>
<h4 id="应用说明"><a href="#应用说明" class="headerlink" title="应用说明"></a>应用说明</h4><ul>
<li><p>读取整个文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- encoding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import mmap</span><br><span class="line">import contextlib</span><br><span class="line"></span><br><span class="line">f = open(&#x27;test.txt&#x27;, &#x27;r&#x27;)</span><br><span class="line">with contextlib.closing(mmap.mmap(f.fileno(), 0,access=mmap.ACCESS_READ)) as m:</span><br><span class="line">#readline需要循环才能读取整个文件</span><br><span class="line">    while True:</span><br><span class="line">        line = m.readline().strip()</span><br><span class="line">        print line</span><br><span class="line"> #光标到最后位置（读完），就退出</span><br><span class="line">        if m.tell()==m.size(): </span><br><span class="line">            break</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">~$ python untitled.py                                                                                                                                1 ↵</span><br><span class="line">-- ZHOUJY  ---dump 10.13  Distrib 5.6.19, for osx10.7 (x86_64)</span><br><span class="line">--</span><br><span class="line">-- Host: localhost    Database: test</span><br><span class="line">-- ------------------------------------------------------</span><br><span class="line">-- Server version       5.6.19</span><br><span class="line"></span><br><span class="line">/*!40101 ZHOUJY SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */ZHOUJY;</span><br><span class="line">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;</span><br><span class="line">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;</span><br><span class="line">/*!40101 SET NAMES utf8 */;</span><br><span class="line">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;</span><br><span class="line">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */ ZHOUJY;</span><br><span class="line">/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;</span><br><span class="line">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;</span><br><span class="line">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */;</span><br><span class="line">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;</span><br></pre></td></tr></table></figure>
</li>
<li><p>逐步读取指定字节数文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- encoding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import mmap</span><br><span class="line">import contextlib</span><br><span class="line"></span><br><span class="line">with open(&#x27;test.txt&#x27;, &#x27;r&#x27;) as f:</span><br><span class="line">    with contextlib.closing(mmap.mmap(f.fileno(), 0,access=mmap.ACCESS_READ)) as m:</span><br><span class="line">        print &#x27;读取10个字节的字符串 :&#x27;, m.read(10)</span><br><span class="line">        print &#x27;支持切片，对读取到的字符串进行切片操作:&#x27;, m[2:10]</span><br><span class="line">        print &#x27;读取之前光标后的10个字符串&#x27;, m.read(10)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~$ python untitled.py</span><br><span class="line">读取10个字节的字符串 : -- ZHOUJY </span><br><span class="line">支持切片，对读取到的字符串进行切片操作:  ZHOUJY </span><br><span class="line">读取之前光标后的10个字符串  ---dump 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>从整个文件查找所有匹配的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- encoding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import mmap</span><br><span class="line">import contextlib</span><br><span class="line"></span><br><span class="line">word = &#x27;ZHOUJY&#x27;</span><br><span class="line">print &#x27;查找:&#x27;, word</span><br><span class="line"></span><br><span class="line">f = open(&#x27;test.txt&#x27;, &#x27;r&#x27;)</span><br><span class="line">with contextlib.closing(mmap.mmap(f.fileno(), 0,access=mmap.ACCESS_READ)) as m:</span><br><span class="line">#也可以通过find(str,pos)来处理</span><br><span class="line">    while True: </span><br><span class="line">        line = m.readline().strip()</span><br><span class="line">        if line.find(word)&gt;=0:</span><br><span class="line">            print &quot;结果：&quot;</span><br><span class="line">            print line</span><br><span class="line">        elif m.tell()==m.size():</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            pass</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~$ python untitled.py</span><br><span class="line">查找: ZHOUJY</span><br><span class="line">结果：</span><br><span class="line">-- ZHOUJY  ---dump 10.13  Distrib 5.6.19, for osx10.7 (x86_64)</span><br><span class="line">结果：</span><br><span class="line">/*!40101 ZHOUJY SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */ZHOUJY;</span><br><span class="line">结果：</span><br><span class="line">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */ ZHOUJY;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从整个文件里查找，找到就退出（确认到底是否存在）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- encoding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import mmap</span><br><span class="line">import contextlib</span><br><span class="line"></span><br><span class="line">word = &#x27;ZHOUJY&#x27;</span><br><span class="line">print &#x27;查找:&#x27;, word</span><br><span class="line"></span><br><span class="line">f = open(&#x27;test.txt&#x27;, &#x27;r&#x27;)</span><br><span class="line">with contextlib.closing(mmap.mmap(f.fileno(), 0,access=mmap.ACCESS_READ)) as m:</span><br><span class="line">#不需要循环，只要找到一个就可以了</span><br><span class="line">    loc = m.find(word)</span><br><span class="line">    if loc &gt;= 0:</span><br><span class="line">        print loc</span><br><span class="line">        print m[loc:loc+len(word)]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~$ python untitled.py</span><br><span class="line">查找: ZHOUJY</span><br><span class="line">194</span><br><span class="line">ZHOUJY</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过正则查找，（找出40开头的数字）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- encoding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import mmap</span><br><span class="line">import re</span><br><span class="line">import contextlib</span><br><span class="line">  </span><br><span class="line">pattern = re.compile(r&#x27;(40\d*)&#x27;)</span><br><span class="line">  </span><br><span class="line">with open(&#x27;test.txt&#x27;, &#x27;r&#x27;) as f:</span><br><span class="line">    with contextlib.closing(mmap.mmap(f.fileno(), 0,access=mmap.ACCESS_READ)) as m:</span><br><span class="line">        print pattern.findall(m)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ python untitled.py</span><br><span class="line">[&#x27;40101&#x27;, &#x27;40101&#x27;, &#x27;40101&#x27;, &#x27;40101&#x27;, &#x27;40103&#x27;, &#x27;40103&#x27;, &#x27;40014&#x27;, &#x27;40014&#x27;, &#x27;40101&#x27;, &#x27;40111&#x27;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>替换文本中出现一次的内容。比如想把A库的备份文件（9G）还原到B库，需要把里面的USE <code>A</code>改成USE <code>B</code>。</p>
<ul>
<li>sed：时间消耗近105s；磁盘IO几乎跑满；内存几乎没消耗、CPU消耗10～20%之间。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1:替换文本中第一次出现的内容</span><br><span class="line">~$ date &amp;&amp; sed -i &#x27;0,/USE `edcba`;/s//USE `ABCDE`;/&#x27; test.sql &amp;&amp; date</span><br><span class="line">2016年 11月 16日 星期三 12:04:17 CST</span><br><span class="line">2016年 11月 16日 星期三 12:06:02 CST</span><br><span class="line"></span><br><span class="line">2:替换文本中指定行的内容</span><br><span class="line">~$ date &amp;&amp; sed -i &#x27;24s/USE `ABCDE`;/USE `edcba`;/&#x27; test.sql &amp;&amp; date</span><br><span class="line">2016年 11月 16日 星期三 12:09:05 CST</span><br><span class="line">2016年 11月 16日 星期三 12:10:50 CST</span><br></pre></td></tr></table></figure>
<p>IO消耗：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rMB/s    wMB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               1.00     7.00  772.00  105.00    87.22    92.06   418.65    27.90   31.35    2.21  245.56   1.14 100.00</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rMB/s    wMB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               1.00     4.00  778.00  102.00    87.59    90.03   413.36    25.08   30.30    2.59  241.65   1.13  99.60</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rMB/s    wMB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               2.00     5.00  771.00  101.00    87.48    88.04   412.22    29.80   30.24    2.34  243.21   1.14  99.60</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rMB/s    wMB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               1.00    18.00  431.00  137.00    49.08   122.04   616.99    66.20   70.25    3.02  281.75   1.75  99.60</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rMB/s    wMB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00     1.00    1.00  248.00     0.00   177.04  1456.16   105.24  416.53   24.00  418.11   4.02 100.00</span><br></pre></td></tr></table></figure>
<ul>
<li><p>python处理：时间消耗是毫秒级别的，几乎是秒级别完成，该情况比较特别：搜索的关键词在大文本里比较靠前的位置，这样处理上T的大文件也是非常快的，要是搜索的关键词靠后怎会怎么样呢？后面会说明。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- encoding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import mmap</span><br><span class="line">import contextlib</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">word = &#x27;USE `EDCBA`;&#x27;</span><br><span class="line">replace = &#x27;USE `ABCDE`;&#x27;</span><br><span class="line">print &#x27;查找:&#x27;, word</span><br><span class="line">print&#x27;替换:&#x27;, replace</span><br><span class="line"></span><br><span class="line">f = open(&#x27;test.sql&#x27;, &#x27;r+&#x27;)</span><br><span class="line">with contextlib.closing(mmap.mmap(f.fileno(), 0,access=mmap.ACCESS_WRITE)) as m:</span><br><span class="line">    loc = m.find(word)</span><br><span class="line">    if loc &gt;=0:</span><br><span class="line">        print loc</span><br><span class="line">        m[loc:loc + len(word)] = replace</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~$ date &amp;&amp; python mmap_python.py &amp;&amp; date</span><br><span class="line">2016年 11月 16日 星期三 12:14:19 CST</span><br><span class="line">查找: USE `EDCBA`;</span><br><span class="line">替换: USE `ABCDE`;</span><br><span class="line">929</span><br><span class="line">2016年 11月 16日 星期三 12:14:19 CST</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>替换文本中所有匹配的关键词。比如想把备份文件里的ENGINE=MYISAM改成ENGINE=InnoDB，看看性能如何。</p>
<ul>
<li><p>sed处理：时间消耗110s；磁盘IO几乎跑满(读写IO高)；内存几乎没消耗、CPU消耗10～30%之间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ date &amp;&amp; sed -i &#x27;s/ENGINE=InnoDB/ENGINE=MyISAM/g&#x27; test.sql &amp;&amp; date</span><br><span class="line">2016年 11月 16日 星期三 12:19:30 CST</span><br><span class="line">2016年 11月 16日 星期三 12:21:20 CST</span><br></pre></td></tr></table></figure>
<p>和①中sed的执行效果差不多，其实对于处理一条还是多条记录，sed都是做同样工作量的事情，至于原因可以看 了解sed的工作原理说明，个人理解大致意思就是：sed是1行1行读取（所以内存消耗很小），放入到自己设置的缓冲区里，替换完之后再写入（所以IO很高），处理速度受限于CPU和IO。</p>
</li>
<li><p>python处理：时间消耗20多秒，比sed少。因为不用重写所有内容，只需要替换指定的内容即可，并且是在内存中处理的，所以写IO的压力几乎没有。当关键词比较靠后，其读入的数据就比较大，文件需要从磁盘读入到内存，这时磁盘的读IO也很高，写IO还是没有。因为是虚拟内存映射文件，所以占用的物理内存不多，虽然通过TOP看到的内存使用率%mem很高，这里可以不用管，因为大部分都是在SHR列里的消耗，真正使用掉的内存可以通过RES-SHR来计算。关于top中SHR的意思，可以去看相关文章说明。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- encoding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import mmap</span><br><span class="line">import contextlib</span><br><span class="line"></span><br><span class="line">word    = &#x27;ENGINE=MyISAM&#x27;</span><br><span class="line">replace = &#x27;ENGINE=InnoDB&#x27;</span><br><span class="line">print &#x27;查找:&#x27;, word</span><br><span class="line">print&#x27;替换:&#x27;, replace</span><br><span class="line"></span><br><span class="line">loc = 0</span><br><span class="line">f = open(&#x27;test.sql&#x27;, &#x27;r+&#x27;)</span><br><span class="line">with contextlib.closing(mmap.mmap(f.fileno(), 0,access=mmap.ACCESS_WRITE)) as m:</span><br><span class="line">    while True:</span><br><span class="line">        loc = m.find(word,loc)</span><br><span class="line">        if loc &gt;=0:</span><br><span class="line">            print loc</span><br><span class="line">            m[loc:loc + len(word)] = replace</span><br><span class="line">            #要是access=mmap.ACCESS_COPY需要执行flush</span><br><span class="line">            #m.flush()</span><br><span class="line">        elif loc == -1:</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            pass</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">~$ date &amp;&amp; python mmap_python.py &amp;&amp; date</span><br><span class="line">2016年 11月 16日 星期三 13:19:30 CST</span><br><span class="line">查找: ENGINE=MyISAM</span><br><span class="line">替换: ENGINE=InnoDB</span><br><span class="line">1663</span><br><span class="line">5884938</span><br><span class="line">11941259</span><br><span class="line">12630481</span><br><span class="line">12904261</span><br><span class="line">64852169</span><br><span class="line">64859312</span><br><span class="line">65018692</span><br><span class="line">65179617</span><br><span class="line">65181544</span><br><span class="line">65709930</span><br><span class="line">149571849</span><br><span class="line">3592900115</span><br><span class="line">5874952354</span><br><span class="line">7998151839</span><br><span class="line">2016年 11月 16日 星期三 13:19:55 CST</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>正则匹配修改，这个可以通过上面介绍的查找方法，做下修改即可，就不再做说明。</p>
</li>
</ul>
<p><strong>小结：</strong>对比sed和python处理文件的方法，这里来小结下：对于sed不管修改的关键字在文本中的任意位置、次数，修改的工作量都一样（全文的读写IO），差距不大；对于python mmap的修改，要是关键字出现在比较靠前的地方，修改起来速度非常快，否则修改也会有大量的读IO，写IO没有。通过上面的对比分析来看，mmap的修改要比sed修改性能高。</p>
<p>Python还有另一个读取操作的方法：open中的read、readline、readlines，这个方法是把文件全部载入内存，再进行操作。若内存不足直接用swap或则报错退出，内存消耗和文本大小成正比，而通过mmap模块的方法可以很好的避免了这个问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的介绍，大致知道如何使用mmap模块了，其大致特点如下：</p>
<ul>
<li>普通文件被映射到虚拟地址空间后，程序可以向访问普通内存一样对文件进行访问，在有些情况下可以提高IO效率。</li>
<li>它占用物理内存空间少，可以解决内存空间不足的问题，适合处理超大文件。</li>
<li>不同于通常的字符串对象，它是可变的，可以通过切片的方式更改，也可以定位当前文件位置<code>m.tell()</code>或<code>m.seek()</code>定位到文件的指定位置，再进行<code>m.write(str)</code>固定长度的修改操作。</li>
</ul>
<p>最后，可以把mmap封装起来进行使用了，脚本信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mmap</span><br><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> optparse <span class="keyword">import</span> OptionParser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_time</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_deco</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        begin_time = time.time()</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        cost_time = time.time() - begin_time</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;cost time: %s&#x27;</span> % (cost_time)</span><br><span class="line">    <span class="keyword">return</span> _deco</span><br><span class="line"></span><br><span class="line"><span class="meta">@calc_time</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">replace_keyword_all</span>(<span class="params">filename,old_word,new_word</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(old_word) == <span class="built_in">len</span>(new_word):</span><br><span class="line">        loc = <span class="number">0</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;%s 替换成 %s &quot;</span> %(new_word,old_word)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;r+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">with</span> contextlib.closing(mmap.mmap(f.fileno(), <span class="number">0</span>,access=mmap.ACCESS_WRITE)) <span class="keyword">as</span> m:</span><br><span class="line">                <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                    loc = m.find(old_word,loc)</span><br><span class="line">                    <span class="keyword">if</span> loc &gt;= <span class="number">0</span>:</span><br><span class="line">                        m[loc:loc+<span class="built_in">len</span>(old_word)] = new_word</span><br><span class="line">                    <span class="keyword">elif</span> loc == -<span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">        f.close()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;替换的词要和被替换的词长度一致!&quot;</span></span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@calc_time</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">replace_keyword_once</span>(<span class="params">filename,old_word,new_word</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(old_word) == <span class="built_in">len</span>(new_word):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;%s 替换成 %s &quot;</span> %(new_word,old_word)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;r+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">with</span> contextlib.closing(mmap.mmap(f.fileno(), <span class="number">0</span>,access=mmap.ACCESS_WRITE)) <span class="keyword">as</span> m:</span><br><span class="line">                loc = m.find(old_word)</span><br><span class="line">                <span class="keyword">if</span> loc &gt;= <span class="number">0</span>:</span><br><span class="line">                    m[loc:loc+<span class="built_in">len</span>(old_word)] = new_word</span><br><span class="line">        f.close()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;替换的词要和被替换的词长度一致!&quot;</span></span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = OptionParser()</span><br><span class="line">    parser.add_option(<span class="string">&quot;-f&quot;</span>, <span class="string">&quot;--filename&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Filename for search&quot;</span>, dest=<span class="string">&quot;filename&quot;</span>)</span><br><span class="line">    parser.add_option(<span class="string">&quot;-o&quot;</span>, <span class="string">&quot;--oldword&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;the ip to use&quot;</span>, dest=<span class="string">&quot;old_word&quot;</span>)</span><br><span class="line">    parser.add_option(<span class="string">&quot;-n&quot;</span>, <span class="string">&quot;--newword&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;the ip to use&quot;</span>, dest=<span class="string">&quot;new_word&quot;</span>)</span><br><span class="line"></span><br><span class="line">    (options, args) = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> options.filename:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;params filename need to apply&#x27;</span></span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> options.old_word:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;params oldword need to apply&#x27;</span></span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> options.new_word:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;params newword need to apply&#x27;</span></span><br><span class="line">        exit()</span><br><span class="line"><span class="comment"># 替换文本中第一次出现的内容（查到一个就处理退出，越靠前越快）</span></span><br><span class="line"><span class="comment">#    replace_keyword_once(options.filename,options.old_word,options.new_word)</span></span><br><span class="line"><span class="comment"># 替换文本中出现的内容(查找处理整个文本)</span></span><br><span class="line">    replace_keyword_all(options.filename,options.old_word,options.new_word)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~$ python mmap_search.py -h</span><br><span class="line">Usage: mmap_search.py [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -f FILENAME, --filename=FILENAME</span><br><span class="line">                        Filename for search</span><br><span class="line">  -o OLD_WORD, --oldword=OLD_WORD</span><br><span class="line">                        the ip to use</span><br><span class="line">  -n NEW_WORD, --newword=NEW_WORD</span><br><span class="line">                        the ip to use</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1）sed：替换文本中第一次出现的内容</span><br><span class="line">~$ date &amp;&amp; sed -i &#x27;0,/USE `EDCBA`;/s//USE `ABCDE`;/&#x27; test.sql &amp;&amp; date</span><br><span class="line">2016年 11月 17日 星期四 11:15:33 CST</span><br><span class="line">2016年 11月 17日 星期四 11:21:47 CST</span><br><span class="line"></span><br><span class="line">2）mmap：替换文本中第一次出现的内容（使用replace_keyword_once方法，查到一个就处理退出，越靠前越快）</span><br><span class="line">~$ python mmap_search.py --filename=&#x27;test.sql&#x27; --oldword=&quot;USE \`EDCBA\`;&quot; --newword=&quot;USE \`ABCDE\`;&quot;</span><br><span class="line">USE `ABCDE`; 替换成 USE `EDCBA`; </span><br><span class="line">cost time: 0.000128984451294</span><br><span class="line"></span><br><span class="line">3）sed：替换文本中出现的内容(查找处理整个文本)</span><br><span class="line">~$ date &amp;&amp; sed -i &#x27;s/ENGINE=InnoDB/ENGINE=MyISAM/g&#x27; test.sql &amp;&amp; date</span><br><span class="line">2016年 11月 17日 星期四 10:04:49 CST</span><br><span class="line">2016年 11月 17日 星期四 10:11:34 CST</span><br><span class="line"></span><br><span class="line">4）mmap：替换文本中出现的内容(使用replace_keyword_all方法，查找处理整个文本)</span><br><span class="line">~$ python mmap_search.py --filename=&quot;test.sql&quot; --oldword=&quot;ENGINE=MyISAM&quot; --newword=&quot;ENGINE=InnoDB&quot;</span><br><span class="line">ENGINE=InnoDB 替换成 ENGINE=MyISAM </span><br><span class="line">cost time: 198.471223116</span><br></pre></td></tr></table></figure>
<p><strong>结论：</strong>修改大文本文件，通过sed处理，不管被修改的词在哪个位置都需要重写整个文件；而mmap修改文本，被修改的词越靠前性能越好，不需要重写整个文本，只要替换被修改词语的长度即可。</p>
<h1 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h1><p>本文是对《Effective Python》37、38、39条中关于python 多线程的总结。主要分为以下3个部分：</p>
<ul>
<li>并发与并行</li>
<li>多线程的数据共享和竞态</li>
<li>在阻塞式I/O任务中使用Queue来协调多线程C:\Users\陈润青\Downloads\Practice\test.py</li>
</ul>
<h2 id="并发-concurrency-和并行-parallelism"><a href="#并发-concurrency-和并行-parallelism" class="headerlink" title="并发(concurrency)和并行(parallelism)"></a>并发(concurrency)和并行(parallelism)</h2><ul>
<li>并发：计算机似乎在同一时间做了多个任务，但实际上只是在多个任务间快速切换。比如一个单核CPU上在1分钟处理了4个任务，实际上只是每个任务执行1s后就换另外一个任务。</li>
<li>并行：计算机确实在同一时间做着多个任务。比如在4核CPU上，每个核心处理一个任务，1分钟过后，每个任务都做了1分钟。而上面并发的例子中，每个任务只做了1/4分钟。</li>
</ul>
<p>并行与并发的关键区别，就在于能不能提速(speedup)。关于并发核并行的区别， geeksforgeeks总结得较好：</p>
<p><img src="https://image.rexking6.top/img/0c467aacda251beb4b2541823088d427.png" alt="Effective Python 并行与并发_下载图片"></p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="多线程的数据共享"><a href="#多线程的数据共享" class="headerlink" title="多线程的数据共享"></a>多线程的数据共享</h3><p>比如有个程序，它做的操作只有一条<code>cnt = cnt + 1</code>，如果将这个程序写成多线程(假设两个)，那么可能最后的输出是1，而不是2。要理解背后的原因，需要将<code>cnt = cnt + 1</code>写成汇编形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将共享变了cnt加载到accumulator register</span><br><span class="line">movq cnt(%rip), %rdx</span><br><span class="line">// 加1操作</span><br><span class="line">addq %eax</span><br><span class="line">// 将更行的值给回共享变量cnt</span><br><span class="line">movq %eax, cnt(%rip)</span><br></pre></td></tr></table></figure>
<p>如果执行顺序为：线程1执行step1，线程2执行step1，线程1执行step2，线程2执行step2，线程1执行step3，线程2执行step3，结果显然为1。为了解决多线程的数据竞争，需要对数据合理加锁。对于上述多线程中的race condition问题，可以阅读CSAPP 12.5节《Synchronizing Threads with Semaphores》。实操一下《Effective Python》中的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">self, offset</span>):</span><br><span class="line">        self.count += offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">sensor_index, how_many, counter</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(how_many):</span><br><span class="line">        counter.increment(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_threads</span>(<span class="params">func, how_many, counter</span>):</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        args = (i, how_many, counter)</span><br><span class="line">        thread = Thread(target=func, args=args)</span><br><span class="line">        threads.append(thread)</span><br><span class="line">        thread.start()</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">how_many = <span class="number">1000000</span></span><br><span class="line">counter = Counter()</span><br><span class="line">run_threads(worker, how_many, counter)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Counter should be &#123;&#125;, found &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">5</span> * how_many, counter.count))</span><br></pre></td></tr></table></figure>
<p>这里值得注意的是，虽然<code>how_many</code>设置为10000时，得到的结果并不是5倍的<code>how_many</code>，但是<code>how_many</code>很小时，比如1000，结果确实是5倍的<code>how_many</code>。这是因为第二个线程开始时，第一个线程已经完成了worker内的计算。<br>为了解决上述竞态问题，下面是经过数据加锁的代码，threading中的Lock类是用标准方法实现的互斥锁(mutex)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread, Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Counter(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.count = 0</span><br><span class="line">        self.lock = Lock()</span><br><span class="line"></span><br><span class="line">    def increment(self, offset):</span><br><span class="line">        with self.lock:</span><br><span class="line">            self.count += offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def worker(sensor_index, how_many, counter):</span><br><span class="line">    for _ in range(how_many):</span><br><span class="line">        counter.increment(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def run_threads(func, how_many, counter):</span><br><span class="line">    threads = []</span><br><span class="line">    for i in range(5):</span><br><span class="line">        args = (i, how_many, counter)</span><br><span class="line">        thread = Thread(target=func, args=args)</span><br><span class="line">        threads.append(thread)</span><br><span class="line">        thread.start()</span><br><span class="line">    for thread in threads:</span><br><span class="line">        thread.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">how_many = 1000000</span><br><span class="line">counter = Counter()</span><br><span class="line">run_threads(worker, how_many, counter)</span><br><span class="line">print(&quot;Counter should be &#123;&#125;, found &#123;&#125;&quot;.format(5 * how_many, counter.count))</span><br></pre></td></tr></table></figure>
<p>试了一下在<code>counter.increment(1)</code>处加锁，也有用，和原文不一致。</p>
<h3 id="在阻塞式I-O中使用多线程"><a href="#在阻塞式I-O中使用多线程" class="headerlink" title="在阻塞式I/O中使用多线程"></a>在阻塞式I/O中使用多线程</h3><p>在做一些项目的过程中，会遇到有以下特点的任务：</p>
<ul>
<li>整个任务可以划分成按序执行的多个阶段(可以表示成pipeline): <code>Task = stage1-&gt; stage2 -&gt; ... -&gt; stageN</code></li>
<li>其中有些stage是阻塞式I/O操作</li>
</ul>
<p>举个例子：Stage1: 从网络下载图片；Stage 2: 判断图片是否包含小动物； Stage 3: 将包含小动物的图像通过网络传递给客户A。这个过程中Stage 1和Stage 3都是非计算密集型的I/O操作，它可能只需要一条接收或发送语句，接下来等待得到数据或对方接收到数据就行了，主要的计算在Stage 2中。</p>
<p>面对具有这样特点的任务，就可以考虑使用Pyhton中的多线程来提高速度。(注: Python中由于GIL的存在，如果这些stage都是计算密集型的任务，使用多线程无法提高效率，在3.2中我们会具体解释)</p>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>处理上述特点任务时，我们通常会使用<code>Queue</code>来协调各线程间的工作，下面简单介绍一下内置<code>queue</code>模块中的<code>Queue</code>类。</p>
<ul>
<li><code>task_done()</code>方法：标识队列中的某个元素已经出队列了(某个任务已经完成了)</li>
<li><code>join()</code>方法：阻塞，直到队列中所有元素都出队列了(队列为空)</li>
</ul>
<p>如果队列获取某个元素，并对其执行一系列操作后，并未调用task_done()进行标识，调用join()会一直阻塞。<br>举个例子，下面这段代码永远不会执行最后一句print语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line"></span><br><span class="line">q = Queue()</span><br><span class="line">for i in range(10):</span><br><span class="line">    q.put(i)</span><br><span class="line">    </span><br><span class="line">for i in range(10):</span><br><span class="line">    q.get()</span><br><span class="line">    # q.task_done()</span><br><span class="line">    </span><br><span class="line">q.join()</span><br><span class="line">print(&quot;Ohh, Finished q.join&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="为什么这类任务可以考虑多线程"><a href="#为什么这类任务可以考虑多线程" class="headerlink" title="为什么这类任务可以考虑多线程"></a>为什么这类任务可以考虑多线程</h3><p>还是举《Effective Python》中的例子，考虑一个3阶段的任务：</p>
<ol>
<li>从网络下载图片download；</li>
<li>对图片进行处理resize；</li>
<li>将图片上传upload。该任务有阻塞式I/O操作(图片还没完全下载下来，下一个步骤就进行不了)。</li>
</ol>
<p>如果在编写代码时，将download、resize和upload3个函数进行如下实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line">from queue import Queue</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def download(item):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    return item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def resize(item):</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    return item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def upload(item):</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    return item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class StoppableWorker(Thread):</span><br><span class="line"></span><br><span class="line">    def __init__(self, func, in_queue, out_queue):</span><br><span class="line">        super(StoppableWorker, self).__init__()</span><br><span class="line">        self.func = func</span><br><span class="line">        self.in_queue = in_queue</span><br><span class="line">        self.out_queue = out_queue</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        for item in self.in_queue:</span><br><span class="line">            result = self.func(item)</span><br><span class="line">            self.out_queue.put(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ClosableQueue(Queue):</span><br><span class="line">    SENTINEL = object()</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        self.put(self.SENTINEL)</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        while True:</span><br><span class="line">            item = self.get()</span><br><span class="line">            try:</span><br><span class="line">                if item is self.SENTINEL:</span><br><span class="line">                    return</span><br><span class="line">                yield item</span><br><span class="line">            finally:</span><br><span class="line">                self.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">download_queue = ClosableQueue()</span><br><span class="line">resize_queue = ClosableQueue()</span><br><span class="line">upload_queue = ClosableQueue()</span><br><span class="line">output_queue = ClosableQueue()</span><br><span class="line">threads = [</span><br><span class="line">    StoppableWorker(download, download_queue, resize_queue),</span><br><span class="line">    StoppableWorker(resize, resize_queue, upload_queue),</span><br><span class="line">    StoppableWorker(upload, upload_queue, output_queue)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">for t in threads:</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">st = time.time()</span><br><span class="line">for i in range(10):</span><br><span class="line">    download_queue.put(i)</span><br><span class="line">download_queue.close()</span><br><span class="line">download_queue.join()</span><br><span class="line">resize_queue.close()</span><br><span class="line">resize_queue.join()</span><br><span class="line">upload_queue.close()</span><br><span class="line">upload_queue.join()</span><br><span class="line">print(&quot;It took &#123;&#125;&quot;.format(time.time() - st))</span><br><span class="line">print(output_queue.qsize(), &#x27;items finished&#x27;)</span><br></pre></td></tr></table></figure>
<p>运行代码，得到的计算时间满足<code>T = 10 + (N - 1) * 5</code>。看到这个结果，有人可能会纳闷，不是说Python中由于GIL的存在，多个线程只有一个能获得对Python Interpreter的锁，相当于只使用了一个CPU核心吗，这样应该无法提速啊。其实应该注意到<code>time.sleep()</code>操作应该是不占用CPU的，sleep的过程和阻塞式I/O的等待过程类似，而这正是多线程为什么在这类任务上可以提高效率的原因。</p>
<p>如果将这3个函数实现为计算密集型版本(必须使用CPU)，并重新计算花费的时间，在这种情况下，使用多线程就不能带来速度上的提升了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def download(item):</span><br><span class="line">    number = 18769139</span><br><span class="line">    res = 0</span><br><span class="line">    for i in range(1, number + 1):</span><br><span class="line">        if number % i == 0:</span><br><span class="line">            res += 1</span><br><span class="line"></span><br><span class="line">def resize(item):</span><br><span class="line">    number = 18769139 * 3</span><br><span class="line">    res = 0</span><br><span class="line">    for i in range(1, number + 1):</span><br><span class="line">        if number % i == 0:</span><br><span class="line">            res += 1</span><br><span class="line"></span><br><span class="line">def upload(item):</span><br><span class="line">    number = 18769139 * 5</span><br><span class="line">    res = 0</span><br><span class="line">    for i in range(1, number + 1):</span><br><span class="line">        if number % i == 0:</span><br><span class="line">            res += 1</span><br></pre></td></tr></table></figure>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>multiprocessing包是Python中的多进程管理包。与<code>threading.Thread</code>类似，它可以利用<code>multiprocessing.Process</code>对象来创建一个进程。该进程可以运行在Python程序内部编写的函数。该Process对象与Thread对象的用法相同，也有<code>start()</code>, <code>run()</code>, <code>join()</code>的方法。此外multiprocessing包中也有<code>Lock</code>/<code>Event</code>/<code>Semaphore</code>/<code>Condition</code>类 (这些对象可以像多线程那样，通过参数传递给各个进程)，用以同步进程，其用法与threading包中的同名类一致。所以，multiprocessing的很大一部份与threading使用同一套API，只不过换到了多进程的情境。但在使用这些共享API的时候，我们要注意以下几点:</p>
<ul>
<li>在UNIX平台上，当某个进程终结之后，该进程需要被其父进程调用wait，否则进程成为僵尸进程(Zombie)。所以，有必要对每个Process对象调用join()方法 (实际上等同于wait)。对于多线程来说，由于只有一个进程，所以不存在此必要性。</li>
<li>multiprocessing提供了threading包中没有的IPC(比如Pipe和Queue)，效率上更高。应优先考虑Pipe和Queue，避免使用<code>Lock</code>/<code>Event</code>/<code>Semaphore</code>/<code>Condition</code>等同步方式 (因为它们占据的不是用户进程的资源)。</li>
<li>多进程应该避免共享资源。在多线程中，我们可以比较容易地共享资源，比如使用全局变量或者传递参数。在多进程情况下，由于每个进程有自己独立的内存空间，以上方法并不合适。此时我们可以通过共享内存和Manager的方法来共享资源。但这样做提高了程序的复杂度，并因为同步的需要而降低了程序的效率。</li>
<li>在多进程下run方法启动相当于直接调用函数，并没有真正意义上使用多进程，这一点我们可以通过pid看的出来。而start启动却是真正意义上调用了多进程，同样我们可以通过pid看的出来</li>
</ul>
<p>Process.PID中保存有PID，如果进程还没有<code>start()</code>，则PID为None。</p>
<p>我们可以从下面的程序中看到Thread对象和Process对象在使用上的相似性与结果上的不同。各个线程和进程都做一件事：打印PID。但问题是，所有的任务在打印的时候都会向同一个标准输出(stdout)输出。这样输出的字符会混合在一起，无法阅读。使用Lock同步，在一个任务输出完成之后，再允许另一个任务输出，可以避免多个任务同时向终端输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import threading</span><br><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line"># Main</span><br><span class="line">print(&#x27;Main:&#x27;, os.getpid())</span><br><span class="line"></span><br><span class="line"># worker function</span><br><span class="line">def worker(sign, lock):</span><br><span class="line">    lock.acquire()</span><br><span class="line">    print(sign, os.getpid())</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Multi-thread</span><br><span class="line">record = []</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"># Multi-process</span><br><span class="line">record = []</span><br><span class="line">lock = multiprocessing.Lock()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    for i in range(5):</span><br><span class="line">        thread = threading.Thread(target=worker, args=(&#x27;thread&#x27;, lock))</span><br><span class="line">        thread.start()</span><br><span class="line">        record.append(thread)</span><br><span class="line"></span><br><span class="line">    for thread in record:</span><br><span class="line">        thread.join()</span><br><span class="line">    </span><br><span class="line">    for i in range(5):</span><br><span class="line">        process = multiprocessing.Process(target=worker, args=(&#x27;process&#x27;, lock))</span><br><span class="line">        process.start()</span><br><span class="line">        record.append(process)</span><br><span class="line">    </span><br><span class="line">    for process in record:</span><br><span class="line">        process.join()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Main: 10012</span><br><span class="line">thread 10012</span><br><span class="line">thread 10012</span><br><span class="line">thread 10012</span><br><span class="line">thread 10012</span><br><span class="line">thread 10012</span><br><span class="line">Main: 6052</span><br><span class="line">process 6052</span><br><span class="line">Main: 8080</span><br><span class="line">Main: 4284</span><br><span class="line">Main: 7240</span><br><span class="line">process 8080</span><br><span class="line">process 4284</span><br><span class="line">process 7240</span><br><span class="line">Main: 10044</span><br><span class="line">process 10044</span><br></pre></td></tr></table></figure>
<h3 id="Pipe和Queue"><a href="#Pipe和Queue" class="headerlink" title="Pipe和Queue"></a>Pipe和Queue</h3><p>正如我们在Linux多线程中介绍的管道PIPE和消息队列message queue，multiprocessing包中有Pipe类和Queue类来分别支持这两种IPC机制。Pipe和Queue可以用来传送常见的对象。</p>
<ol>
<li><p>Pipe可以是单向(half-duplex)，也可以是双向(duplex)。我们通过<code>mutiprocessing.Pipe(duplex=False)</code>创建单向管道 (默认为双向)。一个进程从PIPE一端输入对象，然后被PIPE另一端的进程接收，单向管道只允许管道一端的进程输入，而双向管道则允许从两端输入。</p>
<p>下面的程序展示了Pipe的使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mul</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proc1</span>(<span class="params">pipe</span>):</span><br><span class="line">    pipe.send(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;proc1 rec:&#x27;</span>, pipe.recv())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proc2</span>(<span class="params">pipe</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;proc2 rec:&#x27;</span>, pipe.recv())</span><br><span class="line">    pipe.send(<span class="string">&#x27;hello, too&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Build a pipe</span></span><br><span class="line">pipe = mul.Pipe()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># Pass an end of the pipe to process 1</span></span><br><span class="line">    p1 = mul.Process(target=proc1, args=(pipe[<span class="number">0</span>],))</span><br><span class="line">    <span class="comment"># Pass the other end of the pipe to process 2</span></span><br><span class="line">    p2 = mul.Process(target=proc2, args=(pipe[<span class="number">1</span>],))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proc2 rec: hello</span><br><span class="line">proc1 rec: hello, too</span><br></pre></td></tr></table></figure>
<p>这里的Pipe是双向的。Pipe对象建立的时候，返回一个含有两个元素的表，每个元素代表Pipe的一端(Connection对象)。我们对Pipe的某一端调用<code>send()</code>方法来传送对象，在另一端使用<code>recv()</code>来接收。</p>
</li>
<li><p>Queue与Pipe相类似，都是先进先出的结构。但Queue允许多个进程放入，多个进程从队列取出对象。Queue使用<code>mutiprocessing.Queue(maxsize)</code>创建，maxsize表示队列中可以存放对象的最大数量。</p>
<p>下面的程序展示了Queue的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import multiprocessing</span><br><span class="line">import time</span><br><span class="line">#==================</span><br><span class="line"># input worker</span><br><span class="line">def inputQ(queue):</span><br><span class="line">    info = str(os.getpid()) + &#x27;(put):&#x27; + str(time.time())</span><br><span class="line">    queue.put(info)</span><br><span class="line"></span><br><span class="line"># output worker</span><br><span class="line">def outputQ(queue,lock):</span><br><span class="line">    info = queue.get()</span><br><span class="line">    lock.acquire()</span><br><span class="line">    print (str(os.getpid()) + &#x27; get: &#x27; + info)</span><br><span class="line">    lock.release()</span><br><span class="line">#===================</span><br><span class="line"># Main</span><br><span class="line">record1 = []   # store input processes</span><br><span class="line">record2 = []   # store output processes</span><br><span class="line">lock  = multiprocessing.Lock()    # To prevent messy print</span><br><span class="line">queue = multiprocessing.Queue(3)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # input processes</span><br><span class="line">    for i in range(10):</span><br><span class="line">        process = multiprocessing.Process(target=inputQ,args=(queue,))</span><br><span class="line">        process.start()</span><br><span class="line">        record1.append(process)</span><br><span class="line">    </span><br><span class="line">    # output processes</span><br><span class="line">    for i in range(10):</span><br><span class="line">        process = multiprocessing.Process(target=outputQ,args=(queue,lock))</span><br><span class="line">        process.start()</span><br><span class="line">        record2.append(process)</span><br><span class="line">    </span><br><span class="line">    for p in record1:</span><br><span class="line">        p.join()</span><br><span class="line">    </span><br><span class="line">    queue.close()  # No more object will come, close the queue</span><br><span class="line">    </span><br><span class="line">    for p in record2:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">8572 get: 6300(put):1555486924.3676226</span><br><span class="line">8136 get: 3464(put):1555486924.412625</span><br><span class="line">9576 get: 9660(put):1555486924.5126307</span><br><span class="line">6936 get: 5064(put):1555486924.5976355</span><br><span class="line">10652 get: 8688(put):1555486924.5976355</span><br><span class="line">6992 get: 10988(put):1555486924.7526445</span><br><span class="line">6548 get: 6836(put):1555486924.7456443</span><br><span class="line">3504 get: 7284(put):1555486924.7666454</span><br><span class="line">8652 get: 4960(put):1555486924.8536503</span><br><span class="line">10868 get: 460(put):1555486924.8606508</span><br></pre></td></tr></table></figure>
<p>一些进程使用<code>put()</code>在Queue中放入字符串，这个字符串中包含PID和时间。另一些进程从Queue中取出，并打印自己的PID以及<code>get()</code>的字符串。</p>
</li>
</ol>
<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>进程池 (Process Pool)可以创建多个进程。这些进程就像是随时待命的士兵，准备执行任务(程序)。一个进程池中可以容纳多个待命的进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import multiprocessing as mul</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f(x):</span><br><span class="line">    return x ** 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    pool = mul.Pool(5)</span><br><span class="line">    rel = pool.map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])</span><br><span class="line">    print(rel)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>
<p>我们创建了一个容许5个进程的进程池 (Process Pool) 。Pool运行的每个进程都执行f()函数。我们利用<code>map()</code>方法，将<code>f()</code>函数作用到表的每个元素上。这与built-in的<code>map()</code>函数类似，只是这里用5个进程并行处理。如果进程运行结束后，还有需要处理的元素，那么进程会被用于重新运行<code>f()</code>函数。除了<code>map()</code>方法外，Pool还有下面的常用方法。</p>
<ul>
<li><code>apply_async(func,args)</code> 从进程池中取出一个进程执行func，args参数。它将返回一个AsyncResult的对象，你可以对该对象调用<code>get()</code>方法以获得结果。</li>
<li><code>close()</code> 进程池不再创建新的进程</li>
<li><code>join()</code> wait进程池中的全部进程。必须对Pool先调用<code>close()</code>方法才能join。</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>实例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line"># Value/Array</span><br><span class="line">def func1(a, arr):</span><br><span class="line">    a.value = 3.14</span><br><span class="line">    for i in range(len(arr)):</span><br><span class="line">        arr[i] = 0</span><br><span class="line">    a.value = 0</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    num = multiprocessing.Value(&#x27;d&#x27;, 1.0)  # num=0</span><br><span class="line">    arr = multiprocessing.Array(&#x27;i&#x27;, range(10))  # arr=range(10)</span><br><span class="line">    p = multiprocessing.Process(target=func1, args=(num, arr))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print (num.value)</span><br><span class="line">    print (arr[:])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.0</span><br><span class="line">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure>
<p>这里我们实际上只有主进程和Process对象代表的进程。我们在主进程的内存空间中创建共享的内存，也就是Value和Array两个对象。对象Value被设置成为双精度数(d), 并初始化为1.0。而Array则类似于C中的数组，有固定的类型(i, 也就是整数)。在Process进程中，我们修改了Value和Array对象。回到主程序，打印出结果，主程序也看到了两个对象的改变，说明资源确实在两个进程之间共享。</p>
<h3 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h3><p>Manager是通过共享进程的方式共享数据。Manager管理的共享数据类型有：Value、Array、dict、list、Lock、Semaphore等等，同时Manager还可以共享类的实例对象。</p>
<p>实例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process,Manager</span><br><span class="line">def func1(shareList,shareValue,shareDict,lock):</span><br><span class="line">    with lock:</span><br><span class="line">        shareValue.value+=1</span><br><span class="line">        shareDict[1]=&#x27;1&#x27;</span><br><span class="line">        shareDict[2]=&#x27;2&#x27;</span><br><span class="line">        for i in xrange(len(shareList)):</span><br><span class="line">            shareList[i]+=1</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    manager=Manager()</span><br><span class="line">    list1=manager.list([1,2,3,4,5])</span><br><span class="line">    dict1=manager.dict()</span><br><span class="line">    array1=manager.Array(&#x27;i&#x27;,range(10))</span><br><span class="line">    value1=manager.Value(&#x27;i&#x27;,1)</span><br><span class="line">    lock=manager.Lock()</span><br><span class="line">    proc=[Process(target=func1,args=(list1,value1,dict1,lock)) for i in xrange(20)]</span><br><span class="line">    for p in proc:</span><br><span class="line">        p.start()</span><br><span class="line">    for p in proc:</span><br><span class="line">        p.join()</span><br><span class="line">    print list1</span><br><span class="line">    print dict1</span><br><span class="line">    print array1</span><br><span class="line">    print value1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[21, 22, 23, 24, 25]</span><br><span class="line">&#123;1: &#x27;1&#x27;, 2: &#x27;2&#x27;&#125;</span><br><span class="line">array(&#x27;i&#x27;, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">Value(&#x27;i&#x27;, 21)</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2019\11\20\7个Python数据分析工具\" rel="bookmark">7个Python数据分析工具</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2019\11\20\Python-collections四种高性能数据类型\" rel="bookmark">Python collections四种高性能数据类型</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2017\07\10\Python之copy与deepcopy\" rel="bookmark">Python之copy与deepcopy</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div>一分一毛，也是心意。</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Run-Qing Chen 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Run-Qing Chen 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Run-Qing Chen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://blog.rexking6.top/2021/07/01/Python%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" title="Python性能分析">https://blog.rexking6.top/2021/07/01/Python性能分析/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%BC%80%E5%8F%91/" rel="tag"># 开发</a>
              <a href="/tags/Python/" rel="tag"># Python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/01/%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90RCA/" rel="prev" title="根因分析RCA">
      <i class="fa fa-chevron-left"></i> 根因分析RCA
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/04/%E5%81%A5%E8%BA%AB/" rel="next" title="健身">
      健身 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

    <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E6%80%9D%E8%B7%AF"><span class="nav-number">2.</span> <span class="nav-text">整体思路</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="nav-number">3.</span> <span class="nav-text">性能分析工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU"><span class="nav-number">3.1.</span> <span class="nav-text">CPU</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">3.1.1.</span> <span class="nav-text">例子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cProfile"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">cProfile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vmprof"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">vmprof</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98"><span class="nav-number">3.2.</span> <span class="nav-text">内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">例子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#memory-profiler"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">memory_profiler</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">4.</span> <span class="nav-text">性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU-1"><span class="nav-number">4.1.</span> <span class="nav-text">CPU</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="nav-number">4.1.1.</span> <span class="nav-text">优化方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#numba%E4%BE%8B%E5%AD%90"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">numba例子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO"><span class="nav-number">4.2.</span> <span class="nav-text">IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">4.2.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-number">4.2.2.</span> <span class="nav-text">说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">创建对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">对象方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">使用说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="nav-number">4.2.2.4.</span> <span class="nav-text">应用说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.2.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-number">5.</span> <span class="nav-text">并行与并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91-concurrency-%E5%92%8C%E5%B9%B6%E8%A1%8C-parallelism"><span class="nav-number">5.1.</span> <span class="nav-text">并发(concurrency)和并行(parallelism)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">5.2.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="nav-number">5.2.1.</span> <span class="nav-text">多线程的数据共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E9%98%BB%E5%A1%9E%E5%BC%8FI-O%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.2.2.</span> <span class="nav-text">在阻塞式I&#x2F;O中使用多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Queue"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">Queue</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E7%B1%BB%E4%BB%BB%E5%8A%A1%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.2.3.</span> <span class="nav-text">为什么这类任务可以考虑多线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C"><span class="nav-number">5.3.</span> <span class="nav-text">并行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Pipe%E5%92%8CQueue"><span class="nav-number">5.3.1.</span> <span class="nav-text">Pipe和Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.3.2.</span> <span class="nav-text">进程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">5.3.3.</span> <span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Manager"><span class="nav-number">5.3.4.</span> <span class="nav-text">Manager</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Run-Qing Chen"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Run-Qing Chen</p>
  <div class="site-description" itemprop="description">覆苍天以为衾，卧大地以为庐。</div>
</div>


   <div class="feed-link motion-element">
     <a href="/atom.xml" rel="alternate">
       <i class="fa fa-rss"></i>
       RSS
     </a>
   </div>
 
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">241</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">85</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">84</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RexKing6" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RexKing6" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1010026261@qq.com" title="E-Mail → mailto:1010026261@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://zhimi.vercel.app/index_zh-cn.html" title="https:&#x2F;&#x2F;zhimi.vercel.app&#x2F;index_zh-cn.html" rel="noopener" target="_blank">執迷</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://whitepuffer.github.io/" title="https:&#x2F;&#x2F;whitepuffer.github.io&#x2F;" rel="noopener" target="_blank">江斓</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kexue.fm/" title="https:&#x2F;&#x2F;kexue.fm&#x2F;" rel="noopener" target="_blank">科学空间</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yongyuan.name/" title="https:&#x2F;&#x2F;yongyuan.name&#x2F;" rel="noopener" target="_blank">袁勇</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/abcjennifer" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;abcjennifer" rel="noopener" target="_blank">Rachel Zhang</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://dmkf.xyz/" title="http:&#x2F;&#x2F;dmkf.xyz&#x2F;" rel="noopener" target="_blank">代码咖啡</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://wuxiaolong.me/" title="http:&#x2F;&#x2F;wuxiaolong.me&#x2F;" rel="noopener" target="_blank">吴小龙同学</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.tennfy.com/" title="http:&#x2F;&#x2F;www.tennfy.com&#x2F;" rel="noopener" target="_blank">TENNFY WU</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fab fa-accessible-icon"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Run-Qing Chen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">4.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">64:09</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"6XDsO3aHIjDk3nV6eLJCufbl-MdYXbMMI","app_key":"YK4qOc0TpkazN6exhuqsnwmB","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

  

</body>
</html>
