<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.rexking6.top","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#37c6c0","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"YS7HT61SEB","apiKey":"0fd1eba022e7883c76ff4a71aee2acdc","indexName":"blog_NAME","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"找不到关于 ${query} 的文章","hits_stats":"共找到 ${hits} 篇文章，花了 ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="...">
<meta property="og:type" content="article">
<meta property="og:title" content="Transformer">
<meta property="og:url" content="https://blog.rexking6.top/2021/07/20/Transformer/">
<meta property="og:site_name" content="RexKing6&#39;s Note">
<meta property="og:description" content="...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.rexking6.top/img/0 (2">
<meta property="og:image" content="https://image.rexking6.top/img/0.jpg">
<meta property="og:image" content="https://image.rexking6.top/img/0 (1">
<meta property="og:image" content="https://image.rexking6.top/img/0 (5">
<meta property="og:image" content="https://image.rexking6.top/img/0 (7">
<meta property="og:image" content="https://image.rexking6.top/img/0 (1">
<meta property="og:image" content="https://image.rexking6.top/img/0 (8">
<meta property="og:image" content="https://image.rexking6.top/img/0 (4">
<meta property="og:image" content="https://image.rexking6.top/img/0 (6">
<meta property="og:image" content="https://image.rexking6.top/img/0 (9">
<meta property="og:image" content="https://image.rexking6.top/img/0 (10">
<meta property="og:image" content="https://image.rexking6.top/img/0 (16">
<meta property="og:image" content="https://image.rexking6.top/img/0 (11">
<meta property="og:image" content="https://image.rexking6.top/img/0 (12">
<meta property="og:image" content="https://image.rexking6.top/img/0 (14">
<meta property="og:image" content="https://image.rexking6.top/img/0 (15">
<meta property="og:image" content="https://image.rexking6.top/img/0.gif">
<meta property="og:image" content="https://image.rexking6.top/img/0 (1">
<meta property="og:image" content="https://image.rexking6.top/img/0 (8">
<meta property="og:image" content="https://image.rexking6.top/img/0 (9">
<meta property="og:image" content="https://image.rexking6.top/img/0 (5">
<meta property="og:image" content="https://image.rexking6.top/img/0 (11">
<meta property="og:image" content="https://image.rexking6.top/img/0 (7">
<meta property="og:image" content="https://image.rexking6.top/img/0 (6">
<meta property="og:image" content="https://image.rexking6.top/img/0 (3">
<meta property="og:image" content="https://image.rexking6.top/img/0 (4">
<meta property="og:image" content="https://image.rexking6.top/img/0 (2">
<meta property="og:image" content="https://image.rexking6.top/img/0 (10">
<meta property="og:image" content="https://image.rexking6.top/img/0 (13">
<meta property="og:image" content="https://image.rexking6.top/img/0 (12">
<meta property="og:image" content="https://image.rexking6.top/img/0 (14">
<meta property="og:image" content="https://image.rexking6.top/img/0 (15">
<meta property="og:image" content="https://image.rexking6.top/img/0 (17">
<meta property="og:image" content="https://image.rexking6.top/img/0 (16">
<meta property="og:image" content="https://image.rexking6.top/img/0 (18">
<meta property="og:image" content="https://image.rexking6.top/img/0 (21">
<meta property="og:image" content="https://image.rexking6.top/img/0 (19">
<meta property="og:image" content="https://image.rexking6.top/img/0 (20">
<meta property="og:image" content="https://image.rexking6.top/img/0 (23">
<meta property="og:image" content="https://image.rexking6.top/img/0 (22">
<meta property="og:image" content="https://image.rexking6.top/img/0 (25">
<meta property="og:image" content="https://image.rexking6.top/img/0 (24">
<meta property="article:published_time" content="2021-07-20T03:18:51.000Z">
<meta property="article:modified_time" content="2023-04-04T15:55:30.007Z">
<meta property="article:author" content="Run-Qing Chen">
<meta property="article:tag" content="深度学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.rexking6.top/img/0 (2">

<link rel="canonical" href="https://blog.rexking6.top/2021/07/20/Transformer/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Transformer | RexKing6's Note</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="RexKing6's Note" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RexKing6's Note</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/rexking6" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.rexking6.top/2021/07/20/Transformer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Run-Qing Chen">
      <meta itemprop="description" content="覆苍天以为衾，卧大地以为庐。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RexKing6's Note">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Transformer
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-20 11:18:51" itemprop="dateCreated datePublished" datetime="2021-07-20T11:18:51+08:00">2021-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-04 23:55:30" itemprop="dateModified" datetime="2023-04-04T23:55:30+08:00">2023-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          
            <span id="/2021/07/20/Transformer/" class="post-meta-item leancloud_visitors" data-flag-title="Transformer" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>30k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>综合转载以下文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/fsUWz5bkts1qUl6tUbgkwQ">Transformer各层网络结构详解！</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/AA_AIpdliEkic-DtASFJ6Q">放弃幻想，全面拥抱Transformer：自然语言处理三大特征抽取器（CNN/RNN/TF）比较</a></li>
</ul>
<h1 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h1><p><strong>《Attention Is All You Need》是一篇Google提出的将Attention思想发挥到极致的论文。</strong></p>
<p><img src="https://image.rexking6.top/img/0 (2" alt="">.png)</p>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1706.03762.pdf">https://arxiv.org/pdf/1706.03762.pdf</a></p>
<p><strong>这篇论文中提出一个全新的模型，叫 Transformer，抛弃了以往深度学习任务里面使用到的 CNN 和 RNN。</strong>目前大热的Bert就是基于Transformer构建的，这个模型广泛应用于NLP领域，例如机器翻译，问答系统，文本摘要和语音识别等等方向。</p>
<h2 id="Transformer-结构"><a href="#Transformer-结构" class="headerlink" title="Transformer 结构"></a>Transformer 结构</h2><h3 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h3><p>Transformer的结构和Attention模型一样，Transformer模型中也采用了 encoer-decoder 架构。但其结构相比于Attention更加复杂，论文中encoder层由6个encoder堆叠在一起，decoder层也一样。</p>
<p>不了解Attention模型的，可以回顾之前的文章：Attention（<a target="_blank" rel="noopener" href="https://www.yanxishe.com/blogDetail/14422）">https://www.yanxishe.com/blogDetail/14422）</a></p>
<p><img src="https://image.rexking6.top/img/0.jpg" alt=""></p>
<p>每一个encoder和decoder的内部结构如下图：</p>
<p><img src="https://image.rexking6.top/img/0 (1" alt="">.jpg)</p>
<ul>
<li>encoder，包含两层，一个self-attention层和一个前馈神经网络，self-attention能帮助当前节点不仅仅只关注当前的词，从而能获取到上下文的语义。</li>
<li>decoder也包含encoder提到的两层网络，但是在这两层中间还有一层attention层，帮助当前节点获取到当前需要关注的重点内容。</li>
</ul>
<h3 id="Encoder层结构"><a href="#Encoder层结构" class="headerlink" title="Encoder层结构"></a>Encoder层结构</h3><p>首先，模型需要对输入的数据进行一个embedding操作，也可以理解为类似w2c的操作，enmbedding结束之后，输入到encoder层，self-attention处理完数据后把数据送给前馈神经网络，前馈神经网络的计算可以并行，得到的输出会输入到下一个encoder。</p>
<p><img src="https://image.rexking6.top/img/0 (5" alt="">.png)</p>
<h4 id="Positional-Encoding"><a href="#Positional-Encoding" class="headerlink" title="Positional Encoding"></a>Positional Encoding</h4><p>transformer模型中缺少一种解释输入序列中单词顺序的方法，它跟序列模型还不不一样。为了处理这个问题，transformer给encoder层和decoder层的输入添加了一个额外的向量Positional Encoding，维度和embedding的维度一样，这个向量采用了一种很独特的方法来让模型学习到这个值，这个向量能决定当前词的位置，或者说在一个句子中不同的词之间的距离。这个位置向量的具体计算方法有很多种，论文中的计算方法如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& P E(p o s, 2 i)=\sin \left(\frac{p o s}{10000^{\frac{2 i}{d_{\text {model }}}}}\right) \\
& P E(p o s, 2 i+1)=\cos \left(\frac{p o s}{10000^{\frac{2 i}{d_{\text {model }}}}}\right)
\end{aligned}</script><p>其中pos是指当前词在句子中的位置，i是指向量中每个值的index，可以看出，在<strong>偶数位置，使用正弦编码，在奇数位置，使用余弦编码</strong>。</p>
<p>最后把这个Positional Encoding与embedding的值相加，作为输入送到下一层。</p>
<p><img src="https://image.rexking6.top/img/0 (7" alt="">.png)</p>
<h4 id="Self-Attention"><a href="#Self-Attention" class="headerlink" title="Self-Attention"></a>Self-Attention</h4><p>接下来我们详细看一下self-attention，其思想和attention类似，但是self-attention是Transformer用来将其他相关单词的“理解”转换成我们正在处理的单词的一种思路，我们看个例子：</p>
<p><em>The animal didn’t cross the street because it was too tired</em></p>
<p>这里的 it 到底代表的是 animal 还是 street 呢，对于我们来说能很简单的判断出来，但是对于机器来说，是很难判断的，self-attention就能够让机器把 it 和 animal 联系起来，接下来我们看下详细的处理过程。</p>
<ol>
<li><p>首先，self-attention会计算出三个新的向量，在论文中，向量的维度是512维，我们把这三个向量分别称为Query、Key、Value，这三个向量是用embedding向量与一个矩阵相乘得到的结果，这个矩阵是随机初始化的，维度为（64，512）注意第二个维度需要和embedding的维度一样，其值在BP的过程中会一直进行更新，得到的这三个向量的维度是64。</p>
<p><img src="https://image.rexking6.top/img/0 (1" alt="">.png)</p>
</li>
<li><p>计算self-attention的分数值，该分数值决定了当我们在某个位置encode一个词时，对输入句子的其他部分的关注程度。这个分数值的计算方法是Query与Key做点乘，以下图为例，首先我们需要针对Thinking这个词，计算出其他词对于该词的一个分数值，首先是针对于自己本身即q1·k1，然后是针对于第二个词即q1·k2。</p>
<p><img src="https://image.rexking6.top/img/0 (8" alt="">.png)</p>
</li>
<li><p>接下来，把点成的结果除以一个常数，这里我们除以8，这个值一般是采用上文提到的矩阵的第一个维度的开方即64的开方8，当然也可以选择其他的值，然后把得到的结果做一个softmax的计算。得到的结果即是每个词对于当前位置的词的相关性大小，当然，当前位置的词相关性肯定会会很大。</p>
<p><img src="https://image.rexking6.top/img/0 (4" alt="">.png)</p>
<p>这一步修正还有进一步的解释，即如果经过 Softmax 归一化后模型稳定性存在问题。怎么理解？如果假设 Q 和 K 中的每个向量的每一维数据都具有零均值、单位方差，这样输入数据是具有稳定性的，那么如何让「暗含信息 1」计算后仍然具有稳定性呢？即运算结果依然保持零均值、单位方差，就是除以$\sqrt{d_k}$。</p>
</li>
<li><p>下一步就是把Value和softmax得到的值进行相乘，并相加，得到的结果即是self-attetion在当前节点的值。</p>
<p><img src="https://image.rexking6.top/img/0 (6" alt="">.png)</p>
</li>
</ol>
<p>在实际的应用场景，为了提高计算速度，我们采用的是矩阵的方式，直接计算出Query, Key, Value的矩阵，然后把embedding的值与三个矩阵直接相乘，把得到的新矩阵 Q 与 K 相乘，乘以一个常数，做softmax操作，最后乘上 V 矩阵。</p>
<p><strong>这种通过 query 和 key 的相似性程度来确定 value 的权重分布的方法被称为scaled dot-product attention。</strong></p>
<p><img src="https://image.rexking6.top/img/0 (9" alt="">.png)</p>
<p><img src="https://image.rexking6.top/img/0 (10" alt="">.png)</p>
<h4 id="Multi-Headed-Attention"><a href="#Multi-Headed-Attention" class="headerlink" title="Multi-Headed Attention"></a>Multi-Headed Attention</h4><p>这篇论文更牛逼的地方是给self-attention加入了另外一个机制，被称为“multi-headed” attention，该机制理解起来很简单，<strong>就是说不仅仅只初始化一组Q、K、V的矩阵，而是初始化多组，tranformer是使用了8组</strong>，所以最后得到的结果是8个矩阵。</p>
<p><img src="https://image.rexking6.top/img/0 (16" alt="">.png)</p>
<p><img src="https://image.rexking6.top/img/0 (11" alt="">.png)</p>
<h4 id="Layer-normalization"><a href="#Layer-normalization" class="headerlink" title="Layer normalization"></a>Layer normalization</h4><p>在transformer中，每一个子层（self-attetion，Feed Forward Neural Network）之后都会接一个残缺模块，并且有一个Layer normalization。</p>
<p><img src="https://image.rexking6.top/img/0 (12" alt="">.png)</p>
<p>Normalization有很多种，但是它们都有一个共同的目的，那就是把输入转化成均值为0方差为1的数据。我们在把数据送入激活函数之前进行normalization（归一化），因为我们不希望输入数据落在激活函数的饱和区。</p>
<p><strong>LN 是在每一个样本上计算均值和方差</strong>，而不是BN那种在批方向计算均值和方差。公式如下：</p>
<script type="math/tex; mode=display">
L N\left(x_i\right)=\alpha * \frac{x_i-\mu_L}{\sqrt{\sigma_L^2+\varepsilon}}+\beta</script><p><img src="https://image.rexking6.top/img/0 (14" alt="">.png)</p>
<h4 id="Feed-Forward-Neural-Network"><a href="#Feed-Forward-Neural-Network" class="headerlink" title="Feed Forward Neural Network"></a>Feed Forward Neural Network</h4><p>这给我们留下了一个小的挑战，前馈神经网络没法输入 8 个矩阵呀，这该怎么办呢？所以我们需要一种方式，把 8 个矩阵降为 1 个，首先，我们把 8 个矩阵连在一起，这样会得到一个大的矩阵，再随机初始化一个矩阵和这个组合好的矩阵相乘，最后得到一个最终的矩阵。</p>
<p><img src="https://image.rexking6.top/img/0 (15" alt="">.png)</p>
<h3 id="Decoder层结构"><a href="#Decoder层结构" class="headerlink" title="Decoder层结构"></a>Decoder层结构</h3><p>根据上面的总体结构图可以看出，decoder部分其实和encoder部分大同小异，刚开始也是先添加一个位置向量Positional Encoding，方法和 2.2.1 节一样，接下来接的是masked mutil-head attetion，这里的mask也是transformer一个很关键的技术，下面我们会进行一一介绍。</p>
<p>其余的层结构与Encoder一样，请参考Encoder层结构。</p>
<h4 id="masked-mutil-head-attetion"><a href="#masked-mutil-head-attetion" class="headerlink" title="masked mutil-head attetion"></a>masked mutil-head attetion</h4><p><strong>mask 表示掩码，它对某些值进行掩盖，使其在参数更新时不产生效果</strong>。Transformer 模型里面涉及两种 mask，分别是 padding mask 和 sequence mask。其中，padding mask 在所有的 scaled dot-product attention 里面都需要用到，而 sequence mask 只有在 decoder 的 self-attention 里面用到。</p>
<ol>
<li><p><strong>padding mask</strong></p>
<p>什么是 padding mask 呢？因为每个批次输入序列长度是不一样的也就是说，我们要对输入序列进行对齐。具体来说，就是给在较短的序列后面填充 0。但是如果输入的序列太长，则是截取左边的内容，把多余的直接舍弃。因为这些填充的位置，其实是没什么意义的，所以我们的attention机制不应该把注意力放在这些位置上，所以我们需要进行一些处理。</p>
<p>具体的做法是，把这些位置的值加上一个非常大的负数(负无穷)，这样的话，经过 softmax，这些位置的概率就会接近0！</p>
<p>而我们的 padding mask 实际上是一个张量，每个值都是一个Boolean，值为 false 的地方就是我们要进行处理的地方。</p>
</li>
<li><p><strong>Sequence mask</strong></p>
<p>文章前面也提到，sequence mask 是为了使得 decoder 不能看见未来的信息。也就是对于一个序列，在 time_step 为 t 的时刻，我们的解码输出应该只能依赖于 t 时刻之前的输出，而不能依赖 t 之后的输出。因此我们需要想一个办法，把 t 之后的信息给隐藏起来。</p>
<p>那么具体怎么做呢？也很简单：<strong>产生一个上三角矩阵，上三角的值全为0。把这个矩阵作用在每一个序列上，就可以达到我们的目的</strong>。</p>
<ul>
<li>对于 decoder 的 self-attention，里面使用到的 scaled dot-product attention，同时需要padding mask 和 sequence mask 作为 attn_mask，具体实现就是两个mask相加作为attn_mask。</li>
<li>其他情况，attn_mask 一律等于 padding mask。</li>
</ul>
</li>
</ol>
<h4 id="Output层"><a href="#Output层" class="headerlink" title="Output层"></a>Output层</h4><p>当decoder层全部执行完毕后，怎么把得到的向量映射为我们需要的词呢，很简单，只需要在结尾再添加一个全连接层和softmax层，假如我们的词典是1w个词，那最终softmax会输入1w个词的概率，概率值最大的对应的词就是我们最终的结果。</p>
<h3 id="动态流程图"><a href="#动态流程图" class="headerlink" title="动态流程图"></a>动态流程图</h3><p>编码器通过处理输入序列开启工作。顶端编码器的输出之后会变转化为一个包含向量K（键向量）和V（值向量）的注意力向量集 ，<strong>这是并行化操作</strong>。这些向量将被每个解码器用于自身的“编码-解码注意力层”，而这些层可以帮助解码器关注输入序列哪些位置合适：</p>
<p><img src="https://image.rexking6.top/img/0.gif" alt=""></p>
<p>在完成编码阶段后，则开始解码阶段。解码阶段的每个步骤都会输出一个输出序列（在这个例子里，是英语翻译的句子）的元素。</p>
<p>接下来的步骤重复了这个过程，直到到达一个特殊的终止符号，它表示transformer的解码器已经完成了它的输出。每个步骤的输出在下一个时间步被提供给底端解码器，并且就像编码器之前做的那样，这些解码器会输出它们的解码结果 。</p>
<p><img src="https://image.rexking6.top/img/0 (1" alt="">.gif)</p>
<h2 id="Transformer为什么需要进行Multi-head-Attention？"><a href="#Transformer为什么需要进行Multi-head-Attention？" class="headerlink" title="Transformer为什么需要进行Multi-head Attention？"></a>Transformer为什么需要进行Multi-head Attention？</h2><p>原论文中说到进行Multi-head Attention的原因是将模型分为多个头，形成多个子空间，可以让模型去关注不同方面的信息，最后再将各个方面的信息综合起来。其实直观上也可以想到，如果自己设计这样的一个模型，必然也不会只做一次attention，多次attention综合的结果至少能够起到增强模型的作用，也可以类比CNN中同时使用<strong>多个卷积核</strong>的作用，直观上讲，多头的注意力<strong>有助于网络捕捉到更丰富的特征/信息</strong>。</p>
<h2 id="Transformer相比于RNN-LSTM，有什么优势，为什么？"><a href="#Transformer相比于RNN-LSTM，有什么优势，为什么？" class="headerlink" title="Transformer相比于RNN/LSTM，有什么优势，为什么？"></a>Transformer相比于RNN/LSTM，有什么优势，为什么？</h2><ol>
<li><p>RNN系列的模型，并行计算能力很差。RNN并行计算的问题就出在这里，因为 T 时刻的计算依赖 T-1 时刻的隐层计算结果，而 T-1 时刻的计算依赖 T-2 时刻的隐层计算结果，如此下去就形成了所谓的序列依赖关系。</p>
</li>
<li><p>Transformer的特征抽取能力比RNN系列的模型要好。</p>
<p>具体实验对比可以参考：放弃幻想，全面拥抱Transformer：自然语言处理三大特征抽取器（CNN/RNN/TF）比较</p>
<p>但是值得注意的是，并不是说Transformer就能够完全替代RNN系列的模型了，任何模型都有其适用范围，同样的，RNN系列模型在很多任务上还是首选，熟悉各种模型的内部原理，知其然且知其所以然，才能遇到新任务时，快速分析这时候该用什么样的模型，该怎么做好。</p>
</li>
</ol>
<h2 id="为什么说Transformer可以代替seq2seq？"><a href="#为什么说Transformer可以代替seq2seq？" class="headerlink" title="为什么说Transformer可以代替seq2seq？"></a>为什么说Transformer可以代替seq2seq？</h2><p><strong>seq2seq缺点</strong>：这里用代替这个词略显不妥当，seq2seq虽已老，但始终还是有其用武之地，seq2seq最大的问题在于<strong>将Encoder端的所有信息压缩到一个固定长度的向量中</strong>，并将其作为Decoder端首个隐藏状态的输入，来预测Decoder端第一个单词(token)的隐藏状态。在输入序列比较长的时候，这样做显然会损失Encoder端的很多信息，而且这样一股脑的把该固定向量送入Decoder端，Decoder端不能够关注到其想要关注的信息。</p>
<p><strong>Transformer优点</strong>：transformer不但对seq2seq模型这两点缺点有了实质性的改进(多头交互式attention模块)，而且还引入了self-attention模块，让源序列和目标序列首先“自关联”起来，这样的话，源序列和目标序列自身的embedding表示所蕴含的信息更加丰富，而且后续的FFN层也增强了模型的表达能力，并且Transformer并行计算的能力是远远超过seq2seq系列的模型，因此我认为这是transformer优于seq2seq模型的地方。</p>
<h1 id="CNN-RNN-TF比较"><a href="#CNN-RNN-TF比较" class="headerlink" title="CNN/RNN/TF比较"></a>CNN/RNN/TF比较</h1><p>如果对目前 NLP 里的三大特征抽取器的未来走向趋势做个宏观判断的话，我的判断是这样的：RNN人老珠黄，已经基本完成它的历史使命，将来会逐步退出历史舞台；CNN 如果改造得当，将来还是有希望有自己在 NLP 领域的一席之地，如果改造成功程度超出期望，那么还有一丝可能作为割据一方的军阀，继续生存壮大，当然我认为这个希望不大，可能跟宋小宝打篮球把姚明打哭的概率相当；而新欢 Transformer 明显会很快成为 NLP 里担当大任的最主流的特征抽取器。</p>
<p>至于将来是否会出现新的特征抽取器，一枪将 Tranformer 挑落马下，继而取而代之成为新的特征抽取山大王？这种担忧其实是挺有必要的，毕竟李商隐在一千年前就告诫过我们说：「君恩如水向东流，得宠忧移失宠愁。莫向樽前奏花落，凉风只在殿西头。」当然这首诗看样子目前送给 RNN 是比较贴切的，至于未来 Transformer 是否会失宠？这个问题的答案基本可以是肯定的，无非这个时刻的来临是 3 年之后，还是 1 年之后出现而已。</p>
<p>当然，我希望如果是在读这篇文章的你，或者是我，在未来的某一天，从街头拉来一位长相普通的淑女，送到韩国整容，一不小心偏离流水线整容工业的美女模板，整出一位天香国色的绝色，来把 Transformer 打入冷宫，那是最好不过。但是在目前的状态下，即使是打着望远镜，貌似还没有看到有这种资质的候选人出现在我们的视野之内。</p>
<p>我知道如果是一位严谨的研发人员，不应该在目前局势还没那么明朗的时候做出如上看似有些武断的明确结论，所以这种说法可能会引起争议。但是这确实就是我目前的真实想法，至于根据什么得出的上述判断？这种判断是否有依据？依据是否充分？相信你在看完这篇文章可以有个属于自己的结论。</p>
<p>可能谈到这里，有些平常吃亏吃的少所以喜欢挑刺的同学会质疑说：你凭什么说 NLP 的典型特征抽取器就这三种呢？你置其它知名的特征抽取器比如 Recursive NN 于何地? 嗯，是，很多介绍 NLP 重要进展的文章里甚至把 Recursive NN 当做一项 NLP 里的重大进展，除了它，还有其它的比如 Memory Network 也享受这种部局级尊贵待遇。但是我一直都不太看好这两个技术，而且不看好很多年了，目前情形更坚定了这个看法。而且我免费奉劝你一句，没必要在这两个技术上浪费时间，至于为什么，因为跟本文主题无关，以后有机会再详细说。</p>
<p>上面是结论，下面，我们正式进入举证阶段。</p>
<h2 id="战场侦查：NLP-任务的特点及任务类型"><a href="#战场侦查：NLP-任务的特点及任务类型" class="headerlink" title="战场侦查：NLP 任务的特点及任务类型"></a>战场侦查：NLP 任务的特点及任务类型</h2><p><img src="https://image.rexking6.top/img/0 (8" alt="">.jpg)</p>
<p>NLP 任务的特点和图像有极大的不同，上图展示了一个例子，NLP 的输入往往是一句话或者一篇文章，所以它有几个特点：首先，输入是个一维线性序列，这个好理解；其次，输入是不定长的，有的长有的短，而这点其实对于模型处理起来也会增加一些小麻烦；再次，单词或者子句的相对位置关系很重要，两个单词位置互换可能导致完全不同的意思。</p>
<p>如果你听到我对你说：「你欠我那一千万不用还了」和「我欠你那一千万不用还了」，你听到后分别是什么心情？两者区别了解一下；另外，句子中的长距离特征对于理解语义也非常关键，例子参考上图标红的单词，特征抽取器能否具备长距离特征捕获能力这一点对于解决 NLP 任务来说也是很关键的。</p>
<p>上面这几个特点请记清，一个特征抽取器是否适配问题领域的特点，有时候决定了它的成败，而很多模型改进的方向，其实就是改造得使得它更匹配领域问题的特性。这也是为何我在介绍 RNN、CNN、Transformer 等特征抽取器之前，先说明这些内容的原因。</p>
<p>NLP 是个很宽泛的领域，包含了几十个子领域，理论上只要跟语言处理相关，都可以纳入这个范围。但是如果我们对大量 NLP 任务进行抽象的话，会发现绝大多数 NLP 任务可以归结为几大类任务。两个看似差异很大的任务，在解决任务的模型角度，可能完全是一样的。</p>
<p><img src="https://image.rexking6.top/img/0 (9" alt="">.jpg)</p>
<p>通常而言，绝大部分 NLP 问题可以归入上图所示的四类任务中：一类是序列标注，这是最典型的 NLP 任务，比如中文分词，词性标注，命名实体识别，语义角色标注等都可以归入这一类问题，它的特点是句子中每个单词要求模型根据上下文都要给出一个分类类别。第二类是分类任务，比如我们常见的文本分类，情感计算等都可以归入这一类。它的特点是不管文章有多长，总体给出一个分类类别即可。</p>
<p>第三类任务是句子关系判断，比如 Entailment，QA，语义改写，自然语言推理等任务都是这个模式，它的特点是给定两个句子，模型判断出两个句子是否具备某种语义关系；第四类是生成式任务，比如机器翻译，文本摘要，写诗造句，看图说话等都属于这一类。它的特点是输入文本内容后，需要自主生成另外一段文字。</p>
<p>解决这些不同的任务，从模型角度来讲什么最重要？是特征抽取器的能力。尤其是深度学习流行开来后，这一点更凸显出来。因为深度学习最大的优点是「端到端（end to end）」，当然这里不是指的从客户端到云端，意思是以前研发人员得考虑设计抽取哪些特征，而端到端时代后，这些你完全不用管，把原始输入扔给好的特征抽取器，它自己会把有用的特征抽取出来。</p>
<p>身为资深 Bug 制造者和算法工程师，你现在需要做的事情就是：选择一个好的特征抽取器，选择一个好的特征抽取器，选择一个好的特征抽取器，喂给它大量的训练数据，设定好优化目标（loss function），告诉它你想让它干嘛…….. 然后你觉得你啥也不用干等结果就行了是吧？那你是我见过的整个宇宙中最乐观的人……. 你大量时间其实是用在调参上…….。</p>
<p>从这个过程可以看出，如果我们有个强大的特征抽取器，那么中初级算法工程师沦为调参侠也就是个必然了，在 AutoML（自动那啥）流行的年代，也许以后你想当调参侠而不得，李斯说的「吾欲与若复牵黄犬，俱出上蔡东门逐狡兔，岂可得乎！」请了解一下。</p>
<p>所以请珍惜你半夜两点还在调整超参的日子吧，因为对于你来说有一个好消息一个坏消息，好消息是：对于你来说可能这样辛苦的日子不多了！坏消息是：对于你来说可能这样辛苦的日子不多了！！！那么怎么才能成为算法高手？你去设计一个更强大的特征抽取器呀。</p>
<p>下面开始分叙三大特征抽取器。</p>
<h2 id="沙场老将-RNN：廉颇老矣，尚能饭否"><a href="#沙场老将-RNN：廉颇老矣，尚能饭否" class="headerlink" title="沙场老将 RNN：廉颇老矣，尚能饭否"></a>沙场老将 RNN：廉颇老矣，尚能饭否</h2><p><img src="https://image.rexking6.top/img/0 (5" alt="">.jpg)</p>
<p>RNN 模型我估计大家都熟悉，就不详细介绍了，模型结构参考上图，核心是每个输入对应隐层节点，而隐层节点之间形成了线性序列，信息由前向后在隐层之间逐步向后传递。我们下面直接进入我想讲的内容。</p>
<h3 id="为何-RNN-能够成为解决-NLP-问题的主流特征抽取器"><a href="#为何-RNN-能够成为解决-NLP-问题的主流特征抽取器" class="headerlink" title="为何 RNN 能够成为解决 NLP 问题的主流特征抽取器"></a>为何 RNN 能够成为解决 NLP 问题的主流特征抽取器</h3><p>我们知道，RNN 自从引入 NLP 界后，很快就成为吸引眼球的明星模型，在 NLP 各种任务中被广泛使用。但是原始的 RNN 也存在问题，它采取线性序列结构不断从前往后收集输入信息，但这种线性序列结构在反向传播的时候存在优化困难问题，因为反向传播路径太长，容易导致严重的梯度消失或梯度爆炸问题。</p>
<p>为了解决这个问题，后来引入了 LSTM 和 GRU 模型，通过增加中间状态信息直接向后传播，以此缓解梯度消失问题，获得了很好的效果，于是很快 LSTM 和 GRU 成为 RNN 的标准模型。其实图像领域最早由 HighwayNet/Resnet 等导致模型革命的 skip connection 的原始思路就是从 LSTM 的隐层传递机制借鉴来的。经过不断优化，后来 NLP 又从图像领域借鉴并引入了 attention 机制（从这两个过程可以看到不同领域的相互技术借鉴与促进作用），叠加网络把层深作深，以及引入 Encoder-Decoder 框架，这些技术进展极大拓展了 RNN 的能力以及应用效果。</p>
<p>下图展示的模型就是非常典型的使用 RNN 来解决 NLP 任务的通用框架技术大礼包，在更新的技术出现前，你可以在 NLP 各种领域见到这个技术大礼包的身影。</p>
<p><img src="https://image.rexking6.top/img/0 (11" alt="">.jpg)</p>
<p>上述内容简单介绍了 RNN 在 NLP 领域的大致技术演进过程。那么为什么 RNN 能够这么快在 NLP 流行并且占据了主导地位呢？主要原因还是因为 RNN 的结构天然适配解决 NLP 的问题，NLP 的输入往往是个不定长的线性序列句子，而 RNN 本身结构就是个可以接纳不定长输入的由前向后进行信息线性传导的网络结构，而在 LSTM 引入三个门后，对于捕获长距离特征也是非常有效的。所以 RNN 特别适合 NLP 这种线形序列应用场景，这是 RNN 为何在 NLP 界如此流行的根本原因。</p>
<h3 id="RNN-在新时代面临的两个严重问题"><a href="#RNN-在新时代面临的两个严重问题" class="headerlink" title="RNN 在新时代面临的两个严重问题"></a>RNN 在新时代面临的两个严重问题</h3><p>RNN 在 NLP 界一直红了很多年（2014-2018？），在 2018 年之前，大部分各个子领域的 State of Art 的结果都是 RNN 获得的。但是最近一年来，眼看着 RNN 的领袖群伦的地位正在被动摇，所谓各领风骚 3-5 年，看来网红模型也不例外。</p>
<p>那这又是因为什么呢？主要有两个原因。</p>
<p>第一个原因在于一些后起之秀新模型的崛起，比如经过特殊改造的 CNN 模型，以及最近特别流行的 Transformer，这些后起之秀尤其是 Transformer 的应用效果相比 RNN 来说，目前看具有明显的优势。这是个主要原因，老人如果干不过新人，又没有脱胎换骨自我革命的能力，自然要自觉或不自愿地退出历史舞台，这是自然规律。</p>
<p>至于 RNN 能力偏弱的具体证据，本文后面会专门谈，这里不展开讲。当然，技术人员里的 RNN 保皇派们，这个群体规模应该还是相当大的，他们不会轻易放弃曾经这么热门过的流量明星的，所以也想了或者正在想一些改进方法，试图给 RNN 延年益寿。至于这些方法是什么，有没有作用，后面也陆续会谈。</p>
<p>另外一个严重阻碍 RNN 将来继续走红的问题是：RNN 本身的序列依赖结构对于大规模并行计算来说相当之不友好。通俗点说，就是 RNN 很难具备高效的并行计算能力，这个乍一看好像不是太大的问题，其实问题很严重。如果你仅仅满足于通过改 RNN 发一篇论文，那么这确实不是大问题，但是如果工业界进行技术选型的时候，在有快得多的模型可用的前提下，是不太可能选择那么慢的模型的。一个没有实际落地应用支撑其存在价值的模型，其前景如何这个问题，估计用小脑思考也能得出答案。</p>
<p>那问题来了：为什么 RNN 并行计算能力比较差？是什么原因造成的？</p>
<p><img src="https://image.rexking6.top/img/0 (7" alt="">.jpg)</p>
<p>我们知道，RNN 之所以是 RNN，能将其和其它模型区分开的最典型标志是：T 时刻隐层状态的计算，依赖两个输入，一个是 T 时刻的句子输入单词 Xt，这个不算特点，所有模型都要接收这个原始输入；关键的是另外一个输入，T 时刻的隐层状态 St 还依赖 T-1 时刻的隐层状态 S(t-1) 的输出，这是最能体现 RNN 本质特征的一点，RNN 的历史信息是通过这个信息传输渠道往后传输的，示意参考上图。</p>
<p>那么为什么 RNN 的并行计算能力不行呢？问题就出在这里。因为 T 时刻的计算依赖 T-1 时刻的隐层计算结果，而 T-1 时刻的计算依赖 T-2 时刻的隐层计算结果…….. 这样就形成了所谓的序列依赖关系。就是说只能先把第 1 时间步的算完，才能算第 2 时间步的结果，这就造成了 RNN 在这个角度上是无法并行计算的，只能老老实实地按着时间步一个单词一个单词往后走。</p>
<p>而 CNN 和 Transformer 就不存在这种序列依赖问题，所以对于这两者来说并行计算能力就不是问题，每个时间步的操作可以并行一起计算。</p>
<p>那么能否针对性地对 RNN 改造一下，提升它的并行计算能力呢？如果可以的话，效果如何呢？下面我们讨论一下这个问题。</p>
<h3 id="如何改造-RNN-使其具备并行计算能力？"><a href="#如何改造-RNN-使其具备并行计算能力？" class="headerlink" title="如何改造 RNN 使其具备并行计算能力？"></a>如何改造 RNN 使其具备并行计算能力？</h3><p>上面说过，RNN 不能并行计算的症结所在，在于 T 时刻对 T-1 时刻计算结果的依赖，而这体现在隐层之间的全连接网络上。既然症结在这里，那么要想解决问题，也得在这个环节下手才行。在这个环节多做点什么事情能够增加 RNN 的并行计算能力呢？你可以想一想。</p>
<p>其实留给你的选项并不多，你可以有两个大的思路来改进：一种是仍然保留任意连续时间步（T-1 到 T 时刻）之间的隐层连接；而另外一种是部分地打断连续时间步（T-1 到 T 时刻）之间的隐层连接。</p>
<p>我们先来看第一种方法，现在我们的问题转化成了：我们仍然要保留任意连续时间步（T-1 到 T 时刻）之间的隐层连接，但是在这个前提下，我们还要能够做到并行计算，这怎么处理呢？因为只要保留连续两个时间步的隐层连接，则意味着要计算 T 时刻的隐层结果，就需要 T-1 时刻隐层结果先算完，这不又落入了序列依赖的陷阱里了吗？</p>
<p>嗯，确实是这样，但是为什么一定要在不同时间步的输入之间并行呢？没有人说 RNN 的并行计算一定发生在不同时间步上啊，你想想，隐层是不是也是包含很多神经元？那么在隐层神经元之间并行计算行吗？如果你要是还没理解这是什么意思，那请看下图。</p>
<p> <img src="https://image.rexking6.top/img/0 (6" alt="">.jpg)</p>
<p>上面的图只显示了各个时间步的隐层节点，每个时间步的隐层包含 3 个神经元，这是个俯视图，是从上往下看 RNN 的隐层节点的。另外，连续两个时间步的隐层神经元之间仍然有连接，上图没有画出来是为了看着简洁一些。</p>
<p>这下应该明白了吧，假设隐层神经元有 3 个，那么我们可以形成 3 路并行计算（红色箭头分隔开成了三路），而每一路因为仍然存在序列依赖问题，所以每一路内仍然是串行的。大思路应该明白了是吧？但是了解 RNN 结构的同学会发现这样还遗留一个问题：隐层神经元之间的连接是全连接，就是说 T 时刻某个隐层神经元与 T-1 时刻所有隐层神经元都有连接，如果是这样，是无法做到在神经元之间并行计算的，你可以想想为什么，这个简单，我假设你有能力想明白。</p>
<p>那么怎么办呢？很简单，T 时刻和 T-1 时刻的隐层神经元之间的连接关系需要改造，从之前的全连接，改造成对应位置的神经元（就是上图被红箭头分隔到同一行的神经元之间）有连接，和其它神经元没有连接。这样就可以解决这个问题，在不同路的隐层神经元之间可以并行计算了。</p>
<p>第一种改造 RNN 并行计算能力的方法思路大致如上所述，这种方法的代表就是论文「Simple Recurrent Units for Highly Parallelizable Recurrence」中提出的 SRU 方法，它最本质的改进是把隐层之间的神经元依赖由全连接改成了哈达马乘积，这样 T 时刻隐层单元本来对 T-1 时刻所有隐层单元的依赖，改成了只是对 T-1 时刻对应单元的依赖，于是可以在隐层单元之间进行并行计算，但是收集信息仍然是按照时间序列来进行的。所以其并行性是在隐层单元之间发生的，而不是在不同时间步之间发生的。</p>
<p>这其实是比较巧妙的一种方法，但是它的问题在于其并行程度上限是有限的，并行程度取决于隐层神经元个数，而一般这个数值往往不会太大，再增加并行性已经不太可能。另外每一路并行线路仍然需要序列计算，这也会拖慢整体速度。SRU 的测试速度为：在文本分类上和原始 CNN（Kim 2014）的速度相当，论文没有说 CNN 是否采取了并行训练方法。其它在复杂任务阅读理解及 MT 任务上只做了效果评估，没有和 CNN 进行速度比较，我估计这是有原因的，因为复杂任务往往需要深层网络，其它的就不妄作猜测了。</p>
<p><img src="https://image.rexking6.top/img/0 (3" alt="">.jpg)</p>
<p>第二种改进典型的思路是：为了能够在不同时间步输入之间进行并行计算，那么只有一种做法，那就是打断隐层之间的连接，但是又不能全打断，因为这样基本就无法捕获组合特征了，所以唯一能选的策略就是部分打断，比如每隔 2 个时间步打断一次，但是距离稍微远点的特征如何捕获呢？只能加深层深，通过层深来建立远距离特征之间的联系。</p>
<p>代表性模型比如上图展示的 Sliced RNN。我当初看到这个模型的时候，心里忍不住发出杠铃般的笑声，情不自禁地走上前跟他打了个招呼：你好呀，CNN 模型，想不到你这个糙汉子有一天也会穿上粉色裙装，装扮成 RNN 的样子出现在我面前啊，哈哈。了解 CNN 模型的同学看到我上面这句话估计会莞尔会心一笑：这不就是简化版本的 CNN 吗？不了解 CNN 的同学建议看完后面 CNN 部分再回头来看看是不是这个意思。</p>
<p>那经过这种改造的 RNN 速度改进如何呢？论文给出了速度对比实验，归纳起来，SRNN 速度比 GRU 模型快 5 到 15 倍，嗯，效果不错，但是跟对比模型 DC-CNN 模型速度比较起来，比 CNN 模型仍然平均慢了大约 3 倍。这很正常但是又有点说不太过去，说正常是因为本来这就是把 RNN 改头换面成类似 CNN 的结构，而片段里仍然采取 RNN 序列模型，所以必然会拉慢速度，比 CNN 慢再正常不过了。说「说不过去」是指的是：既然本质上是 CNN，速度又比 CNN 慢，那么这么改的意义在哪里？为什么不直接用 CNN 呢？是不是？</p>
<p>前面那位因为吃亏吃的少所以爱抬杠的同学又会说了：也许人家效果特别好呢。嗯，从这个结构的作用机制上看，可能性不太大。你说论文实验部分证明了这一点呀，我认为实验部分对比试验做的不充分，需要补充除了 DC-CNN 外的其他 CNN 模型进行对比。当然这点纯属个人意见，别当真，因为我讲起话来的时候经常摇头晃脑，此时一般会有人惊奇地跟我反馈说：为什么你一讲话我就听到了水声？</p>
<p>上面列举了两种大的改进 RNN 并行计算能力的思路，我个人对于 RNN 的并行计算能力持悲观态度，主要因为 RNN 本质特性决定了我们能做的选择太少。无非就是选择打断还是不打断隐层连接的问题。</p>
<p>如果选择打断，就会面临上面的问题，你会发现它可能已经不是 RNN 模型了，为了让它看上去还像是 RNN，所以在打断片段里仍然采取 RNN 结构，这样无疑会拉慢速度，所以这是个两难的选择，与其这样不如直接换成其它模型；如果我们选择不打断，貌似只能在隐层神经元之间进行并行，而这样做的缺点是：一方面并行能力上限很低；另外一方面里面依然存在的序列依赖估计仍然是个问题。这是为何悲观的原因，主要是看不到大的希望。</p>
<h2 id="偏师之将-CNN：刺激战场绝地求生"><a href="#偏师之将-CNN：刺激战场绝地求生" class="headerlink" title="偏师之将 CNN：刺激战场绝地求生"></a>偏师之将 CNN：刺激战场绝地求生</h2><p>在一年多前，CNN 是自然语言处理中除了 RNN 外最常见的深度学习模型，这里介绍下 CNN 特征抽取器，会比 RNN 说得详细些，主要考虑到大家对它的熟悉程度可能没有 RNN 那么高。</p>
<h3 id="NLP-中早期的怀旧版-CNN-模型"><a href="#NLP-中早期的怀旧版-CNN-模型" class="headerlink" title="NLP 中早期的怀旧版 CNN 模型"></a>NLP 中早期的怀旧版 CNN 模型</h3><p><img src="https://image.rexking6.top/img/0 (4" alt="">.jpg)</p>
<p>最早将 CNN 引入 NLP 的是 Kim 在 2014 年做的工作，论文和网络结构参考上图。一般而言，输入的字或者词用 Word Embedding 的方式表达，这样本来一维的文本信息输入就转换成了二维的输入结构，假设输入 X 包含 n 个字符，而每个字符的 Word Embedding 的长度为 d，那么输入就是 d*n 的二维向量。</p>
<p>卷积层本质上是个特征抽取层，可以设定超参数 F 来指定卷积层包含多少个卷积核（Filter）。对于某个 Filter 来说，可以想象有一个 d*k 大小的移动窗口从输入矩阵的第一个字开始不断往后移动，其中 k 是 Filter 指定的窗口大小，d 是 Word Embedding 长度。</p>
<p>对于某个时刻的窗口，通过神经网络的非线性变换，将这个窗口内的输入值转换为某个特征值，随着窗口不断往后移动，这个 Filter 对应的特征值不断产生，形成这个 Filter 的特征向量。这就是卷积核抽取特征的过程。卷积层内每个 Filter 都如此操作，就形成了不同的特征序列。Pooling 层则对 Filter 的特征进行降维操作，形成最终的特征。一般在 Pooling 层之后连接全联接层神经网络，形成最后的分类过程。</p>
<p>这就是最早应用在 NLP 领域 CNN 模型的工作机制，用来解决 NLP 中的句子分类任务，看起来还是很简洁的，之后陆续出现了在此基础上的改进模型。这些怀旧版 CNN 模型在一些任务上也能和当时怀旧版本的 RNN 模型效果相当，所以在 NLP 若干领域也能野蛮生长，但是在更多的 NLP 领域，还是处于被 RNN 模型压制到抑郁症早期的尴尬局面。</p>
<p>那为什么在图像领域打遍天下无敌手的 CNN，一旦跑到 NLP 的地盘，就被 RNN 这个地头蛇压制得无颜见图像领域江东父老呢？这说明这个版本的 CNN 还是有很多问题的，其实最根本的症结所在还是老革命遇到了新问题，主要是到了新环境没有针对新环境的特性做出针对性的改变，所以面临水土不服的问题。</p>
<p>CNN 能在 RNN 纵横的各种 NLP 任务环境下生存下来吗？谜底即将揭晓。</p>
<h3 id="CNN-的进化：物竞天择的模型斗兽场"><a href="#CNN-的进化：物竞天择的模型斗兽场" class="headerlink" title="CNN 的进化：物竞天择的模型斗兽场"></a>CNN 的进化：物竞天择的模型斗兽场</h3><p>下面我们先看看怀旧版 CNN 存在哪些问题，然后看看我们的 NLP 专家们是如何改造 CNN，一直改到目前看上去还算效果不错的现代版本 CNN 的。</p>
<p>首先，我们先要明确一点：CNN 捕获到的是什么特征呢？从上述怀旧版本 CNN 卷积层的运作机制你大概看出来了，关键在于卷积核覆盖的那个滑动窗口，CNN 能捕获到的特征基本都体现在这个滑动窗口里了。大小为 k 的滑动窗口轻轻的穿过句子的一个个单词，荡起阵阵涟漪，那么它捕获了什么? 其实它捕获到的是单词的 k-gram 片段信息，这些 k-gram 片段就是 CNN 捕获到的特征，k 的大小决定了能捕获多远距离的特征。</p>
<p><img src="https://image.rexking6.top/img/0 (2" alt="">.jpg)</p>
<p>说完这个，我们来看 Kim 版 CNN 的第一个问题：它只有一个卷积层。表面看上去好像是深度不够的问题是吧？我会反问你说：为什么要把 CNN 作深呢？其实把深度做起来是手段，不是目的。只有一个卷积层带来的问题是：对于远距离特征，单层 CNN 是无法捕获到的，如果滑动窗口 k 最大为 2，而如果有个远距离特征距离是 5，那么无论上多少个卷积核，都无法覆盖到长度为 5 的距离的输入，所以它是无法捕获长距离特征的。</p>
<p><img src="https://image.rexking6.top/img/0 (10" alt="">.jpg)</p>
<p>那么怎样才能捕获到长距离的特征呢？有两种典型的改进方法：一种是假设我们仍然用单个卷积层，滑动窗口大小 k 假设为 3，就是只接收三个输入单词，但是我们想捕获距离为 5 的特征，怎么做才行？显然，如果卷积核窗口仍然覆盖连续区域，这肯定是完不成任务的。提示一下：你玩过跳一跳是吧？能采取类似策略吗？对，你可以跳着覆盖呀，是吧？这就是 Dilated 卷积的基本思想，确实也是一种解决方法。</p>
<p><img src="https://image.rexking6.top/img/0 (13" alt="">.jpg)</p>
<p>第二种方法是把深度做起来。第一层卷积层，假设滑动窗口大小 k 是 3，如果再往上叠一层卷积层，假设滑动窗口大小也是 3，但是第二层窗口覆盖的是第一层窗口的输出特征，所以它其实能覆盖输入的距离达到了 5。如果继续往上叠加卷积层，可以继续增大卷积核覆盖输入的长度。</p>
<p>上面是两种典型的解决 CNN 远距离特征捕获能力的方案，Dilated CNN 偏技巧一些，而且叠加卷积层时超参如何设置有些学问，因为连续跳接可能会错过一些特征组合，所以需要精心调节参数搭配，保证所有可能组合都被覆盖到。相对而言，把 CNN 作深是主流发展方向。</p>
<p>上面这个道理好理解，其实自从 CNN 一出现，人们就想各种办法试图把 CNN 的深度做起来，但是现实往往是无情的，发现怎么折腾，CNN 做 NLP 问题就是做不深，做到 2 到 3 层卷积层就做不上去了，网络更深对任务效果没什么帮助（请不要拿 CharCNN 来做反例，后来研究表明使用单词的 2 层 CNN 效果超过 CharCNN）。目前看来，还是深层网络参数优化手段不足导致的这个问题，而不是层深没有用。后来 Resnet 等图像领域的新技术出现后，很自然地，人们会考虑把 Skip Connection 及各种 Norm 等参数优化技术引入，这才能慢慢把 CNN 的网络深度做起来。</p>
<p>上面说的是 Kim 版本 CNN 的第一个问题，无法捕获远距离特征的问题，以及后面科研人员提出的主要解决方案。回头看 Kim 版本 CNN 还有一个问题，就是那个 Max Pooling 层，这块其实与 CNN 能否保持输入句子中单词的位置信息有关系。首先我想问个问题：RNN 因为是线性序列结构，所以很自然它天然就会把位置信息编码进去；那么，CNN 是否能够保留原始输入的相对位置信息呢？我们前面说过对于 NLP 问题来说，位置信息是很有用的。</p>
<p>其实 CNN 的卷积核是能保留特征之间的相对位置的，道理很简单，滑动窗口从左到右滑动，捕获到的特征也是如此顺序排列，所以它在结构上已经记录了相对位置信息了。但是如果卷积层后面立即接上 Pooling 层的话，Max Pooling 的操作逻辑是：从一个卷积核获得的特征向量里只选中并保留最强的那一个特征，所以到了 Pooling 层，位置信息就被扔掉了，这在 NLP 里其实是有信息损失的。所以在 NLP 领域里，目前 CNN 的一个发展趋势是抛弃 Pooling 层，靠全卷积层来叠加网络深度，这背后是有原因的（当然图像领域也是这个趋势）。</p>
<p><img src="https://image.rexking6.top/img/0 (12" alt="">.jpg)</p>
<p>上图展示了在 NLP 领域能够施展身手的摩登 CNN 的主体结构，通常由 1-D 卷积层来叠加深度，使用 Skip Connection 来辅助优化，也可以引入 Dilated CNN 等手段。比如 ConvS2S 主体就是上图所示结构，Encoder 包含 15 个卷积层，卷积核 kernel size=3，覆盖输入长度为 25。</p>
<p>当然对于 ConvS2S 来说，卷积核里引入 GLU 门控非线性函数也有重要帮助，限于篇幅，这里不展开说了，GLU 貌似是 NLP 里 CNN 模型必备的构件，值得掌握。再比如 TCN（论文：An Empirical Evaluation of Generic Convolutional and Recurrent Networks for Sequence Modeling），集成了几项技术：利用 Dilated CNN 拓展单层卷积层的输入覆盖长度，利用全卷积层堆叠层深，使用 Skip Connection 辅助优化，引入 Casual CNN 让网络结构看不到 T 时间步后的数据。</p>
<p>不过 TCN 的实验做得有两个明显问题：一个问题是任务除了语言模型外都不是典型的 NLP 任务，而是合成数据任务，所以论文结论很难直接说就适合 NLP 领域；另外一点，它用来进行效果比较的对比方法，没有用当时效果很好的模型来对比，比较基准低。所以 TCN 的模型效果说服力不太够。其实它该引入的元素也基本引入了，实验说服力不够，我觉得可能是它命中缺 GLU 吧。</p>
<p>除此外，简单谈一下 CNN 的位置编码问题和并行计算能力问题。上面说了，CNN 的卷积层其实是保留了相对位置信息的，只要你在设计模型的时候别手贱，中间层不要随手瞎插入 Pooling 层，问题就不大，不专门在输入部分对 position 进行编码也行。但是也可以类似 ConvS2S 那样，专门在输入部分给每个单词增加一个 position embedding，将单词的 position embedding 和词向量 embedding 叠加起来形成单词输入，这样也可以，也是常规做法。</p>
<p>至于 CNN 的并行计算能力，那是非常强的，这其实很好理解。我们考虑单层卷积层，首先对于某个卷积核来说，每个滑动窗口位置之间没有依赖关系，所以完全可以并行计算；另外，不同的卷积核之间也没什么相互影响，所以也可以并行计算。CNN 的并行度是非常自由也非常高的，这是 CNN 的一个非常好的优点。</p>
<p>以上内容介绍了怀旧版 CNN 是如何在 NLP 修罗场一步步通过自我进化生存到今天的。CNN 的进化方向，如果千言万语一句话归纳的话，那就是：想方设法把 CNN 的深度做起来，随着深度的增加，很多看似无关的问题就随之解决了。就跟我们国家最近 40 年的主旋律是发展经济一样，经济发展好了，很多问题就不是问题了。最近几年之所以大家感到各方面很困难，症结就在于经济不行了，所以很多问题无法通过经济带动来解决，于是看似各种花样的困难就冒出来，这是一个道理。</p>
<p>那么介绍了这么多，摩登版 CNN 效果如何呢？与 RNN 及 Transforme 比起来怎样？别着急，后面会专门谈这个问题。</p>
<h2 id="白衣骑士-Transformer：盖世英雄站上舞台"><a href="#白衣骑士-Transformer：盖世英雄站上舞台" class="headerlink" title="白衣骑士 Transformer：盖世英雄站上舞台"></a>白衣骑士 Transformer：盖世英雄站上舞台</h2><p><img src="https://image.rexking6.top/img/0 (14" alt="">.jpg)</p>
<p>Transformer 是谷歌在 17 年做机器翻译任务的「Attention is all you need」的论文中提出的，引起了相当大的反响。每一位从事 NLP 研发的同仁都应该透彻搞明白 Transformer，它的重要性毫无疑问，尤其是你在看完我这篇文章之后，我相信你的紧迫感会更迫切，我就是这么一位善于制造焦虑的能手。</p>
<p>不过这里没打算重点介绍它，想要入门 Transformer 的可以参考以下三篇文章：一个是 Jay Alammar 可视化地介绍 Transformer 的博客文章 The Illustrated Transformer，非常容易理解整个机制，建议先从这篇看起，这是中文翻译版本；第二篇是 Calvo 的博客：Dissecting BERT Part 1: The Encoder，尽管说是解析 Bert，但是因为 Bert 的 Encoder 就是 Transformer，所以其实它是在解析 Transformer，里面举的例子很好；再然后可以进阶一下，参考哈佛大学 NLP 研究组写的「The Annotated Transformer.」，代码原理双管齐下，讲得也很清楚。</p>
<p>下面只说跟本文主题有关的内容。</p>
<p><img src="https://image.rexking6.top/img/0 (15" alt="">.jpg)</p>
<p>这里要澄清一下，本文所说的 Transformer 特征抽取器并非原始论文所指。我们知道，「Attention is all you need」论文中说的的 Transformer 指的是完整的 Encoder-Decoder 框架，而我这里是从特征提取器角度来说的，你可以简单理解为论文中的 Encoder 部分。因为 Encoder 部分目的比较单纯，就是从原始句子中提取特征，而 Decoder 部分则功能相对比较多，除了特征提取功能外，还包含语言模型功能，以及用 attention 机制表达的翻译模型功能。所以这里请注意，避免后续理解概念产生混淆。</p>
<p>Transformer 的 Encoder 部分（不是上图一个一个的标为 encoder 的模块，而是红框内的整体，上图来自 The Illustrated Transformer，Jay Alammar 把每个 Block 称为 Encoder 不太符合常规叫法）是由若干个相同的 Transformer Block 堆叠成的。这个 Transformer Block 其实才是 Transformer 最关键的地方，核心配方就在这里。那么它长什么样子呢？</p>
<p><img src="https://image.rexking6.top/img/0 (17" alt="">.jpg)</p>
<p>它的照片见上图，看上去是不是很可爱，有点像安卓机器人是吧？这里需要强调一下，尽管 Transformer 原始论文一直重点在说 Self Attention，但是目前来看，能让 Transformer 效果好的，不仅仅是 Self attention，这个 Block 里所有元素，包括 Multi-head self attention，Skip connection，LayerNorm，FF 一起在发挥作用。为什么这么说？你看到后面会体会到这一点。</p>
<p>我们针对 NLP 任务的特点来说下 Transformer 的对应解决方案。首先，自然语言一般是个不定长的句子，那么这个不定长问题怎么解决呢？Transformer 做法跟 CNN 是类似的，一般设定输入的最大长度，如果句子没那么长，则用 Padding 填充，这样整个模型输入起码看起来是定长的了。另外，NLP 句子中单词之间的相对位置是包含很多信息的，上面提过，RNN 因为结构就是线性序列的，所以天然会将位置信息编码进模型；而 CNN 的卷积层其实也是保留了位置相对信息的，所以什么也不做问题也不大。</p>
<p>但是对于 Transformer 来说，为了能够保留输入句子单词之间的相对位置信息，必须要做点什么。为啥它必须要做点什么呢？因为输入的第一层网络是 Muli-head self attention 层，我们知道，Self attention 会让当前输入单词和句子中任意单词发生关系，然后集成到一个 embedding 向量里，但是当所有信息到了 embedding 后，位置信息并没有被编码进去。</p>
<p>所以，Transformer 不像 RNN 或 CNN，必须明确的在输入端将 Positon 信息编码，Transformer 是用位置函数来进行位置编码的，而 Bert 等模型则给每个单词一个 Position embedding，将单词 embedding 和单词对应的 position embedding 加起来形成单词的输入 embedding，类似上文讲的 ConvS2S 的做法。而关于 NLP 句子中长距离依赖特征的问题，Self attention 天然就能解决这个问题，因为在集成信息的时候，当前单词和句子中任意单词都发生了联系，所以一步到位就把这个事情做掉了。不像 RNN 需要通过隐层节点序列往后传，也不像 CNN 需要通过增加网络深度来捕获远距离特征，Transformer 在这点上明显方案是相对简单直观的。说这些是为了单独介绍下 Transformer 是怎样解决 NLP 任务几个关键点的。</p>
<p>Transformer 有两个版本：Transformer base 和 Transformer Big。两者结构其实是一样的，主要区别是包含的 Transformer Block 数量不同，Transformer base 包含 12 个 Block 叠加，而 Transformer Big 则扩张一倍，包含 24 个 Block。无疑 Transformer Big 在网络深度，参数量以及计算量相对 Transformer base 翻倍，所以是相对重的一个模型，但是效果也最好。</p>
<h2 id="华山论剑：三大特征抽取器比较"><a href="#华山论剑：三大特征抽取器比较" class="headerlink" title="华山论剑：三大特征抽取器比较"></a>华山论剑：三大特征抽取器比较</h2><p>结合 NLP 领域自身的特点，上面几个部分分别介绍了 RNN／CNN／Transformer 各自的特性。从上面的介绍，看上去好像三大特征抽取器在 NLP 领域里各有所长，推想起来要是把它们拉到 NLP 任务竞技场角斗，一定是互有胜负，各擅胜场吧？</p>
<p>事实究竟如何呢？是三个特征抽取器三花齐放还是某一个一枝独秀呢？我们通过一些实验来说明这个问题。</p>
<p>为了更细致和公平地做对三者进行比较，我准备从几个不同的角度来分别进行对比，我原先打算从以下几个维度来进行分析判断：句法特征提取能力；语义特征提取能力；长距离特征捕获能力；任务综合特征抽取能力。上面四个角度是从 NLP 的特征抽取器能力强弱角度来评判的，另外再加入并行计算能力及运行效率，这是从是否方便大规模实用化的角度来看的。</p>
<p>因为目前关于特征抽取器句法特征抽取能力方面进行比较的文献很少，好像只看到一篇文章，结论是 CNN 在句法特征提取能力要强于 RNN，但是因为是比较早的文章，而且没有对比 transformer 在句法特征抽取方面的能力，所以这块很难单独比较，于是我就简化为对以下几项能力的对比：</p>
<ol>
<li>语义特征提取能力；</li>
<li>长距离特征捕获能力；</li>
<li>任务综合特征抽取能力；</li>
<li>并行计算能力及运行效率</li>
</ol>
<p>三者在这些维度各自表现如何呢？下面我们分头进行说明。</p>
<h3 id="语义特征提取能力"><a href="#语义特征提取能力" class="headerlink" title="语义特征提取能力"></a>语义特征提取能力</h3><p><img src="https://image.rexking6.top/img/0 (16" alt="">.jpg)</p>
<p>从语义特征提取能力来说，目前实验支持如下结论：Transformer 在这方面的能力非常显著地超过 RNN 和 CNN（在考察语义类能力的任务 WSD 中，Transformer 超过 RNN 和 CNN 大约 4-8 个绝对百分点），RNN 和 CNN 两者能力差不太多。</p>
<h3 id="长距离特征捕获能力"><a href="#长距离特征捕获能力" class="headerlink" title="长距离特征捕获能力"></a>长距离特征捕获能力</h3><p><img src="https://image.rexking6.top/img/0 (18" alt="">.jpg)</p>
<p>在长距离特征捕获能力方面，目前在特定的长距离特征捕获能力测试任务中（主语-谓语一致性检测，比如 we……..are…），实验支持如下结论：原生 CNN 特征抽取器在这方面极为显著地弱于 RNN 和 Transformer，Transformer 微弱优于 RNN 模型 (尤其在主语谓语距离小于 13 时)，能力由强到弱排序为 Transformer&gt;RNN&gt;&gt;CNN; 但在比较远的距离上（主语谓语距离大于 13），RNN 微弱优于 Transformer，所以综合看，可以认为 Transformer 和 RNN 在这方面能力差不太多，而 CNN 则显著弱于前两者。</p>
<p>那么为什么 CNN 在捕获长距离特征方面这么弱呢？这个我们在前文讲述 CNN 的时候就说过，CNN 解决这个问题是靠堆积深度来获得覆盖更长的输入长度的，所以 CNN 在这方面的表现与卷积核能够覆盖的输入距离最大长度有关系。如果通过增大卷积核的 kernel size，同时加深网络深度，以此来增加输入的长度覆盖。</p>
<p>实验证明这能够明显提升 CNN 的 long-range 特征捕获能力。但是尽管如此，CNN 在这方面仍然显著弱于 RNN 和 Transformer。这个问题背后的原因是什么呢（因为上述主语-谓语一致性任务中，CNN 的深度肯定可以覆盖 13-25 这个长度了，但是表现还是很弱）？其实这是一个很好的值得探索的点。</p>
<p>对于 Transformer 来说，Multi-head attention 的 head 数量严重影响 NLP 任务中 Long-range 特征捕获能力：结论是 head 越多越有利于捕获 long-range 特征。在上页 PPT 里写明的论文出来之前，有个工作（论文：Tran. The Importance of Being Recurrent for Modeling Hierarchical Structure）的结论和上述结论不一致：它的结论是在」主语-谓语一致性」任务上，Transformer 表现是弱于 LSTM 的。如果综合这两篇论文，我们看似得到了相互矛盾的结论，那么到底谁是正确的呢？</p>
<p>Why Self-attention 的论文对此进行了探索，它的结论是：这个差异是由于两个论文中的实验中 Transformer 的超参设置不同导致的，其中尤其是 multi-head 的数量，对结果影响严重，而如果正确设置一些超参，那么之前 Trans 的论文结论是不成立的。也就是说，我们目前仍然可以维持下面结论：在远距离特征捕获能力方面，Transformer 和 RNN 能力相近，而 CNN 在这方面则显著弱于前两者。</p>
<h3 id="任务综合特征抽取能力"><a href="#任务综合特征抽取能力" class="headerlink" title="任务综合特征抽取能力"></a>任务综合特征抽取能力</h3><p>上面两项对比是从特征抽取的两个比较重要的单项能力角度来评估的，其实更重要的是在具体任务中引入不同特征抽取器，然后比较效果差异，以此来综合评定三者的综合能力。那么这样就引出一个问题：NLP 中的任务很多，哪些任务是最具有代表性的呢？答案是机器翻译。你会看到很多 NLP 的重要的创新模型都是在机器翻译任务上提出来的，这背后是有道理的，因为机器翻译基本上是对 NLP 各项处理能力综合要求最高的任务之一，要想获得高质量的翻译结果，对于两种语言的词法，句法，语义，上下文处理能力，长距离特征捕获等等更方面都需要考虑进来才行。</p>
<p>这是为何看到很多比较工作是在机器翻译上作出的，这里给个背后原因的解释，以避免被质疑任务单一，没有说服力的问题。当然，我预料到那位「因为吃亏少…. 爱挑刺」的同学会这么质问我，没关系，即使你对此提出质疑，我依然能够拿出证据，为什么这么讲，请往后看。</p>
<p>那么在以机器翻译为代表的综合特征抽取能力方面，三个特征抽取器哪个更好些呢？</p>
<p><img src="https://image.rexking6.top/img/0 (21" alt="">.jpg)</p>
<p>先给出一个机器翻译任务方面的证据，仍然是 why Self attention 论文的结论，对比实验结果数据参考上图。在两个机器翻译任务中，可以看到，翻译质量指标 BLEU 证明了如下结论：Transformer 综合能力要明显强于 RNN 和 CNN（你要知道，技术发展到现在阶段，BLEU 绝对值提升 1 个点是很难的事情），而 RNN 和 CNN 看上去表现基本相当，貌似 CNN 表现略好一些。</p>
<p>你可能觉得一个论文的结论不太能说明问题，那么我再给出一个证据，不过这个证据只对比了 Transformer 和 RNN，没带 CNN 玩，不过关于说服力我相信你不会质疑，实验对比数据如下：</p>
<p><img src="https://image.rexking6.top/img/0 (19" alt="">.jpg)</p>
<p>上面是 GPT 论文的实验结论，在 8 个不同的 NLP 任务上，在其它条件相同的情况下，只是把特征抽取器从 Transformer 换成 LSTM，平均下来 8 个任务得分掉了 5 个点以上。这具备足够说服力吗？</p>
<p>其实还有其它机器翻译方面的实验数据，篇幅原因，不一一列举了。如果你是个较真的人，实在还想看，那请看下一节，里面有另外一个例子的数据让来你服气。如果归纳一下的话，现在能得出的结论是这样的：从综合特征抽取能力角度衡量，Transformer 显著强于 RNN 和 CNN，而 RNN 和 CNN 的表现差不太多，如果一定要在这两者之间比较的话，通常 CNN 的表现要稍微好于 RNN 的效果。</p>
<p>当然，需要强调一点，本部分所说的 RNN 和 CNN 指的是原生的 RNN 和 CNN 模型，就是说你可以在经典的结构上增加 attention，堆叠层次等各种改进，但是不包含对本身结构特别大的变动，就是说支持整容，但是不支持变性。这里说的原生版本指的是整容版本，我知道你肯定很关心有没有变性版本的 RNN 和 CNN，我负责任地跟你说，有。你想知道它变性之后是啥样子？等会你就看到了，有它们的照片给你。</p>
<h3 id="并行计算能力及运算效率"><a href="#并行计算能力及运算效率" class="headerlink" title="并行计算能力及运算效率"></a>并行计算能力及运算效率</h3><p>关于三个特征抽取器的并行计算能力，其实我们在前文分述三个模型的时候都大致提过，在此仅做个归纳，结论如下：</p>
<p>RNN 在并行计算方面有严重缺陷，这是它本身的序列依赖特性导致的，所谓成也萧何败也萧何，它的这个线形序列依赖性非常符合解决 NLP 任务，这也是为何 RNN 一引入到 NLP 就很快流行起来的原因，但是也正是这个线形序列依赖特性，导致它在并行计算方面要想获得质的飞跃，看起来困难重重，近乎是不太可能完成的任务。</p>
<p>而对于 CNN 和 Transformer 来说，因为它们不存在网络中间状态不同时间步输入的依赖关系，所以可以非常方便及自由地做并行计算改造，这个也好理解。</p>
<p>所以归纳一下的话，可以认为并行计算能力由高到低排序如下：Transformer 和 CNN 差不多，都远远远远强于 RNN。</p>
<p>我们从另外一个角度来看，先抛开并行计算能力的问题，单纯地比较一下三个模型的计算效率。可能大家的直观印象是 Transformer 比较重，比较复杂，计算效率比较低，事实是这样的吗？</p>
<p><img src="https://image.rexking6.top/img/0 (20" alt="">.jpg)</p>
<p>上图列出了单层的 Self attention／RNN／CNN 的计算效率，首先要注意：上面列的是 Self attention，不是 Transformer 的 Block，因为 Transformer Block 里其实包含了好几层，而不是单层。我们先说 self attention，等会说 Transformer Block 的计算量。</p>
<p>从上图可以看出，如果是 self attention/CNN/RNN 单层比较计算量的话，三者都包含一个平方项，区别主要是：self attention 的平方项是句子长度，因为每一个单词都需要和任意一个单词发生关系来计算 attention，所以包含一个 n 的平方项。而 RNN 和 CNN 的平方项则是 embedding size。那么既然都包含平方项，怎么比较三个模型单层的计算量呢？首先容易看出 CNN 计算量是大于 RNN 的，那么 self attention 如何与其它两者比较呢。</p>
<p>可以这么考虑：如果句子平均长度 n 大于 embedding size，那么意味着 Self attention 的计算量要大于 RNN 和 CNN；而如果反过来，就是说如果 embedding size 大于句子平均长度，那么明显 RNN 和 CNN 的计算量要大于 self attention 操作。而事实上是怎样？我们可以想一想，一般正常的句子长度，平均起来也就几十个单词吧。而当前常用的 embedding size 从 128 到 512 都常见，所以在大多数任务里面其实 self attention 计算效率是要高于 RNN 和 CNN 的。</p>
<p>但是，那位因为吃亏吃的少所以喜欢挑刺的同学会继续质问我：「哥，我想知道的是 Transformer 和 RNN 及 CNN 的计算效率对比，不是 self attention。另外，你能降低你脑袋里发出的水声音量吗？」。嗯，这个质问很合理，我来粗略估算一下，因为 Transformer 包含多层，其中的 skip connection 后的 Add 操作及 LayerNorm 操作不太耗费计算量，我先把它忽略掉，后面的 FFN 操作相对比较耗时，它的时间复杂度应该是 n 乘以 d 的平方。</p>
<p>所以如果把 Transformer Block 多层当作一个整体和 RNN 及 CNN 单层对比的话，Transformer Block 计算量肯定是要多于 RNN 和 CNN 的，因为它本身也包含一个 n 乘以 d 的平方，上面列出的 self attention 的时间复杂度就是多出来的计算量。这么说起来，单个 Transformer Block 计算量大于单层 RNN 和 CNN，没毛病。</p>
<p>上面考虑的是三者单层的计算量，可以看出结论是：Transformer Block &gt;CNN &gt;RNN。如果是考虑不同的具体模型，会与模型的网络层深有很大关系，另外还有常见的 attention 操作，所以问题会比较复杂，这里不具体讨论了。</p>
<p>说完非并行情况的三者单层计算量，再说回并行计算的问题。很明显，对于 Transformer 和 CNN 来说，那个句子长度 n 是可以通过并行计算消掉的，而 RNN 因为序列依赖的问题，那个 n 就消不掉，所以很明显，把并行计算能力考虑进来，RNN 消不掉的那个 n 就很要命。这只是理论分析，实际中三者计算效率到底如何呢？我们给出一些三者计算效率对比的实验结论。</p>
<p>论文「Convolutional Sequence to Sequence Learning」比较了 ConvS2S 与 RNN 的计算效率，证明了跟 RNN 相比，CNN 明显速度具有优势，在训练和在线推理方面，CNN 比 RNN 快 9.3 倍到 21 倍。论文「Dissecting Contextual Word Embeddings: Architecture and Representation」提到了 Transformer 和 CNN 训练速度比双向 LSTM 快 3 到 5 倍。论文「The Best of Both Worlds: Combining Recent Advances in Neural Machine Translation」给出了 RNN／CNN／Transformer 速度对比实验，结论是：Transformer Base 速度最快；CNN 速度次之，但是比 Transformer Base 比慢了将近一倍；Transformer Big 速度再次，主要因为它的参数量最大，而吊在车尾最慢的是 RNN 结构。</p>
<p>总而言之，关于三者速度对比方面，目前的主流经验结论基本如上所述：Transformer Base 最快，CNN 次之，再次 Transformer Big，最慢的是 RNN。RNN 比前两者慢了 3 倍到几十倍之间。</p>
<h3 id="综合排名情况"><a href="#综合排名情况" class="headerlink" title="综合排名情况"></a>综合排名情况</h3><p>以上介绍内容是从几个不同角度来对 RNN／CNN/Transformer 进行对比，综合这几个方面的实验数据，我自己得出的结论是这样的：单从任务综合效果方面来说，Transformer 明显优于 CNN，CNN 略微优于 RNN。速度方面 Transformer 和 CNN 明显占优，RNN 在这方面劣势非常明显。这两者再综合起来，如果我给的排序结果是 Transformer&gt;CNN&gt;RNN，估计没有什么问题吧？那位吃亏….. 爱挑刺的同学，你说呢？</p>
<p>从速度和效果折衷的角度看，对于工业界实用化应用，我的感觉在特征抽取器选择方面配置 Transformer base 是个较好的选择。</p>
<h2 id="三者的合流：向-Transformer-靠拢"><a href="#三者的合流：向-Transformer-靠拢" class="headerlink" title="三者的合流：向 Transformer 靠拢"></a>三者的合流：向 Transformer 靠拢</h2><p>上文提到了，Transformer 的效果相对原生 RNN 和 CNN 来说有比较明显的优势，那么是否意味着我们可以放弃 RNN 和 CNN 了呢？事实倒也并未如此。我们聪明的科研人员想到了一个巧妙的改造方法，我把它叫做「寄居蟹」策略（就是上文说的「变性」的一种带有海洋文明气息的文雅说法）。什么意思呢？我们知道 Transformer Block 其实不是只有一个构件，而是由 multi-head attention/skip connection/Layer Norm/Feed forward network 等几个构件组成的一个小系统，如果我们把 RNN 或者 CNN 塞到 Transformer Block 里会发生什么事情呢？这就是寄居蟹策略的基本思路。</p>
<p>那么怎么把 RNN 和 CNN 塞到 Transformer Block 的肚子里，让它们背上重重的壳，从而能够实现寄居策略呢？</p>
<p><img src="https://image.rexking6.top/img/0 (23" alt="">.jpg)</p>
<p><img src="https://image.rexking6.top/img/0 (22" alt="">.jpg)</p>
<p>其实很简单，参考上面两张 PPT，简而言之，大的方向就是把 self attention 模块用双向 RNN 或者 CNN 替换掉，Transformer Block 的其它构件依然健在。当然这只是说明一个大方向，具体的策略可能有些差异，但是基本思想八九不离十。</p>
<p>那么如果 RNN 和 CNN 采取这种寄居策略，效果如何呢？他们还爬的动吗？其实这种改造方法有奇效，能够极大提升 RNN 和 CNN 的效果。而且目前来看，RNN 或者 CNN 想要赶上 Transformer 的效果，可能还真只有这个办法了。</p>
<p><img src="https://image.rexking6.top/img/0 (25" alt="">.jpg)</p>
<p>我们看看 RNN 寄居到 Transformer 后，效果是如何的。上图展示了对原生 RNN 不断进行整容手术，逐步加入 Transformer 的各个构件后的效果。我们从上面的逐步变身过程可以看到，原生 RNN 的效果在不断稳定提升。但是与土生土长的 Transformer 相比，性能仍然有差距。</p>
<p><img src="https://image.rexking6.top/img/0 (24" alt="">.jpg)</p>
<p>类似的，上图展示了对 CNN 进行不断改造的过程以及其对应效果。同样的，性能也有不同幅度的提升。但是也与土家 Transformer 性能存在一些差距。</p>
<p>这说明什么？我个人意见是：这说明 Transformer 之所以能够效果这么好，不仅仅 multi-head attention 在发生作用，而是几乎所有构件都在共同发挥作用，是一个小小的系统工程。</p>
<p>但是从上面结果看，变性版本 CNN 好像距离 Transformer 真身性能还是比不上，有些数据集合差距甚至还很大，那么是否意味着这条路也未必走的通呢？Lightweight convolution 和 Dynamic convolutions 给人们带来一丝曙光，在论文「Pay Less Attention With LightweightI and Dynamic Convolutions」里提出了上面两种方法，效果方面基本能够和 Transformer 真身相当。那它做了什么能够达成这一点呢？也是寄居策略。就是用 Lightweight convolution 和 Dynamic convolutions 替换掉 Transformer 中的 Multi-head attention 模块，其它构件复用了 Transformer 的东西。和原生 CNN 的最主要区别是采用了 Depth-wise separable CNN 以及 softmax-normalization 等优化的 CNN 模型。</p>
<p>而这又说明了什么呢？我觉得这说明了一点：RNN 和 CNN 的大的出路在于寄生到 Transformer Block 里，这个原则没问题，看起来也是他俩的唯一出路。但是，要想效果足够好，在塞进去的 RNN 和 CNN 上值得花些功夫，需要一些新型的 RNN 和 CNN 模型，以此来配合 Transformer 的其它构件，共同发挥作用。如果走这条路，那么 RNN 和 CNN 翻身的一天也许还会到来。</p>
<p>尽管如此，我觉得 RNN 这条路仍然不好走，为什么呢，你要记得 RNN 并行计算能力差这个天生缺陷，即使把它塞到 Transformer Block 里，别说现在效果还不行，就算哪天真改出了一个效果好的，但是因为它的并行能力，会整体拖慢 Transformer 的运行效率。所以我综合判断 RNN 这条路将来也走不太通。</p>
<h2 id="2019-来自未来的消息：总结"><a href="#2019-来自未来的消息：总结" class="headerlink" title="2019 来自未来的消息：总结"></a>2019 来自未来的消息：总结</h2><p>很多年前的小学语文课本上有句话，是这么说的：「张华考上了北京大学；李萍进了中等技术学校；我在百货公司当售货员：我们都有光明的前途」。我们小的时候看到这句话，对此深信不疑，但是走到 2019 的今天，估计已经没有父母愿意跟他们的孩子说这句话了，毕竟欺骗孩子是个挺不好的事情。如果套用这句话来说明 NLP 的三大特征抽取器的前途的话，应该是这样的：「Transformer 考上了北京大学；CNN 进了中等技术学校，希望有一天能够考研考进北京大学；RNN 在百货公司当售货员：我们都有看似光明的前途。」</p>
<p>我们把上文的所有证据都收集起来进行逻辑推理，可以模仿曹雪芹老师，分别给三位 NLP 界佳丽未来命运写一句判词。当然，再次声明，这是我个人判断。</p>
<h3 id="进退维谷的-RNN"><a href="#进退维谷的-RNN" class="headerlink" title="进退维谷的 RNN"></a>进退维谷的 RNN</h3><p>为什么说 RNN 进退维谷呢？有几个原因。</p>
<p>首先，如果靠原生的 RNN（包括 LSTM，GRU 以及引入 Attention 以及堆叠层次等各种你能想到的改进方法，可以一起上），目前很多实验已经证明效果比起 Transformer 有较大差距，现在看基本没有迎头赶上的可能，所以原生的 RNN 从效果来讲是处于明显劣势的。</p>
<p>其次，原生的 RNN 还有一个致命的问题：并行计算能力受限制太严重。想要大规模实用化应用？目前看希望渺茫。我们前面说过，决定了 RNN 本身的根本特质是：T 时刻隐层节点对前向输入及中间计算结果的序列依赖，因为它要线形序列收集前面的信息，这是 RNN 之所以是 RNN 的最主要特点。</p>
<p>正是它的这个根本特质，使得 RNN 的并行计算能力想要获得根本解决基本陷入了一个两难的境地：要么仍然保持 RNN 序列依赖的根本特性，这样不论怎么改造，因为这个根本还在，所以 RNN 依旧是 RNN，所谓「我就是我，是不一样的烟火」，但是如果这样，那么其并行能力基本无法有力发挥，天花板很低；当然除此外，还有另外一条路可走，就是把这种序列依赖关系打掉，如果这样，那么这种打掉序列依赖关系的模型虽然看上去仍然保留了部分 RNN 整形前的样貌，其实它骨子里已经是另外一个人了，这已经不是你记忆中的 RNN 了。</p>
<p>就是说，对 RNN 来说，要么就认命接受慢的事实，躲进小楼成一统，管他春夏与秋冬，仅仅是学术界用来发表论文的一种载体，不考虑大规模实用化的问题。要么就彻底改头换面变成另外一个人，如果真走到这一步，我想问的是：你被别人称为高效版本的 RNN，你自己好意思答应吗？这就是 RNN 面临的两难境地。</p>
<p>再次，假设我们再乐观一点，把对 RNN 的改造方向定位为将 RNN 改造成类似 Transformer 的结构这种思路算进来：无非就是在 Transformer 的 Block 里，把某些部件，当然最可行的是把 Multi-head self attention 部件换成 RNN。我们就算退一步讲，且将这种大幅结构改造的模型也算做是 RNN 模型吧。</p>
<p>即使这样，已经把自己整形成长得很像 Transformer 了，RNN 依然面临上述原生 RNN 所面临的同样两个困境：一方面即使这种连变性削骨都上的大幅度整容版本的 RNN，效果虽然有明显提升，但是仍然比不过 Transformer；另外，一旦引入 RNN 构件，同样会触发 Transformer 结构的并行计算能力问题。所以，目前 Transformer 发动机看上去有点带不动 RNN 这个队友。</p>
<p>综合以上几个因素，我们可以看出，RNN 目前处于进退两难的地步，我觉得它被其它模型替换掉只是时间问题，而且好像留给它的时间不多了。当然，这是我个人意见。我说这番话的时候，你是不是又听到了水声？</p>
<p>我看到网上很多人还在推 RNN 说：其实还是 RNN 好用。我觉得这其实是一种错觉。之所以会产生这个错觉，原因来自两个方面：一方面是因为 RNN 发展历史长，所以有大量经过优化的 RNN 框架可用，这对技术选型选择困难症患者来说是个福音，因为你随手选一个知名度还可以的估计效果就不错，包括对一些数据集的前人摸索出的超参数或者调参经验；而 Transformer 因为历史太短，所以各种高效的语言版本的优秀框架还少，选择不多。另外，其实我们对 Transformer 为何有效目前还不是特别清楚，包括相关的各种数据集合上的调参经验公开的也少，所以会觉得调起来比较费劲。随着框架越来越多，以及经验分享越来越充分，这个不再会是问题。这是一方面。</p>
<p>另外一方面，很多人反馈对于小数据集 RNN 更好用，这固然跟 Transformer 的参数量比较多有关系，但是也不是没有解决办法，一种方式是把 Block 数目降低，减少参数量；第二种办法是引入 Bert 两阶段训练模型，那么对于小数据集合来说会极大缓解效果问题。所以综合这两方面看，RNN 貌似在某些场合还有优势，但是这些所谓的优势是很脆弱的，这其实反映的是我们对 Transformer 整体经验不足的事实，随着经验越来越丰富，RNN 被 Transformer 取代基本不会有什么疑问。</p>
<h3 id="一希尚存的-CNN"><a href="#一希尚存的-CNN" class="headerlink" title="一希尚存的 CNN"></a>一希尚存的 CNN</h3><p>CNN 在 14 年左右在 NLP 界刚出道的时候，貌似跟 RNN 比起来表现并不算太好，算是落后生，但是用发展的眼光看，未来的处境反而看上去比 RNN 的状态还要占优一些。</p>
<p>之所以造成这个奇怪现象，最主要的原因有两个：一个是因为 CNN 的天生自带的高并行计算能力，这对于延长它的生命力发挥了很大作用。这就决定了与 Transformer 比起来，它并不存在无法克服的困难，所以仍然有希望；第二，早期的 CNN 做不好 NLP 的一个很大原因是网络深度做不起来，随着不断借鉴图像处理的新型 CNN 模型的构造经验，以及一些深度网络的优化 trick，CNN 在 NLP 领域里的深度逐步能做起来了。</p>
<p>而既然深度能做起来，那么本来 CNN 做 NLP 天然的一个缺陷：无法有效捕获长距离特征的问题，就得到了极大缓解。目前看可以靠堆深度或者结合 dilated CNN 来一定程度上解决这个问题，虽然还不够好，但是仍然是那句话，希望还在。</p>
<p>但是，上面所说只是从道理分析角度来讲 CNN 的希望所在，话分两头，我们说回来，目前也有很多实验证明了原生的 CNN 在很多方面仍然是比不过 Transformer 的，典型的还是长距离特征捕获能力方面，原生的 CNN 版本模型仍然极为显著地弱于 RNN 和 Transformer，而这点在 NLP 界算是比较严重的缺陷。</p>
<p>好，你可以说：那我们把 CNN 引到 Transformer 结构里，比如代替掉 Self attention，这样和 Transformer 还有一战吧？嗯，是的，目前看貌似只有这条路是能走的通的，引入 depth separate CNN 可以达到和 Transformer 接近的效果。但是，我想问的是：你确认长成这样的 CNN，就是把 CNN 塞到 Transformer Block 的肚子里，你确认它的亲朋好友还能认出它吗？</p>
<p>当然，我之所以写 CNN 一希尚存，是因为我觉得把 CNN 塞到 Transformer 肚子里这种方案，对于篇章级别的 NLP 任务来说，跟采取 self attention 作为发动机的 Transformer 方案对比起来，是具有极大优势的领域，也是适合它的战场，后面我估计会出现一些这方面的论文。为什么这么讲？原因下面会说。</p>
<h3 id="稳操胜券的-transformer"><a href="#稳操胜券的-transformer" class="headerlink" title="稳操胜券的 transformer"></a>稳操胜券的 transformer</h3><p>我们在分析未来 NLP 的三大特征抽取器哪个会胜出，我认为，起码根据目前的信息来看，其实 Transformer 在很多战场已经赢了，在这些场地，它未来还会继续赢。为什么呢？上面不是说了吗，原生的 RNN 和 CNN，总有一些方面显著弱于 Transformer（并行计算能力或者效果，或者两者同时都比 Transformer 弱）。那么他们未来的希望，目前大家都寄托在把 RNN 和 CNN 寄生在 Transformer Block 里。RNN 不用说了，上面说过它的进退维艰的现状。单说 CNN 吧，还是上一部分的那句话，我想问的是：你确认长成这样的 CNN，就是把 CNN 塞到 Transformer Block 的肚子里，你确认它的亲朋还能认出它吗？</p>
<p>目前能够和 Transformer 一战的 CNN 模型，基本都已经长成 Transformer 的模样了。而这又说明了什么呢？难道这是 CNN 要能战胜 Transformer 的迹象吗？这是一道留给您的思考题和辩论题。当然，我不参加辩论。</p>
<p>Transformer 作为一个新模型，并不是完美无缺的。它也有明显的缺点：首先，对于长输入的任务，典型的比如篇章级别的任务（例如文本摘要），因为任务的输入太长，Transformer 会有巨大的计算复杂度，导致速度会急剧变慢。所以估计短期内这些领地还能是 RNN 或者长成 Transformer 模样的 CNN 的天下（其实目前他俩这块做得也不好），也是目前看两者的希望所在，尤其是 CNN 模型，希望更大一些。但是是否 Transformer 针对长输入就束手无策，没有解决办法呢？我觉得其实并不是，比如拍脑袋一想，就能想到一些方法，虽然看上去有点丑陋。比如可以把长输入切断分成 K 份，强制把长输入切短，再套上 Transformer 作为特征抽取器，高层可以用 RNN 或者另外一层 Transformer 来接力，形成 Transformer 的层级结构，这样可以把 n 平方的计算量极大减少。</p>
<p>当然，这个方案不优雅，这个我承认。但是我提示你一下：这个方向是个值得投入精力的好方向，你留意一下我这句话，也许有意想不到的收获。（注：上面这段话是我之前早已写好的，结果今天（1 月 12 日）看见媒体号在炒作：「Transforme-XL，速度提升 1800 倍」云云。看了新闻，我找来 Transformer-XL 论文看了一下，发现它解决的就是输入特别长的问题，方法呢其实大思路和上面说的内容差不太多。</p>
<p>说这么多的意思是：我并不想删除上面内容，为避免发出来后，那位「爱挑刺」同学说我拷贝别人思路没引用。我决定还是不改上面的说法，因为这个点子实在是太容易想到的点子，我相信你也能想到。）除了这个缺点，Transformer 整体结构确实显得复杂了一些，如何更深刻认识它的作用机理，然后进一步简化它，这也是一个好的探索方向，这句话也请留意。还有，上面在做语义特征抽取能力比较时，结论是对于距离远与 13 的长距离特征，Transformer 性能弱于 RNN，说实话，这点是比较出乎我意料的，因为 Transformer 通过 Self attention 使得远距离特征直接发生关系，按理说距离不应该成为它的问题，但是效果竟然不如 RNN，这背后的原因是什么呢？这也是很有价值的一个探索点。</p>
<p>我预感到我可能又讲多了，能看到最后不容易，上面几段话算是送给有耐心的同学的礼物，其它不多讲了，就此别过，请忽略你听到的哗哗的水声。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2018\03\28\AMPC-1080Ti机器-深度环境搭建\" rel="bookmark">AMPC-1080Ti机器-深度环境搭建</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2018\03\12\coursera深度学习笔记\" rel="bookmark">coursera深度学习笔记</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2018\03\24\使用Google-Colaboratory免费GPU\" rel="bookmark">使用Google Colaboratory免费GPU</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div>一分一毛，也是心意。</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Run-Qing Chen 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Run-Qing Chen 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Run-Qing Chen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://blog.rexking6.top/2021/07/20/Transformer/" title="Transformer">https://blog.rexking6.top/2021/07/20/Transformer/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag"># 深度学习</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/17/%E5%81%A5%E5%BA%B7/" rel="prev" title="健康">
      <i class="fa fa-chevron-left"></i> 健康
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/24/Docker-k8s/" rel="next" title="Docker & k8s">
      Docker & k8s <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

    <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Transformer"><span class="nav-number">2.</span> <span class="nav-text">Transformer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Transformer-%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">Transformer 结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.1.</span> <span class="nav-text">总体结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Encoder%E5%B1%82%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.2.</span> <span class="nav-text">Encoder层结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Positional-Encoding"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">Positional Encoding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Self-Attention"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">Self-Attention</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Multi-Headed-Attention"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">Multi-Headed Attention</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Layer-normalization"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">Layer normalization</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Feed-Forward-Neural-Network"><span class="nav-number">2.1.2.5.</span> <span class="nav-text">Feed Forward Neural Network</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Decoder%E5%B1%82%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.3.</span> <span class="nav-text">Decoder层结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#masked-mutil-head-attetion"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">masked mutil-head attetion</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Output%E5%B1%82"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">Output层</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">2.1.4.</span> <span class="nav-text">动态流程图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Transformer%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8CMulti-head-Attention%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">Transformer为什么需要进行Multi-head Attention？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Transformer%E7%9B%B8%E6%AF%94%E4%BA%8ERNN-LSTM%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.3.</span> <span class="nav-text">Transformer相比于RNN&#x2F;LSTM，有什么优势，为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Transformer%E5%8F%AF%E4%BB%A5%E4%BB%A3%E6%9B%BFseq2seq%EF%BC%9F"><span class="nav-number">2.4.</span> <span class="nav-text">为什么说Transformer可以代替seq2seq？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CNN-RNN-TF%E6%AF%94%E8%BE%83"><span class="nav-number">3.</span> <span class="nav-text">CNN&#x2F;RNN&#x2F;TF比较</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%98%E5%9C%BA%E4%BE%A6%E6%9F%A5%EF%BC%9ANLP-%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%8A%E4%BB%BB%E5%8A%A1%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">战场侦查：NLP 任务的特点及任务类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B2%99%E5%9C%BA%E8%80%81%E5%B0%86-RNN%EF%BC%9A%E5%BB%89%E9%A2%87%E8%80%81%E7%9F%A3%EF%BC%8C%E5%B0%9A%E8%83%BD%E9%A5%AD%E5%90%A6"><span class="nav-number">3.2.</span> <span class="nav-text">沙场老将 RNN：廉颇老矣，尚能饭否</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95-RNN-%E8%83%BD%E5%A4%9F%E6%88%90%E4%B8%BA%E8%A7%A3%E5%86%B3-NLP-%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%BB%E6%B5%81%E7%89%B9%E5%BE%81%E6%8A%BD%E5%8F%96%E5%99%A8"><span class="nav-number">3.2.1.</span> <span class="nav-text">为何 RNN 能够成为解决 NLP 问题的主流特征抽取器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RNN-%E5%9C%A8%E6%96%B0%E6%97%B6%E4%BB%A3%E9%9D%A2%E4%B8%B4%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%B8%A5%E9%87%8D%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.2.</span> <span class="nav-text">RNN 在新时代面临的两个严重问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%94%B9%E9%80%A0-RNN-%E4%BD%BF%E5%85%B6%E5%85%B7%E5%A4%87%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E8%83%BD%E5%8A%9B%EF%BC%9F"><span class="nav-number">3.2.3.</span> <span class="nav-text">如何改造 RNN 使其具备并行计算能力？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%8F%E5%B8%88%E4%B9%8B%E5%B0%86-CNN%EF%BC%9A%E5%88%BA%E6%BF%80%E6%88%98%E5%9C%BA%E7%BB%9D%E5%9C%B0%E6%B1%82%E7%94%9F"><span class="nav-number">3.3.</span> <span class="nav-text">偏师之将 CNN：刺激战场绝地求生</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NLP-%E4%B8%AD%E6%97%A9%E6%9C%9F%E7%9A%84%E6%80%80%E6%97%A7%E7%89%88-CNN-%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.3.1.</span> <span class="nav-text">NLP 中早期的怀旧版 CNN 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CNN-%E7%9A%84%E8%BF%9B%E5%8C%96%EF%BC%9A%E7%89%A9%E7%AB%9E%E5%A4%A9%E6%8B%A9%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%96%97%E5%85%BD%E5%9C%BA"><span class="nav-number">3.3.2.</span> <span class="nav-text">CNN 的进化：物竞天择的模型斗兽场</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%99%BD%E8%A1%A3%E9%AA%91%E5%A3%AB-Transformer%EF%BC%9A%E7%9B%96%E4%B8%96%E8%8B%B1%E9%9B%84%E7%AB%99%E4%B8%8A%E8%88%9E%E5%8F%B0"><span class="nav-number">3.4.</span> <span class="nav-text">白衣骑士 Transformer：盖世英雄站上舞台</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8E%E5%B1%B1%E8%AE%BA%E5%89%91%EF%BC%9A%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E6%8A%BD%E5%8F%96%E5%99%A8%E6%AF%94%E8%BE%83"><span class="nav-number">3.5.</span> <span class="nav-text">华山论剑：三大特征抽取器比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E4%B9%89%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E8%83%BD%E5%8A%9B"><span class="nav-number">3.5.1.</span> <span class="nav-text">语义特征提取能力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E8%B7%9D%E7%A6%BB%E7%89%B9%E5%BE%81%E6%8D%95%E8%8E%B7%E8%83%BD%E5%8A%9B"><span class="nav-number">3.5.2.</span> <span class="nav-text">长距离特征捕获能力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%BB%BC%E5%90%88%E7%89%B9%E5%BE%81%E6%8A%BD%E5%8F%96%E8%83%BD%E5%8A%9B"><span class="nav-number">3.5.3.</span> <span class="nav-text">任务综合特征抽取能力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E8%83%BD%E5%8A%9B%E5%8F%8A%E8%BF%90%E7%AE%97%E6%95%88%E7%8E%87"><span class="nav-number">3.5.4.</span> <span class="nav-text">并行计算能力及运算效率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E6%8E%92%E5%90%8D%E6%83%85%E5%86%B5"><span class="nav-number">3.5.5.</span> <span class="nav-text">综合排名情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E8%80%85%E7%9A%84%E5%90%88%E6%B5%81%EF%BC%9A%E5%90%91-Transformer-%E9%9D%A0%E6%8B%A2"><span class="nav-number">3.6.</span> <span class="nav-text">三者的合流：向 Transformer 靠拢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2019-%E6%9D%A5%E8%87%AA%E6%9C%AA%E6%9D%A5%E7%9A%84%E6%B6%88%E6%81%AF%EF%BC%9A%E6%80%BB%E7%BB%93"><span class="nav-number">3.7.</span> <span class="nav-text">2019 来自未来的消息：总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E9%80%80%E7%BB%B4%E8%B0%B7%E7%9A%84-RNN"><span class="nav-number">3.7.1.</span> <span class="nav-text">进退维谷的 RNN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E5%B8%8C%E5%B0%9A%E5%AD%98%E7%9A%84-CNN"><span class="nav-number">3.7.2.</span> <span class="nav-text">一希尚存的 CNN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%B3%E6%93%8D%E8%83%9C%E5%88%B8%E7%9A%84-transformer"><span class="nav-number">3.7.3.</span> <span class="nav-text">稳操胜券的 transformer</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Run-Qing Chen"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Run-Qing Chen</p>
  <div class="site-description" itemprop="description">覆苍天以为衾，卧大地以为庐。</div>
</div>


   <div class="feed-link motion-element">
     <a href="/atom.xml" rel="alternate">
       <i class="fa fa-rss"></i>
       RSS
     </a>
   </div>
 
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">216</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RexKing6" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RexKing6" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1010026261@qq.com" title="E-Mail → mailto:1010026261@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.zxpblog.cn/" title="https:&#x2F;&#x2F;www.zxpblog.cn&#x2F;" rel="noopener" target="_blank">赵小平</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://whitepuffer.github.io/" title="https:&#x2F;&#x2F;whitepuffer.github.io&#x2F;" rel="noopener" target="_blank">江斓</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kexue.fm/" title="https:&#x2F;&#x2F;kexue.fm&#x2F;" rel="noopener" target="_blank">科学空间</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yongyuan.name/" title="https:&#x2F;&#x2F;yongyuan.name&#x2F;" rel="noopener" target="_blank">袁勇</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/abcjennifer" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;abcjennifer" rel="noopener" target="_blank">Rachel Zhang</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://dmkf.xyz/" title="http:&#x2F;&#x2F;dmkf.xyz&#x2F;" rel="noopener" target="_blank">代码咖啡</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://wuxiaolong.me/" title="http:&#x2F;&#x2F;wuxiaolong.me&#x2F;" rel="noopener" target="_blank">吴小龙同学</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.tennfy.com/" title="http:&#x2F;&#x2F;www.tennfy.com&#x2F;" rel="noopener" target="_blank">TENNFY WU</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fab fa-accessible-icon"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Run-Qing Chen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">3.8m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">56:52</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"6XDsO3aHIjDk3nV6eLJCufbl-MdYXbMMI","app_key":"YK4qOc0TpkazN6exhuqsnwmB","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
