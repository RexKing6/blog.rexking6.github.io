<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.rexking6.top","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#37c6c0","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"YS7HT61SEB","apiKey":"0fd1eba022e7883c76ff4a71aee2acdc","indexName":"blog_NAME","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"找不到关于 ${query} 的文章","hits_stats":"共找到 ${hits} 篇文章，花了 ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="...">
<meta property="og:type" content="article">
<meta property="og:title" content="基于时间序列的异常检测">
<meta property="og:url" content="https://blog.rexking6.top/2018/11/05/%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/">
<meta property="og:site_name" content="RexKing6&#39;s Note">
<meta property="og:description" content="...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://image.rexking6.top/img/clip1541314641.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1541314841.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1541315241.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1541172227.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1541172603.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1541239974.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1541239998.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1541169228.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1541320628.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1541320933.png">
<meta property="article:published_time" content="2018-11-05T03:39:05.000Z">
<meta property="article:modified_time" content="2021-07-25T15:45:07.551Z">
<meta property="article:author" content="Run-Qing Chen">
<meta property="article:tag" content="时间序列">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://image.rexking6.top/img/clip1541314641.png">

<link rel="canonical" href="https://blog.rexking6.top/2018/11/05/%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>基于时间序列的异常检测 | RexKing6's Note</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="RexKing6's Note" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RexKing6's Note</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/rexking6" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.rexking6.top/2018/11/05/%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Run-Qing Chen">
      <meta itemprop="description" content="覆苍天以为衾，卧大地以为庐。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RexKing6's Note">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          基于时间序列的异常检测
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-05 11:39:05" itemprop="dateCreated datePublished" datetime="2018-11-05T11:39:05+08:00">2018-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-25 23:45:07" itemprop="dateModified" datetime="2021-07-25T23:45:07+08:00">2021-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">时间序列</span></a>
                </span>
            </span>

          
            <span id="/2018/11/05/%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/" class="post-meta-item leancloud_visitors" data-flag-title="基于时间序列的异常检测" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>搜罗了网上几乎所有的基于时间序列的异常检测方法，没有包括文献，整理记录一下。</p>
<p>综合引用以下文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/5377669/">数据挖掘导论</a></li>
<li><a target="_blank" rel="noopener" href="https://www.opsdev.cn/post/timeseries_anomaly_detection.html">时间序列异常检测机制的研究</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41201506">KPI异常检测竞赛笔记</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26648086">异常检测之时间序列的异常检测</a></li>
<li><a target="_blank" rel="noopener" href="https://jiroujuan.wordpress.com/2013/10/09/skyline-anomalous-detect-algorithms/">Skyline timeseries异常判定算法</a></li>
<li><a target="_blank" rel="noopener" href="http://chuansong.me/n/2032667">腾讯蓝鲸数据平台之告警系统</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30169110">异常点检测算法综述</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32584136">时间序列简介（一）</a></li>
</ul>
<h1 id="时间序列预测"><a href="#时间序列预测" class="headerlink" title="时间序列预测"></a>时间序列预测</h1><ul>
<li>周期性：AE/VAE</li>
<li>稳定性：ARIMA</li>
<li>不稳定性：频谱分析/小波分析</li>
</ul>
<p>RNN貌似对以上都适用。</p>
<h1 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h1><p>异常检测的方法有很多，根据《数据挖掘导论》，有以下几个分类：</p>
<h2 id="基于模型的方法"><a href="#基于模型的方法" class="headerlink" title="基于模型的方法"></a>基于模型的方法</h2><p>许多异常检测技术首先建立一个数据模型。异常是那些同模型不能完美拟合的对象。例如，数据分布模型可以通过估计概率分布的参数来创建。如果一个对象不能很好地同该模型拟合，即如果它很可能不服从该分布，则它是一个异常。如果模型是簇的集合，则异常是不显著属于任何簇的对象。在使用回归模型时，异常是相对远离预测值的对象。</p>
<p>由于异常和正常对象可以看作两个不同的类，因此可以使用分类方法来建立这两个类的模型。当然，仅当某些对象存在类标号，使得我们可以构造训练数据集时才可以使用分类方法。此外，异常相对稀少，在选择分类方法和评估度量是需要考虑这一因素。</p>
<p>基于模型的方法又称为统计方法，主要通过拟合单个模型或多个模型来判断该点的概率。</p>
<ul>
<li><p>单维情况</p>
<ul>
<li><p>3$\sigma$-法则</p>
<p>$(μ-3σ,μ+3σ)$区间内的概率为99.74。所以可以认为，当数据分布区间超过这个区间时，即可认为是异常数据。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30757480">箱型图</a></p>
<p>IQR是第三四分位数减去第一四分位数，大于Q3+1.5*IQR之外的数和小于Q1-1.5*IQR的值被认为是异常值。</p>
</li>
<li><p>Grubbs测试</p>
<p>Grubbs测试是一种从样本中找出outlier的方法，所谓outlier，是指样本中偏离平均值过远的数据，他们有可能是极端情况下的正常数据，也有可能是测量过程中的错误数据。使用Grubbs测试需要总体是正态分布的。</p>
<p><strong>算法流程：</strong></p>
<ol>
<li>样本从小到大排序</li>
<li>求样本的mean和std.dev</li>
<li>计算min/max与mean的差距，更大的那个为可疑值</li>
<li>求可疑值的z-score (standard score)，如果大于Grubbs临界值，那么就是outlier；</li>
</ol>
<p>Grubbs临界值可以查表得到，它由两个值决定：检出水平$α$（越严格越小），样本数量$n$。排除outlier，对剩余序列循环做 1-4 步骤。由于这里需要的是异常判定，只需要判断tail_avg是否outlier即可。</p>
</li>
</ul>
</li>
<li><p>高维情况</p>
<ul>
<li>Mahalanobis距离</li>
<li>$\mathcal{X}^2$统计</li>
<li>单个/混合高斯分布</li>
</ul>
</li>
</ul>
<p>在某些情况下，很难建立模型，例如，因为数据的统计分布未知或没有训练数据可用。在这些情况下，可以使用如下所述的不需要模型的技术。</p>
<h2 id="基于距离的方法-基于邻近度的方法"><a href="#基于距离的方法-基于邻近度的方法" class="headerlink" title="基于距离的方法/基于邻近度的方法"></a>基于距离的方法/基于邻近度的方法</h2><p>通常可以在对象之间定义邻近性度量，并且许多异常检测方法都基于邻近度。异常对象是那些远离大部分其他对象的对象。这一领域的许多方法都基于距离，称作基于距离的离群点检测方法。当数据能够以二维或三维散布图显示时，通过寻找与大部分其他点分离的点，可以从视觉上检测出基于距离的离群点。</p>
<p>但是该方法计算复杂度过高，且分布不均匀的点，容易出错。</p>
<p>方法：</p>
<ul>
<li><p>基于角度的离群点检测</p>
<p>角度越小，说明距离越远。</p>
</li>
<li><p>k-最近邻</p>
<p>到k-最近邻的距离。评分为数据对象与最近的k个点的距离之和。很明显，与k个最近点的距离之和越小，异常分越低；与k个最近点的距离之和越大，异常分越大。设定一个距离的阈值，异常分高于这个阈值，对应的数据对象就是异常点。</p>
</li>
<li><p>Local Outlier Factor（LOF）</p>
<p>LOF得分为数据对象的k个最近邻的平均局部密度与数据对象本身的局部密度之比。</p>
</li>
<li><p>Connectivity Outlier Factor（COF）</p>
<p>如果点p的平均连接距离大于它的k最近邻的平均连接距离，则点p是异常点。COF将异常值识别为其邻域比其近邻的邻域更稀疏的点。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34438518">stochastic outlier selection algorithm（无监督）</a></p>
<p>基于方差，近邻点越多，方差越小；近邻点越大，方差越大。</p>
</li>
</ul>
<h2 id="基于密度的方法"><a href="#基于密度的方法" class="headerlink" title="基于密度的方法"></a>基于密度的方法</h2><p>对象的密度估计可以相对直接地计算，特别是当对象之间存在邻近性度量时，低密度区域中的对象相对远离近邻，可能被看作异常。一种更复杂的方法考虑到数据集可能有不同密度区域这一事实，仅当一个点的局部密度显著地低于它的大部分近邻时才将其分类为离群点。</p>
<p><strong>定义1：基于密度的异常</strong></p>
<p>异常就是那些在低密度区域的数据对象，一个数据对象的异常分就是该对象所在区域的密度的倒数，下面是基于密度的异常分的计算公式：</p>
<script type="math/tex; mode=display">
densitiy(x,k)=(\frac{\sum_{y\in N(x,k)}distance(x,y)}{|N(x,k)|})^{-1}</script><p>其中$N(x,k)$指的是$x$的$k$个最近的邻居的集合，$|N(x,k)|$表示该集合的大小，$y$是$x$最近的邻居。</p>
<p><strong>定义2：给定半径的邻域内的数据对象数</strong></p>
<p>一个数据对象的密度等于半径为d的邻域内的数据对象数。</p>
<p>d的选择很重要，若d太小，则会有很多正常的数据对象被认为是异常点；若d太大，则很多异常数据对象会被误判为正常点。事实上，当密度分布不均匀的时候，上述方法得到的异常点会不正确。为了克服密度不均匀的情况，我们使用下面的平均相对密度来作为异常分。</p>
<p><strong>定义3：平均相对密度</strong></p>
<script type="math/tex; mode=display">
average\ relative\ densitiy(x,k)=(\frac{density(x,k)}{\Sigma _{y\in N(x,k)}density(y,k)/|N(x,k)| })</script><p><strong>基于相对密度的异常检测算法</strong></p>
<ol>
<li>{$k$是最近邻的个数}（类似KNN中的$k$）</li>
<li>for 所有的数据对象$x$ do<ol>
<li>计算$N(x,k)$</li>
<li>计算$density(x,k)$</li>
</ol>
</li>
<li>end for</li>
<li>for 所有的数据对象x do<ol>
<li>$outlier score(x) = average relative density(x,k)$</li>
</ol>
</li>
<li>end for</li>
<li>取$outlier score$最大的$N$个数据对象作为异常</li>
</ol>
<h2 id="基于聚类的方法"><a href="#基于聚类的方法" class="headerlink" title="基于聚类的方法"></a>基于聚类的方法</h2><p>一种利用聚类检测离群点的方法是丢弃远离其他簇的小簇。这种方法可以与任何聚类方法一起使用，但是需要最小簇大小和小簇与其他簇之间距离的國值。通常，该过程可以简化为丢弃小于某个最小尺寸的所有簇。这种方案对簇个数的选择高度敏感。此外，使用这一方案，很难将离群点得分附加在对象上。注意，把一组对像看作离群点，将离群点的概念从个体对象扩展到对象组，但是本质上没有任何改变。</p>
<p>一种更系统的方法是，首先聚类所有对象，然后评估对象属于簇的程度。对于基于原型的聚类，可以用对象到它的簇中心的距离来度量对象属于簇的程度。更一般地，对于基于目标函数的聚类方法，可以使用该目标函數来评估对象属于任意簇的程度。特殊情况下，如果删除一个对象导致该目标的显著改进，则我们可以将对象分类为离群点。如，对于K均值，脷除远离其相关簇中心的对象能够显著地改进簇的误差的平方和（SSE）。总而言之，聚类创建数据的模型，而异常扭曲模型。</p>
<h2 id="基于划分的方法"><a href="#基于划分的方法" class="headerlink" title="基于划分的方法"></a>基于划分的方法</h2><p>孤立森林</p>
<p>基于划分的思想，划分成树，深度越低，说明越容易被划分，即为离群点。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4d817084a69a">https://www.jianshu.com/p/4d817084a69a</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5af3c66e0410">https://www.jianshu.com/p/5af3c66e0410</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/fengfenggirl/p/iForest.html">http://www.cnblogs.com/fengfenggirl/p/iForest.html</a></li>
</ul>
<h2 id="基于线性的方法"><a href="#基于线性的方法" class="headerlink" title="基于线性的方法"></a>基于线性的方法</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e35a47913457">Principal Component Analysis（PCA）</a></p>
<p>PCA在做特征值分解之后得到的特征向量反应了原始数据方差变化程度的不同方向，特征值为数据在对应方向上的方差大小。所以，最大特征值对应的特征向量为数据方差最大的方向，最小特征值对应的特征向量为数据方差最小的方向。原始数据在不同方向上的方差变化反应了其内在特点。如果单个数据样本跟整体数据样本表现出的特点不太一致，比如在某些方向上跟其它数据样本偏离较大，可能就表示该数据样本是一个异常点。</p>
</li>
</ul>
<h2 id="基于非线性的方法"><a href="#基于非线性的方法" class="headerlink" title="基于非线性的方法"></a>基于非线性的方法</h2><ul>
<li>Replicator Neural Networks（RNNs）</li>
<li>AutoEncoder（AE）：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e31ff328b682">Anomaly Detection异常检测的几种方法</a></li>
<li>Variational AutoEncoder（VAE）：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/45400663">AIOps探索：基于VAE模型的周期性KPI异常检测方法</a></li>
</ul>
<h2 id="针对非数值型的方法"><a href="#针对非数值型的方法" class="headerlink" title="针对非数值型的方法"></a>针对非数值型的方法</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32085986">Attribute Value Frequency</a></p>
<p>针对非数值型的数据，即类别离散数据的方法。</p>
</li>
</ul>
<h2 id="基于深度学习的方法"><a href="#基于深度学习的方法" class="headerlink" title="基于深度学习的方法"></a>基于深度学习的方法</h2><ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1901.03407">Deep Learning for Anomaly Detection: A Survey</a></li>
</ul>
<p>相关综述可以阅读上面的文献。另外，随着贝叶斯与深度网络的结合，能够衡量模型的不确定性的贝叶斯深度网络在各个领域中应用广泛，也诞生了很多专门针对于神经网络计算不确定性的方法，具体文献可以参考<a target="_blank" rel="noopener" href="http://mlg.eng.cam.ac.uk/yarin/thesis/thesis.pdf">Uncertainty in Deep Learning</a>。<a href="http://blog.rexking6.top/2019/02/14/%E3%80%8ADeep-and-Confident-Prediction-for-Time-Series-at-Uber%E3%80%8B%E7%AC%94%E8%AE%B0/">另外一篇博客</a>介绍的Uber用于预测和检测的一个框架，就是基于不确定性的思路做的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实，可以看到，以上方法的分类之间也是相近的，说到底，概率、密度和聚类也是由空间中的数据点之间的距离所决定的。而本文主要是想记录基于时间序列的异常检测方法，当然，以上的方法，在时间序列抽取后的特征空间中也能够使用。</p>
<h1 id="基于时间序列的异常检测方法"><a href="#基于时间序列的异常检测方法" class="headerlink" title="基于时间序列的异常检测方法"></a>基于时间序列的异常检测方法</h1><p><strong>同比，是指在相邻时段中的某一相同时间点进行比较。</strong></p>
<p><strong>环比，是指在同一时段中的相邻时间点进行比较。</strong></p>
<h2 id="短期环比（SS）"><a href="#短期环比（SS）" class="headerlink" title="短期环比（SS）"></a>短期环比（SS）</h2><p>对于时间序列（是指将同一统计指标的数值按其发生的时间先后顺序排列而成的数列）来说，$T$时刻的数值对于$T-1$时刻有很强的依赖性。比如流量在8:00很多，在8:01时刻的概率是很大的，但是如果07:01时刻对于8:01时刻影响不是很大。</p>
<p>首先，我们可以使用最近时间窗口（$T$）内的数据遵循某种趋势的现象来做文章。比如我们将$T$设置为7，则我们取检测值（$now_value$）和过去7个（记为$i$）点进行比较，如果大于阈值我们将$count$加1，如果$count$超过我们设置的$count_num$，则认为该点是异常点。</p>
<script type="math/tex; mode=display">
count(\sum_{i=0}^T(now\ value-i)>threshold)>count\_num</script><p>上面的公式涉及到$threshold$和$count_num$两个参数，$threshold$如何获取我们将在下节进行介绍，而$count_num$可以根据的需求进行设置，比如对异常敏感，可以设置$count_num$小一些，而如果对异常不敏感，可以将$count_num$设置的大一些。</p>
<h3 id="动态阈值"><a href="#动态阈值" class="headerlink" title="动态阈值"></a>动态阈值</h3><p>业界关于动态阈值设置的方法有很多，这里介绍一种针对360的lvs流量异常检测的阈值设置方法。通常阈值设置方法会参考过去一段时间内的均值、最大值以及最小值，我们也同样应用此方法。取过去一段时间（比如$T$窗口）的平均值、最大值以及最小值，然后取$max-avg$和$avg-min$的最小值。之所以取最小值的原因是让筛选条件设置的宽松一些，让更多的值通过此条件，减少一些漏报的事件。</p>
<script type="math/tex; mode=display">
threshold = min(max-avg, avg-min)</script><h3 id="窗口特征"><a href="#窗口特征" class="headerlink" title="窗口特征"></a>窗口特征</h3><h4 id="统计特征"><a href="#统计特征" class="headerlink" title="统计特征"></a>统计特征</h4><h5 id="3-sigma"><a href="#3-sigma" class="headerlink" title="3-sigma"></a>3-sigma</h5><p>一个很直接的异常判定思路是，拿最新3个datapoint的平均值（tail_avg方法）和整个序列比较，看是否偏离总体平均水平太多。怎样算“太多”呢，因为standard deviation表示集合中元素到mean的平均偏移距离，因此最简单就是和它进行比较。在normal distribution（正态分布）中，99.73%的数据都在偏离mean 3个σ (standard deviation 标准差) 的范围内。如果某些datapoint到mean的距离超过这个范围，则认为是异常的。</p>
<h5 id="z-score"><a href="#z-score" class="headerlink" title="z score"></a>z score</h5><p>标准分，一个个体到集合mean的偏离，以标准差为单位，表达个体距mean相对“平均偏离水平（std dev表达）”的偏离程度，常用来比对来自不同集合的数据。</p>
<p>在模型中，z_score用来衡量窗口数据中，中间值的偏离程度。</p>
<p><strong>算法流程：</strong></p>
<ol>
<li>排除最后一个值</li>
<li>求剩余序列的平均值</li>
<li>全序列减去上面这个平均值</li>
<li>求剩余序列的标准差</li>
<li>（ 中间三个数的平均值-全序列均值）/ 全序列标准差</li>
</ol>
<h5 id="Grubbs格拉斯测试"><a href="#Grubbs格拉斯测试" class="headerlink" title="Grubbs格拉斯测试"></a>Grubbs格拉斯测试</h5><p>Grubbs测试是一种从样本中找出outlier的方法，所谓outlier，是指样本中偏离平均值过远的数据，他们有可能是极端情况下的正常数据，也有可能是测量过程中的错误数据。使用Grubbs测试需要总体是正态分布的。</p>
<p><strong>算法流程：</strong></p>
<ol>
<li>样本从小到大排序</li>
<li>求样本的mean和std.dev</li>
<li>计算min/max与mean的差距，更大的那个为可疑值</li>
<li>求可疑值的z-score (standard score)，如果大于Grubbs临界值，那么就是outlier；</li>
</ol>
<p>Grubbs临界值可以查表得到，它由两个值决定：检出水平$α$（越严格越小），样本数量$n$。排除outlier，对剩余序列循环做 1-4 步骤。由于这里需要的是异常判定，只需要判断tail_avg是否outlier即可。</p>
<h5 id="moving-average（移动平均）"><a href="#moving-average（移动平均）" class="headerlink" title="moving average（移动平均）"></a>moving average（移动平均）</h5><p>给定一个时间序列和窗口长度$N$，moving average等于当前data point之前$N$个点（包括当前点）的平均值。不停地移动这个窗口，就得到移动平均曲线。</p>
<h5 id="cumulative-moving-average（累加移动平均）"><a href="#cumulative-moving-average（累加移动平均）" class="headerlink" title="cumulative moving average（累加移动平均）"></a>cumulative moving average（累加移动平均）</h5><p>设$\{x_i:i \ge 1\}$是观察到的数据序列。 累积移动平均线是所有数据的未加权平均值。 如果若干天的值是$x_1,…,x_i$，那么</p>
<script type="math/tex; mode=display">
CMA_i=\frac{x_1+...+x_i}{i}</script><p>当有新的值$x_{i+1}$，那么累积移动平均为</p>
<script type="math/tex; mode=display">
\begin{align*}
CMA_{i+1} &= \frac{x_1+...+x_i+x_{i+1}}{i+1} \\
& = \frac{x_{i+1}+n·CMA_i}{i+1}\\
& = CMA_i + \frac{x_{i+1}-CMA_i}{i+1}
\end{align*}</script><h5 id="weighted-moving-average（加权移动平均）"><a href="#weighted-moving-average（加权移动平均）" class="headerlink" title="weighted moving average（加权移动平均）"></a>weighted moving average（加权移动平均）</h5><p>加权移动平均值是先前$w$个数据的加权平均值。 假设$\sum_{j=0}^{w-1}weight_j=1$，其中$weight_j&gt;0$，则加权移动平均值为，</p>
<script type="math/tex; mode=display">
WMA_i=\sum_{j=0}^{w-1}weight_j · x_{i-j}</script><p>一般，</p>
<script type="math/tex; mode=display">
weight_j = \frac{w-j}{w+(w-1)+...+1}, for\ 0\le j \le w-1</script><p>所以，</p>
<script type="math/tex; mode=display">
WMA_i=\frac{wx_i+(w-1)x_{i-1}+...+2x_{i-w+2}+x_{i-w+1}}{w+(w-1)+...+1}</script><h5 id="exponential-weighted-moving-average（指数加权移动平均）"><a href="#exponential-weighted-moving-average（指数加权移动平均）" class="headerlink" title="exponential weighted moving average（指数加权移动平均）"></a>exponential weighted moving average（指数加权移动平均）</h5><p>指数移动与移动平均有些不同：</p>
<ol>
<li>并没有时间窗口，用的是从时间序列第一个data point到当前data point之间的所有点。</li>
<li>每个data point的权重不同，离当前时间点越近的点的权重越大，历史时间点的权重随着离当前时间点的距离呈指数衰减，从当前data point往前的data point，权重依次为$α$, $α(1-α)$, $α(1-α)^2$,…, $α(1-α)^n$。</li>
</ol>
<p>该算法可以检测一个异常较短时间后发生另外一个异常的情况，异常持续一段时间后可能被判定为正常。</p>
<p>PS：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a2dbd47b3f1a">https://www.jianshu.com/p/a2dbd47b3f1a</a></p>
<h5 id="double-exponential-smoothing（双指数平滑）"><a href="#double-exponential-smoothing（双指数平滑）" class="headerlink" title="double exponential smoothing（双指数平滑）"></a>double exponential smoothing（双指数平滑）</h5><p>假设$\{Y_t:t\ge1\}$是观测数据序列，有两个与双指数平滑相关的方程：</p>
<script type="math/tex; mode=display">
S_t = \alpha Y_t+(1-\alpha)(S_{t-1}+b_{t-1}),\\
b_t = \beta(S_t-S_{t-1})+(1-\beta)b_{t-1}</script><p>其中$\alpha \in [0,1]$是数据平滑因子，$\beta \in [0,1]$是趋势平滑因子。</p>
<p>这里，初始值为$S_1=Y_1$，$b_1$有三种可能：</p>
<script type="math/tex; mode=display">
b_1=Y_2-Y_1,\\
b_1 = \frac{(Y_2-Y_1)+(Y_3-Y_2)+(Y_4-Y_3)}{3}=\frac{Y_4-Y_1}{3},\\
b_1 = \frac{Y_n-Y_1}{n-1}</script><p>预测：</p>
<ul>
<li>单个时刻：$F_{t+1}=S_t+b_t$</li>
<li>$m$个时刻：$F_{t+m}=S_t+mb_t$</li>
</ul>
<h5 id="triple-exponential-smoothing（三指数平滑）（Holt-Winters）"><a href="#triple-exponential-smoothing（三指数平滑）（Holt-Winters）" class="headerlink" title="triple exponential smoothing（三指数平滑）（Holt-Winters）"></a>triple exponential smoothing（三指数平滑）（Holt-Winters）</h5><ul>
<li><p>multiplicative seasonality</p>
<p>设$\{Y_t:t \ge 1\}$是观察到的数据序列，则三指数平滑为</p>
<script type="math/tex; mode=display">
S_t = \alpha \frac{Y_t}{c_{t-L}}+(1-\alpha)(S_{t-1}+b_{t-1}),overall\ smoothing \\
b_t = \beta(S_t-S_{t-1})+(1-\beta)b_{t-1},trend\ smoothing\\
c_t = \gamma\frac{Y_t}{S_t}+(1-\gamma)c_{t-L}, seasonal smoothing</script><p>其中$\alpha \in [0,1]$是数据平滑因子，$\beta \in [0,1]$是趋势平滑因子， $\gamma \in [0,1]$是季节变化平滑因子。</p>
<p>预测$m$个时刻：$F_{t+m}=(S_t+mb_t)c_{(t-L+m) mod L}$</p>
<p>初始值设定：</p>
<script type="math/tex; mode=display">
S_1 = Y_1,\\
b_0 = \frac{(Y_{L+1}-Y_1)+(Y_{L+2}-Y_2)+...+(Y_{L+L}-Y_L)}{L},\\
c_i = \frac{1}{N}\sum_{j=1}^N\frac{Y_{L(j-1)+i}}{A_j}, \forall i \in \{1,...,L\}\\
A_j=\frac{\sum_{i=1}^LY_{L(j-1)+i}}{L}, \forall \in \{1,...,N\}</script></li>
<li><p>additive seasonality</p>
<p>设$\{Y_t:t \ge 1\}$是观察到的数据序列，则三指数平滑为</p>
<script type="math/tex; mode=display">
S_t = \alpha(Y_t-c_{t-L})+(1-\alpha)(S_{t-1}+b_{t-1}), overall \ smoothing \\
b_t = \beta(S_t- S_{t-1})+(1-\beta)b_{t-1}, trend \ smoothing \\
c_t = \gamma(Y_t-S_{t-1}-b_{t-1})+(1-\gamma)c_{t-L}, seasonal smoothing</script><p>其中$\alpha \in [0,1]$是数据平滑因子，$\beta \in [0,1]$是趋势平滑因子， $\gamma \in [0,1]$是季节变化平滑因子。</p>
<p>预测$m$个时刻：$F_{t+m}=S_t+mb_t+c_{(t-L+m) mod  L}$</p>
</li>
</ul>
<h5 id="stddev-from-average（平均值-标准差）"><a href="#stddev-from-average（平均值-标准差）" class="headerlink" title="stddev from average（平均值-标准差）"></a>stddev from average（平均值-标准差）</h5><p>该算法类似于3sigma准则。当数据服从高斯分布时，数值分布在$(μ-3σ,μ+3σ)$区间内的概率为99.74。所以，可以这么认为，当数据分布区间超过这个区间时，即可认为是异常数据。该算法使用$(t-mean)/std$ 作为特征，用于衡量中间三个值的平均值相对于$3σ$的距离。</p>
<p>该算法的特点是可以有效屏蔽“在一个点上突变到很大的异常值但在下一个点回落到正常水平”的情况，即屏蔽单点毛刺：因为它使用的是3个点的均值（有效缓和突变），和整个序列比较（均值可能被异常值拉大），导致判断正常。</p>
<p><strong>算法流程：</strong></p>
<ol>
<li>求窗口数据的平均值。 (mean)</li>
<li>求窗口数据的标准差。 (std)</li>
<li>求窗口数据中间3个值的平均值。（t）</li>
<li>使用$(t-mean)/std$作为特征。</li>
</ol>
<h5 id="stddev-from-moving-average（移动平均-标准差）"><a href="#stddev-from-moving-average（移动平均-标准差）" class="headerlink" title="stddev from moving average（移动平均-标准差）"></a>stddev from moving average（移动平均-标准差）</h5><p>先求出最后一个点处的指数加权移动平均值，然后再用最新的点和三倍方差方法求异常。</p>
<h5 id="stddev-from-ewma（指数加权移动平均-标准差）"><a href="#stddev-from-ewma（指数加权移动平均-标准差）" class="headerlink" title="stddev from ewma（指数加权移动平均-标准差）"></a>stddev from ewma（指数加权移动平均-标准差）</h5><p>类似于特征3，不过在计算$(t-mean)/std$时，使用的mean，std分别为对窗口数据进行移动加权平均后的平均值以及方差。</p>
<h5 id="histogram-bins"><a href="#histogram-bins" class="headerlink" title="histogram bins"></a>histogram bins</h5><p>该算法和以上都不同，它首先将timeseries划分成15个宽度相等的直方，然后判断tail_avg所在直方内的元素是否&lt;=20，如果是，则异常。</p>
<p>直方的个数和元素个数判定需要根据自己的metrics调整，不然在数据量小的时候很容易就异常了。</p>
<h5 id="median-absolute-deviation（中位数绝对偏差）"><a href="#median-absolute-deviation（中位数绝对偏差）" class="headerlink" title="median absolute deviation（中位数绝对偏差）"></a>median absolute deviation（中位数绝对偏差）</h5><p><strong>median：</strong>大部分情况下我们用mean来表达一个集合的平均水平（average），但是在某些情况下存在少数极大或极小的outlier，拉高或拉低了（skew）整体的mean，造成估计的不准确。此时可以用median（中位数）代替mean描述平均水平。Median的求法很简单，集合排序中间位置即是，如果集合总数为偶数，则取中间二者的平均值。</p>
<p><strong>median of deviation（MAD）：</strong>同mean一样，对于median我们也需要类似standard deviation这样的指标来表达数据的紧凑/分散程度，即偏离average的平均距离，这就是MAD。MAD顾名思义，是deviation的median，而此时的deviation = abs( 个体 – median )，避免了少量outlier对结果的影响，更robust。</p>
<p>绝对中位差实际求法是用原数据减去中位数后得到的新数据的绝对值的中位数。</p>
<ol>
<li>原数据-中位值=新数据</li>
<li>新数据的绝对值的中位数作为特征</li>
</ol>
<h5 id="mean-subtraction-cumulation（平均值减法累积？）"><a href="#mean-subtraction-cumulation（平均值减法累积？）" class="headerlink" title="mean subtraction cumulation（平均值减法累积？）"></a>mean subtraction cumulation（平均值减法累积？）</h5><p>该特征类似于3-sigma准则。</p>
<p><strong>算法流程</strong></p>
<ol>
<li>排除全序列（暂称为all）最后一个值（last datapoint），求剩余序列（暂称为rest，0..length-2）的mean；</li>
<li>rest序列中每个元素减去rest的mean，再求标准差；</li>
<li>求窗口数据中间点到rest mean的距离，即 abs(last datapoint – rest mean)；</li>
</ol>
<h5 id="first-hour-average（前若干-平均值）"><a href="#first-hour-average（前若干-平均值）" class="headerlink" title="first hour average（前若干-平均值）"></a>first hour average（前若干-平均值）</h5><p>和上述算法基本一致，只是比较对象不是整个序列，而是开始一个小时（其实这种这种思想可以推广，只要是时间序列刚开始的一段时间即可）的以内的数据，求出这段时间的均值和标准差和尾部数据（新产生的数据）用三倍方差的方法比较即可。</p>
<h4 id="熵特征"><a href="#熵特征" class="headerlink" title="熵特征"></a>熵特征</h4><p>为什么要研究时间序列的熵呢？请看下面两个时间序列：</p>
<p>时间序列（1）：(1,2,1,2,1,2,1,2,1,2,…)</p>
<p>时间序列（2）：(1,1,2,1,2,2,2,2,1,1,…)</p>
<p>在时间序列（1）中，1 和 2 是交替出现的，而在时间序列（2）中，1 和 2 是随机出现的。在这种情况下，时间序列（1）则更加确定，时间序列（2）则更加随机。并且在这种情况下，两个时间序列的统计特征，例如均值，方差，中位数等等则是几乎一致的，说明用之前的统计特征并不足以精准的区分这两种时间序列。</p>
<p>通常来说，要想描述一种确定性与不确定性，<strong>熵（entropy）</strong>是一种不错的指标。对于离散空间而言，一个系统的熵（entropy）可以这样来表示：</p>
<script type="math/tex; mode=display">
\text{entropy}(X) = -\sum_{i=1}^{\infty}P\{x=x_{i}\}\ln(P\{x=x_{i}\}).</script><p>如果一个系统的熵（entropy）越大，说明这个系统就越混乱；如果一个系统的熵越小，那么说明这个系统就更加确定。</p>
<p>提到时间序列的熵特征，一般来说有几个经典的例子，那就是 <strong>binned entropy</strong>，<strong>approximate entropy</strong>，<strong>sample entropy</strong>。下面来一一介绍时间序列中这几个经典的熵。</p>
<h5 id="Binned-Entropy"><a href="#Binned-Entropy" class="headerlink" title="Binned Entropy"></a>Binned Entropy</h5><p>从熵的定义出发，可以考虑把时间序列 $X_{T}$的取值进行分桶的操作。例如，可以把$[\min(X_{T}), \max(X_{T})]$这个区间等分为十个小区间，那么时间序列的取值就会分散在这十个桶中。根据这个等距分桶的情况，就可以计算出这个概率分布的熵（entropy）。i.e. Binned Entropy 就可以定义为：</p>
<script type="math/tex; mode=display">
\text{binned entropy}(X) = -\sum_{k=0}^{\min(maxbin, len(X))} p_{k}\ln(p_{k})\cdot 1_{(p_{k}>0)},</script><p>其中 $p_{k}$ 表示时间序列 $X_{T}$ 的取值落在第 $k$ 个桶的比例（概率），$maxbin$ 表示桶的个数， $len(X_{T}) = T$ 表示时间序列 $X_{T}$ 的长度。</p>
<p>如果一个时间序列的 Binned Entropy 较大，说明这一段时间序列的取值是较为均匀的分布在 $[\min(X_{T}), \max(X_{T})]$之间的；如果一个时间序列的 Binned Entropy 较小，说明这一段时间序列的取值是集中在某一段上的。</p>
<h5 id="Approximate-Entropy"><a href="#Approximate-Entropy" class="headerlink" title="Approximate Entropy"></a>Approximate Entropy</h5><p>回到本节的问题，如何判断一个时间序列是否具备某种趋势还是随机出现呢？这就需要介绍 Approximate Entropy 的概念了，Approximate Entropy 的思想就是把一维空间的时间序列提升到高维空间中，通过高维空间的向量之间的距离或者相似度的判断，来推导出一维空间的时间序列是否存在某种趋势或者确定性。那么，我们现在可以假设时间序列 $X_{N}: \{x_{1},\cdots, x_{N}\}$ 的长度是 $N$ ，同时 Approximate Entropy 函数拥有两个参数， $m$ 与 $r$ ，下面来详细介绍 Approximate Entropy 的算法细节。</p>
<ol>
<li>固定两个参数，正整数 $m$ 和正数 $r$，正整数 $m$ 是为了把时间序列进行一个片段的提取，正数 $r$ 是表示时间序列距离的某个参数。i.e. 需要构造新的 $m$ 维向量如下：</li>
</ol>
<script type="math/tex; mode=display">
X_{1}(m) = (x_{1},\cdots, x_{m})\in\mathbb{R}^{m},\\
X_{i}(m) = (x_{i},\cdots, x_{m+i-1})\in\mathbb{R}^{m},\\
X_{N-m+1}(m) = (x_{N-m+1},\cdots, x_{N})\in\mathbb{R}^{m}.</script><ol>
<li>通过新的向量$X_{1}(m),\cdots, X_{N-m+1}(m)$，可以计算出哪些向量与 $X_i$ 较为相似。即，</li>
</ol>
<script type="math/tex; mode=display">
C_{i}^{m}(r) = (\text{number of }X_{j}(m)\text{ such that } d(X_{i}(m), X_{j}(m))\leq r)/(N-m+1),</script><p>​    在这里，距离$d$选择$L^1$，$L^2$，$L^p$，$L^\infty$范数。在这个场景下，距离$d$通常选择为$L^\infty$范数。</p>
<ol>
<li>考虑函数</li>
</ol>
<script type="math/tex; mode=display">
\Phi^{m}(r) = (N-m+1)^{-1}\cdot \sum_{i=1}^{N-m+1} \ln(C_{i}^{m}(r)),</script><ol>
<li>Approximate Entropy 可以定义为：</li>
</ol>
<script type="math/tex; mode=display">
\text{ApEn}(m,r) = \Phi^{m}(r)-\Phi^{m+1}(r).</script><p>备注：</p>
<ol>
<li>正整数 $m$ 一般可以取值为 $2$ 或者 $3$， $r&gt;0$ 会基于具体的时间序列具体调整；</li>
<li>如果某条时间序列具有很多重复的片段（repetitive pattern）或者自相似性（self-similarity pattern），那么它的 Approximate Entropy 就会相对小；反之，如果某条时间序列几乎是随机出现的，那么它的 Approximate Entropy 就会相对较大。</li>
</ol>
<h5 id="Sample-Entropy"><a href="#Sample-Entropy" class="headerlink" title="Sample Entropy"></a>Sample Entropy</h5><p>除了 Approximate Entropy，还有另外一个熵的指标可以衡量时间序列，那就是 Sample Entropy，通过自然对数的计算来表示时间序列是否具备某种自相似性。</p>
<p>按照以上 Approximate Entropy 的定义，可以基于$m$与$r$定义两个指标$A$与$B$，分别是</p>
<script type="math/tex; mode=display">
A = \#\{\text{vector pairs having } d(X_{i}(m+1),X_{j}(m+1))<r \text{ of length } m+1 \},\\
B = \#\{ \text{vector pairs having } d(X_{i}(m), X_{j}(m))<r \text{ of length } m\}.</script><p>其中，$#$ 表示集合的元素个数。根据度量 $d$ （无论是$L^1$，$L^2$，$L^\infty$ ）的定义可以知道 $A\le B$，因此 Sample Entropy 总是非负数，即</p>
<script type="math/tex; mode=display">
\text{SampEn} = -\ln(A/B) \geq 0.</script><p>备注：</p>
<ol>
<li>Sample Entropy 总是非负数；</li>
<li>Sample Entropy 越小表示该时间序列具有越强的自相似性（self similarity）。</li>
<li>通常来说，在 Sample Entropy 的参数选择中，可以选择$m=2,r=0.2 \times std$。</li>
</ol>
<h4 id="分段特征"><a href="#分段特征" class="headerlink" title="分段特征"></a>分段特征</h4><p>即使时间序列有一定的自相似性（self-similarity），能否说明这两条时间序列就完全相似呢？其实答案是否定的，例如：两个长度都是 1000 的时间序列，</p>
<p>时间序列（1）： [1,2] * 500</p>
<p>时间序列（2）： [1,2,3,4,5,6,7,8,9,10] * 100</p>
<p>其中，时间序列（1）是 1 和 2 循环的，时间序列（2）是 1~10 这样循环的，它们从图像上看完全是不一样的曲线，并且它们的 Approximate Entropy 和 Sample Entropy 都是非常小的。那么问题来了，有没有办法提炼出信息，从而表示它们的不同点呢？答案是肯定的。</p>
<p>首先，我们可以回顾一下 Riemann 积分和 Lebesgue 积分的定义和不同之处。按照下面两幅图所示，Riemann 积分是为了算曲线下面所围成的面积，因此把横轴划分成一个又一个的小区间，按照长方形累加的算法来计算面积。而 Lebesgue 积分的算法恰好相反，它是把纵轴切分成一个又一个的小区间，然后也是按照长方形累加的算法来计算面积。</p>
<p><img src="http://image.rexking6.top/img/clip1541314641.png" alt=""></p>
<p>之前的 Binned Entropy 方案是根据值域来进行切分的，好比 Lebesgue 积分的计算方法。现在我们可以按照 Riemann 积分的计算方法来表示一个时间序列的特征，于是就有学者把时间序列按照横轴切分成很多段，每一段使用某个简单函数（线性函数等）来表示，于是就有了以下的方法：</p>
<ol>
<li>分段线性逼近（Piecewise Linear Approximation）</li>
<li>分段聚合逼近（Piecewise Aggregate Approximation）</li>
<li>分段常数逼近（Piecewise Constant Approximation）</li>
</ol>
<p>说到这几种算法，其实最本质的思想就是进行数据降维的工作，用少数的数据来进行原始时间序列的表示（Representation）。用数学化的语言来描述时间序列的数据降维（Data Reduction）就是：把原始的时间序列 $\{x_1,…,x_N\}$ 用 $\{x_1’,…,x_D’\}$来表示，其中$D&lt;N$。那么后者就是原始序列的一种表示（representation）。</p>
<h5 id="分段聚合逼近（Piecewise-Aggregate-Approximation）—-类似-Riemann-积分"><a href="#分段聚合逼近（Piecewise-Aggregate-Approximation）—-类似-Riemann-积分" class="headerlink" title="分段聚合逼近（Piecewise Aggregate Approximation）—- 类似 Riemann 积分"></a>分段聚合逼近（Piecewise Aggregate Approximation）—- 类似 Riemann 积分</h5><p>在这种算法中，分段聚合逼近（Piecewise Aggregate Approximation）是一种非常经典的算法。假设原始的时间序列是 $C=\{x_1,…,x_N\}$，定义PAA的序列是：</p>
<script type="math/tex; mode=display">
\overline{C} = \{\overline{x}_{1},\cdots,\overline{x}_{w}\},</script><p>其中，</p>
<script type="math/tex; mode=display">
\overline{x}_{i} = \frac{w}{N} \cdot \sum_{j=\frac{N}{w}(i-1)+1}^{\frac{N}{w}i} x_{j}.</script><p>在这里$1\le i \le w$。用图像来表示那就是</p>
<p><img src="http://image.rexking6.top/img/clip1541314841.png" alt=""></p>
<p>至于分段线性逼近（Piecewise Linear Approximation）和分段常数逼近（Piecewise Constant Approximation），只需要在 $\overline{x}_{i}$ 的定义上稍作修改即可。</p>
<h5 id="符号逼近（Symbolic-Approximation）—-类似-Riemann-积分"><a href="#符号逼近（Symbolic-Approximation）—-类似-Riemann-积分" class="headerlink" title="符号逼近（Symbolic Approximation）—- 类似 Riemann 积分"></a>符号逼近（Symbolic Approximation）—- 类似 Riemann 积分</h5><p>在推荐系统的特征工程里面，特征通常来说可以做归一化，二值化，离散化等操作。例如，用户的年龄特征，一般不会直接使用具体的年月日，而是划分为某个区间段，例如 0~6（婴幼儿时期），7~12（小学），13~17（中学），18~22（大学）等阶段。</p>
<p>其实在得到分段特征之后，分段特征在某种程度上来说依旧是某些连续值，能否把连续值划分为一些离散的值呢？于是就有学者使用一些符号来表示时间序列的关键特征，也就是所谓的符号表示法（Symbolic Representation）。下面来介绍经典的 SAX Representation。</p>
<p>如果我们希望使用 $\alpha$ 个符号，例如 $\{l_1,…,l_\alpha\}$来表示时间序列。同时考虑分布$N(0,1)$，用</p>
<p>$\{z_{1/\alpha},\cdots,z_{(\alpha-1)/\alpha}\}$来表示 Gauss 曲线下方的一些点，而这些点把 Gauss 曲线下方的面积等分成了 $\alpha$段。</p>
<p>算法流程：</p>
<ol>
<li>正规化（normalization）：也就是该时间序列被映射到均值为零，方差为一的区间内。</li>
<li>分段表示（PAA）：$\{x_{1},\cdots, x_{N}\} \Rightarrow \{\overline{x}_{1},\cdots,\overline{x}_{w}\}.$</li>
<li>符号表示（SAX）：如果$\overline{x}_{i}&lt;z_{1/\alpha}$，那么$\hat{X}_{i}=l_{1}$；如果$z_{(j-1)/\alpha}\leq \overline{x}_{i}&lt;z_{j/\alpha}$，那么$\hat{X}_{i} = l_{j}$；如果$\overline{x}_{i}\geq z_{(\alpha-1)/\alpha}$，那么$\hat{X}_{i} = l_{\alpha}$。</li>
</ol>
<p>于是，我们就可以用$\{l_{1},\cdots,l_{\alpha}\}$这$\alpha$个字母来表示原始的时间序列了。</p>
<p><img src="http://image.rexking6.top/img/clip1541315241.png" alt=""></p>
<h4 id="总特征"><a href="#总特征" class="headerlink" title="总特征"></a>总特征</h4><p>总的训练特征为：时间窗口特征 + OneHot特征 + Timestamp所属的星期作为特征，label选取时间窗口中间点的标签。</p>
<p>因为选择了窗口数据的中间位置的点作为label值，所以在窗口移动过程中，在数据起始点和终结点会丢失 datasize-(windowsize/2) 个数据。（datasize为数据的总量，windowsize为时间窗口的大小)</p>
<p>在最终提交的结果中，缺失的数据点的预测结果，用0补充。</p>
<h3 id="分类方法"><a href="#分类方法" class="headerlink" title="分类方法"></a>分类方法</h3><ul>
<li>随机森林</li>
<li>XGBoost</li>
<li>DNN</li>
</ul>
<h2 id="长期环比（LS）"><a href="#长期环比（LS）" class="headerlink" title="长期环比（LS）"></a>长期环比（LS）</h2><p>上面短期环比参考的是短期内的数据，而仅仅有短期内的数据是不够的，我们还需要参考更长时间内数据的总体走势。</p>
<p>通常使用一条曲线对该趋势进行拟合来反应曲线的走势，如果新的数据打破了这种趋势，使曲线变得不平滑，则该点就出现了异常。曲线拟合的方法有很多，比如回归、moving average……。在这里，我们使用EWMA，即指数权重移动平均方法来拟合曲线。在EWMA中，下一点的平均值是由上一点的平均值，加上当前点的实际值修正而来。对于每一个EWMA值，每个数据的权重是不一样的，最近的数据将拥有越高的权重。</p>
<p>有了平均值之后，我们就可以使用3-sigma理论来判断新的input是否超过了容忍范围。比较实际的值是否超出了这个范围就可以知道是否可以告警了。</p>
<p><img src="http://image.rexking6.top/img/clip1541172227.png" alt=""></p>
<p><strong>自己理解：长期环比除了通过拟合、EWMA等方法，ARIMA和RNN也应该能适用</strong></p>
<h2 id="同比-chain"><a href="#同比-chain" class="headerlink" title="同比(chain)"></a>同比(chain)</h2><p>很多监控项都具有一定的周期性，其中以一天为周期的情况比较常见，比如lvs流量在早上4点最低，而在晚上11点最高。为了将监控项的周期性考虑进去，我们选取了某个监控项过去14天的数据。对于某个时刻，将得到14个点可以作为参考值，我们记为$x_i$，其中$i=1,…,14$。</p>
<p>我们先考虑静态阈值的方法来判断$input$是否异常（突增和突减）。如果$input$比过去14天同一时刻的最小值乘以一个阈值还小，就会认为该输入为异常点（突减）；而如果$input$比过去14天同一时刻的最大值乘以一个阈值还大，就会认为该输入为异常点（突增）。</p>
<p><img src="http://image.rexking6.top/img/clip1541172603.png" alt=""></p>
<p>静态阈值的方法是根据历史经验得出的值，实际中如何给$max_threshold$和$min_threshold$是一个需要讨论的话题。根据目前动态阈值的经验规则来说，取平均值是一个比较好的思路。</p>
<p><strong>自己的理解：同比的方法只能针对周期性的曲线使用，但是同比的方法个人认为只能用来辅助预测，更多的应该是用来检测异常。</strong></p>
<h2 id="同比振幅-CA"><a href="#同比振幅-CA" class="headerlink" title="同比振幅(CA)"></a>同比振幅(CA)</h2><p>同比的方法遇到有些情况就不能检测出异常。比如今天是11.18日，过去14天的历史曲线必然会比今天的曲线低很多。那么今天出了一个小故障，曲线下跌了，相对于过去14天的曲线仍然是高很多的。这样的故障使用方法二就检测不出来，那么我们将如何改进我们的方法呢？一个直觉的说法是，两个曲线虽然不一样高，但是“长得差不多”。那么怎么利用这种“长得差不多”呢？那就是振幅了。</p>
<p>怎么计算$t$时刻的振幅呢？ 我们使用$\frac{x(t) – x(t-1)}{x(t-1)}$来表示振幅。举个例子，例如$t$时刻的流量为900bit，$t-1$时刻的是1000bit，那么可以计算出掉线人数是10%。如果参考过去14天的数据，我们会得到14个振幅值。使用14个振幅的绝对值作为标准，如果$m$时刻的振幅$\frac{m(t) – m(t-1)}{m(t-1)}&gt;amplitude \ast threshold$并且$m$时刻的振幅大于0，则我们认为该时刻发生突增，而如果$m$时刻的振幅大于$amplitude\ast threshold$并且$m$时刻的振幅小于0，则认为该时刻发生突减。其中，</p>
<script type="math/tex; mode=display">
amplitude = max[|\frac{x_i(t)-x_i(t-1)}{x_i(t-1)}|],x=1,2,...,14</script><h2 id="算法组合"><a href="#算法组合" class="headerlink" title="算法组合"></a>算法组合</h2><p>上面介绍了四种方法，这四种方法里面，SS和LS是针对非周期性数据的验证方法，而chain和CA是针对周期性数据的验证方法。那这四种方法应该如何选择和使用呢？下面我们介绍两种使用方法：</p>
<p>一、根据周期性的不同来选择合适的方法。这种方法需要首先验证序列是否具有周期性，如果具有周期性则进入左边分支的检测方法，如果没有周期性，则选择进入右分支的检测方法。</p>
<p><img src="http://image.rexking6.top/img/clip1541239974.png" alt=""></p>
<p>上面涉及到了如何检测数据周期的问题，可以使用差分的方法来检测数据是否具有周期性。比如取最近两天的数据来做差分，如果是周期数据，差分后就可以消除波动，然后结合方差阈值判断的判断方法来确定数据的周期性。当然，如果数据波动范围比较大，可以在差分之前先对数据进行归一化（比如z-score）。</p>
<p>二、不区分周期性，直接根据“少数服从多数”的方法来去检测，这种方法比较好理解，在此就不说明了。</p>
<p><img src="http://image.rexking6.top/img/clip1541239998.png" alt=""></p>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><h3 id="Smoothed-z-score-algorithm"><a href="#Smoothed-z-score-algorithm" class="headerlink" title="Smoothed z-score algorithm"></a>Smoothed z-score algorithm</h3><p><img src="http://image.rexking6.top/img/clip1541169228.png" alt=""></p>
<p>主要思想：</p>
<ol>
<li>利用过去一段历史窗口针对下个节点值做预测（利用平均值，方差信息），若是其超过了一定的阈值，则是个异常点。</li>
<li>对异常点的数值进行平滑，以便评估下下个点是否为异常点。因为不做平滑，由于当前是个异常点，对平均值、方差影响较大，若是下一个点仍是异常点，可能不会识别。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/39453139">https://zhuanlan.zhihu.com/p/39453139</a></p>
<h2 id="相空间重构"><a href="#相空间重构" class="headerlink" title="相空间重构"></a>相空间重构</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32910931">时间序列模型之相空间重构模型</a></li>
</ul>
<h1 id="论文集"><a href="#论文集" class="headerlink" title="论文集"></a>论文集</h1><h2 id="针对周期型KPI的异常检测算法"><a href="#针对周期型KPI的异常检测算法" class="headerlink" title="针对周期型KPI的异常检测算法"></a>针对周期型KPI的异常检测算法</h2><ul>
<li>Time Series Decomposition: Yingying Chen, Ratul Mahajan, Baskar Sridharan, and Zhi-Li Zhang. A provider-side view of web search response time. In Proceedings of the ACM SIGCOMM 2013 confere nce on SIGCOMM, pages 243–254. ACM, 2013.</li>
<li>Holtwinters: He Yan, Ashley Flavel, Zihui Ge, Alexandre Gerber, Daniel Massey, Christos Papadopoulos, Hiren Shah, and Jennifer Yates. Argus: End-to-end service anomaly detection and localization from an isp’s point of view. In INFOCOM, 2012 Proceedings IEEE, pages 2756–2760. IEEE, 2012.</li>
<li>AutoEncoder（AE）：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e31ff328b682">Anomaly Detection异常检测的几种方法</a></li>
<li>Variational AutoEncoder（VAE）：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/45400663">AIOps探索：基于VAE模型的周期性KPI异常检测方法</a></li>
</ul>
<h2 id="针对稳定型KPI的异常检测算法"><a href="#针对稳定型KPI的异常检测算法" class="headerlink" title="针对稳定型KPI的异常检测算法"></a>针对稳定型KPI的异常检测算法</h2><ul>
<li>静态阈值: <a href="http://link.zhihu.com/?target=http%3A//docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/ConsoleAlarms.html">Amazon cloudwatch alarm.</a></li>
<li>Moving Average: David R. Choffnes, Fabián E. Bustamante, and Zihui Ge. Crowdsourcing service-level network event monitoring. In Proceedings of the ACM SIGCOMM 2010 Conf.</li>
<li>Weighted Moving Average: Balachander Krishnamurthy, Subhabrata Sen, Yin Zhang, and Yan Chen. Sketch-based change detection: methods, evaluation, and applications. In Proceedings of the 3rd ACM<br>SIGCOMM conference on Internet measurement, pages 234–247. ACM, 2003.</li>
<li>Exponentially Weighted Moving Average: Balachander Krishnamurthy, Subhabrata Sen, Yin Zhang, and Yan Chen. Sketch-based change detection: methods, evaluation, and applications. In Proceedings of the 3rd ACM SIGCOMM conference on Internet measurement, pages 234–247. ACM, 2003.</li>
<li>ARIMA: Yin Zhang, Zihui Ge, Albert Greenberg, and Matthew Roughan. Network anomography. In Proceedings of the 5th ACM SIGCOMM Conference on Internet Measurement, IMC’05, pages 30–30, Berkeley, CA, USA, 2005. USENIX Association.</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35093835">时间序列的自回归模型—从线性代数的角度来看</a></li>
</ul>
<h2 id="针对不稳定型KPI的异常检测算法"><a href="#针对不稳定型KPI的异常检测算法" class="headerlink" title="针对不稳定型KPI的异常检测算法"></a>针对不稳定型KPI的异常检测算法</h2><ul>
<li>Extreme Value Theory: Siffer A, Fouque P A, Termier A, et al. Anomaly Detection in Streams with Extreme Value Theory[C]//Proceedings of the 23rd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining. ACM, 2017: 1067-1075.</li>
<li>Wavelet: Paul Barford, Jeffery Kline, David Plonka, and Amos Ron. A signal analysis of network traffic anomalies. In Proceedings of the 2nd ACM SIGCOMM Workshop on Internet measurment, pages 71–82. ACM, 2002.</li>
</ul>
<h2 id="针对异常数据量太少，-采用异常注入算法"><a href="#针对异常数据量太少，-采用异常注入算法" class="headerlink" title="针对异常数据量太少， 采用异常注入算法"></a>针对异常数据量太少， 采用异常注入算法</h2><ul>
<li>Fernando Silveira, Christophe Diot, Nina Taft, and Ramesh Govindan. Astute: Detecting a different class of traffic anomalies. In Proceedings of the ACM SIGCOMM 2010 Conference, SIGCOMM ’10, pages 267–278. ACM, 2010.</li>
<li>Anukool Lakhina, Mark Crovella, and Christophe Diot. Mining anomalies using traffic feature distributions. In Proceedings of the 2005 Conference on Applications, Technologies, Architectures, and Protocols for Computer Communications, SIGCOMM ’05, pages 217–228. ACM, 2005.</li>
<li>Anukool Lakhina, Mark Crovella, and Christophe Diot. Diagnosing network-wide traffic anomalies. In Proceedings of the 2004 Conference on Applications, Technologies, Architectures, and Protocols for Computer Communications, SIGCOMM ’04, pages 219–230. ACM, 2004</li>
</ul>
<h2 id="针对不同类型的KPI进行聚类"><a href="#针对不同类型的KPI进行聚类" class="headerlink" title="针对不同类型的KPI进行聚类"></a>针对不同类型的KPI进行聚类</h2><ul>
<li><a target="_blank" rel="noopener" href="https://netman.aiops.org/~peidan/ANM2018/8.DependencyDiscovery/LectureCoverage/2018IWQOS_ROCKA.pdf">Robust and Rapid Clustering of KPIs for Large-Scale Anomaly Detection</a></li>
</ul>
<h1 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a>工具库</h1><ul>
<li><code>sklearn.covariance.EllipticEnvelope</code>（高斯分布的协方差估计）</li>
<li><code>sklearn.ensemble.IsolationForest</code>（随机森林）</li>
<li><code>sklearn.neighbors.LocalOutlierFactor</code>（LOF）</li>
</ul>
<h1 id="裴丹论文解读"><a href="#裴丹论文解读" class="headerlink" title="裴丹论文解读"></a>裴丹论文解读</h1><h2 id="Opprentice"><a href="#Opprentice" class="headerlink" title="Opprentice"></a>Opprentice</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30416563">智能运维系统（二）</a></li>
</ul>
<h2 id="Robust-and-Rapid-Clustering-of-KPIs-for-Large-Scale-Anomaly-Detection"><a href="#Robust-and-Rapid-Clustering-of-KPIs-for-Large-Scale-Anomaly-Detection" class="headerlink" title="Robust and Rapid Clustering of KPIs for Large-Scale Anomaly Detection"></a>Robust and Rapid Clustering of KPIs for Large-Scale Anomaly Detection</h2><h2 id="VAE"><a href="#VAE" class="headerlink" title="VAE"></a>VAE</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/45400663">AIOps探索：基于VAE模型的周期性KPI异常检测方法</a></li>
</ul>
<h1 id="KPI比赛分析"><a href="#KPI比赛分析" class="headerlink" title="KPI比赛分析"></a>KPI比赛分析</h1><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><ul>
<li>负样本稀少：负样本过采样</li>
<li>缺失值：一阶线性插值填充、均值填充</li>
<li>样本权重：增加头部异常样本的权重</li>
<li>KPI三种形态：周期波动/稳定/不稳定（进行聚类：裴丹18论文）</li>
<li>异常值替换：格拉布斯准则剔除替换</li>
<li>归一化/正则化：z-score、min-max</li>
<li>长异常区间只取前8个时间点</li>
</ul>
<p><img src="http://image.rexking6.top/img/clip1541320628.png" alt=""></p>
<h2 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h2><ul>
<li>统计特征：均值、方差等</li>
<li>对比特征：差分、变分等</li>
<li>频域特征：频谱分析、小波分析等</li>
<li>拟合特征：移动平均、查分平均、权重平均等</li>
<li>原始特征</li>
<li>深度特征：AR+[LSTM、Seq2Seq]、AttentionLSTM+CNN</li>
<li>其他特征：Seasonal Trend Decomposition、PID（P：误差的值、I：误差的积分值、D：误差的微分值）、tsfresh抽取</li>
</ul>
<p><img src="http://image.rexking6.top/img/clip1541320933.png" alt=""></p>
<h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><ul>
<li>DNN+Threshold</li>
<li>LR+小波分析+随机森林+BiLSTM，加权投票</li>
<li>xgb</li>
</ul>
<p>改进：聚类分别训练模型+加入周期特征+加入无监督模型</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2019\02\17\《Time-series-Extreme-Event-Forecasting-with-Neural-Networks-at-Uber》笔记\" rel="bookmark">《Time-series Extreme Event Forecasting with Neural Networks at Uber》笔记</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\12\29\时间序列分解\" rel="bookmark">时间序列分解</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\12\29\时间序列平滑\" rel="bookmark">时间序列平滑</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div>一分一毛，也是心意。</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Run-Qing Chen 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Run-Qing Chen 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Run-Qing Chen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://blog.rexking6.top/2018/11/05/%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/" title="基于时间序列的异常检测">https://blog.rexking6.top/2018/11/05/基于时间序列的异常检测/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/" rel="tag"># 时间序列</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/11/02/%E3%80%8A%E8%A7%86%E9%A2%91%E5%88%86%E6%9E%90%E5%89%8D%E6%B2%BF%E3%80%8B%E4%BA%8C/" rel="prev" title="《视频分析前沿》二">
      <i class="fa fa-chevron-left"></i> 《视频分析前沿》二
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/11/19/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B-%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C/" rel="next" title="目标检测-经典网络">
      目标检测-经典网络 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

    <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B"><span class="nav-number">2.</span> <span class="nav-text">时间序列预测</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B"><span class="nav-number">3.</span> <span class="nav-text">异常检测</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">基于模型的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%B7%9D%E7%A6%BB%E7%9A%84%E6%96%B9%E6%B3%95-%E5%9F%BA%E4%BA%8E%E9%82%BB%E8%BF%91%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">基于距离的方法&#x2F;基于邻近度的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%AF%86%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">基于密度的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%81%9A%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">基于聚类的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%88%92%E5%88%86%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.5.</span> <span class="nav-text">基于划分的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%BA%BF%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.6.</span> <span class="nav-text">基于线性的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.7.</span> <span class="nav-text">基于非线性的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%92%88%E5%AF%B9%E9%9D%9E%E6%95%B0%E5%80%BC%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.8.</span> <span class="nav-text">针对非数值型的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.9.</span> <span class="nav-text">基于深度学习的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.10.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">基于时间序列的异常检测方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%AD%E6%9C%9F%E7%8E%AF%E6%AF%94%EF%BC%88SS%EF%BC%89"><span class="nav-number">4.1.</span> <span class="nav-text">短期环比（SS）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%98%88%E5%80%BC"><span class="nav-number">4.1.1.</span> <span class="nav-text">动态阈值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E7%89%B9%E5%BE%81"><span class="nav-number">4.1.2.</span> <span class="nav-text">窗口特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E7%89%B9%E5%BE%81"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">统计特征</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-sigma"><span class="nav-number">4.1.2.1.1.</span> <span class="nav-text">3-sigma</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#z-score"><span class="nav-number">4.1.2.1.2.</span> <span class="nav-text">z score</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Grubbs%E6%A0%BC%E6%8B%89%E6%96%AF%E6%B5%8B%E8%AF%95"><span class="nav-number">4.1.2.1.3.</span> <span class="nav-text">Grubbs格拉斯测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#moving-average%EF%BC%88%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%EF%BC%89"><span class="nav-number">4.1.2.1.4.</span> <span class="nav-text">moving average（移动平均）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cumulative-moving-average%EF%BC%88%E7%B4%AF%E5%8A%A0%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%EF%BC%89"><span class="nav-number">4.1.2.1.5.</span> <span class="nav-text">cumulative moving average（累加移动平均）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#weighted-moving-average%EF%BC%88%E5%8A%A0%E6%9D%83%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%EF%BC%89"><span class="nav-number">4.1.2.1.6.</span> <span class="nav-text">weighted moving average（加权移动平均）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#exponential-weighted-moving-average%EF%BC%88%E6%8C%87%E6%95%B0%E5%8A%A0%E6%9D%83%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%EF%BC%89"><span class="nav-number">4.1.2.1.7.</span> <span class="nav-text">exponential weighted moving average（指数加权移动平均）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#double-exponential-smoothing%EF%BC%88%E5%8F%8C%E6%8C%87%E6%95%B0%E5%B9%B3%E6%BB%91%EF%BC%89"><span class="nav-number">4.1.2.1.8.</span> <span class="nav-text">double exponential smoothing（双指数平滑）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#triple-exponential-smoothing%EF%BC%88%E4%B8%89%E6%8C%87%E6%95%B0%E5%B9%B3%E6%BB%91%EF%BC%89%EF%BC%88Holt-Winters%EF%BC%89"><span class="nav-number">4.1.2.1.9.</span> <span class="nav-text">triple exponential smoothing（三指数平滑）（Holt-Winters）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stddev-from-average%EF%BC%88%E5%B9%B3%E5%9D%87%E5%80%BC-%E6%A0%87%E5%87%86%E5%B7%AE%EF%BC%89"><span class="nav-number">4.1.2.1.10.</span> <span class="nav-text">stddev from average（平均值-标准差）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stddev-from-moving-average%EF%BC%88%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87-%E6%A0%87%E5%87%86%E5%B7%AE%EF%BC%89"><span class="nav-number">4.1.2.1.11.</span> <span class="nav-text">stddev from moving average（移动平均-标准差）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stddev-from-ewma%EF%BC%88%E6%8C%87%E6%95%B0%E5%8A%A0%E6%9D%83%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87-%E6%A0%87%E5%87%86%E5%B7%AE%EF%BC%89"><span class="nav-number">4.1.2.1.12.</span> <span class="nav-text">stddev from ewma（指数加权移动平均-标准差）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#histogram-bins"><span class="nav-number">4.1.2.1.13.</span> <span class="nav-text">histogram bins</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#median-absolute-deviation%EF%BC%88%E4%B8%AD%E4%BD%8D%E6%95%B0%E7%BB%9D%E5%AF%B9%E5%81%8F%E5%B7%AE%EF%BC%89"><span class="nav-number">4.1.2.1.14.</span> <span class="nav-text">median absolute deviation（中位数绝对偏差）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mean-subtraction-cumulation%EF%BC%88%E5%B9%B3%E5%9D%87%E5%80%BC%E5%87%8F%E6%B3%95%E7%B4%AF%E7%A7%AF%EF%BC%9F%EF%BC%89"><span class="nav-number">4.1.2.1.15.</span> <span class="nav-text">mean subtraction cumulation（平均值减法累积？）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#first-hour-average%EF%BC%88%E5%89%8D%E8%8B%A5%E5%B9%B2-%E5%B9%B3%E5%9D%87%E5%80%BC%EF%BC%89"><span class="nav-number">4.1.2.1.16.</span> <span class="nav-text">first hour average（前若干-平均值）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%86%B5%E7%89%B9%E5%BE%81"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">熵特征</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Binned-Entropy"><span class="nav-number">4.1.2.2.1.</span> <span class="nav-text">Binned Entropy</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Approximate-Entropy"><span class="nav-number">4.1.2.2.2.</span> <span class="nav-text">Approximate Entropy</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sample-Entropy"><span class="nav-number">4.1.2.2.3.</span> <span class="nav-text">Sample Entropy</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E7%89%B9%E5%BE%81"><span class="nav-number">4.1.2.3.</span> <span class="nav-text">分段特征</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E8%81%9A%E5%90%88%E9%80%BC%E8%BF%91%EF%BC%88Piecewise-Aggregate-Approximation%EF%BC%89%E2%80%94-%E7%B1%BB%E4%BC%BC-Riemann-%E7%A7%AF%E5%88%86"><span class="nav-number">4.1.2.3.1.</span> <span class="nav-text">分段聚合逼近（Piecewise Aggregate Approximation）—- 类似 Riemann 积分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E9%80%BC%E8%BF%91%EF%BC%88Symbolic-Approximation%EF%BC%89%E2%80%94-%E7%B1%BB%E4%BC%BC-Riemann-%E7%A7%AF%E5%88%86"><span class="nav-number">4.1.2.3.2.</span> <span class="nav-text">符号逼近（Symbolic Approximation）—- 类似 Riemann 积分</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%89%B9%E5%BE%81"><span class="nav-number">4.1.2.4.</span> <span class="nav-text">总特征</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.3.</span> <span class="nav-text">分类方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%BF%E6%9C%9F%E7%8E%AF%E6%AF%94%EF%BC%88LS%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">长期环比（LS）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AF%94-chain"><span class="nav-number">4.3.</span> <span class="nav-text">同比(chain)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AF%94%E6%8C%AF%E5%B9%85-CA"><span class="nav-number">4.4.</span> <span class="nav-text">同比振幅(CA)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%BB%84%E5%90%88"><span class="nav-number">4.5.</span> <span class="nav-text">算法组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="nav-number">4.6.</span> <span class="nav-text">其他方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Smoothed-z-score-algorithm"><span class="nav-number">4.6.1.</span> <span class="nav-text">Smoothed z-score algorithm</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E7%A9%BA%E9%97%B4%E9%87%8D%E6%9E%84"><span class="nav-number">4.7.</span> <span class="nav-text">相空间重构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BA%E6%96%87%E9%9B%86"><span class="nav-number">5.</span> <span class="nav-text">论文集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%92%88%E5%AF%B9%E5%91%A8%E6%9C%9F%E5%9E%8BKPI%E7%9A%84%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">针对周期型KPI的异常检测算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%92%88%E5%AF%B9%E7%A8%B3%E5%AE%9A%E5%9E%8BKPI%E7%9A%84%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">针对稳定型KPI的异常检测算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%92%88%E5%AF%B9%E4%B8%8D%E7%A8%B3%E5%AE%9A%E5%9E%8BKPI%E7%9A%84%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">针对不稳定型KPI的异常检测算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%92%88%E5%AF%B9%E5%BC%82%E5%B8%B8%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A4%AA%E5%B0%91%EF%BC%8C-%E9%87%87%E7%94%A8%E5%BC%82%E5%B8%B8%E6%B3%A8%E5%85%A5%E7%AE%97%E6%B3%95"><span class="nav-number">5.4.</span> <span class="nav-text">针对异常数据量太少， 采用异常注入算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84KPI%E8%BF%9B%E8%A1%8C%E8%81%9A%E7%B1%BB"><span class="nav-number">5.5.</span> <span class="nav-text">针对不同类型的KPI进行聚类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7%E5%BA%93"><span class="nav-number">6.</span> <span class="nav-text">工具库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A3%B4%E4%B8%B9%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB"><span class="nav-number">7.</span> <span class="nav-text">裴丹论文解读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Opprentice"><span class="nav-number">7.1.</span> <span class="nav-text">Opprentice</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Robust-and-Rapid-Clustering-of-KPIs-for-Large-Scale-Anomaly-Detection"><span class="nav-number">7.2.</span> <span class="nav-text">Robust and Rapid Clustering of KPIs for Large-Scale Anomaly Detection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VAE"><span class="nav-number">7.3.</span> <span class="nav-text">VAE</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#KPI%E6%AF%94%E8%B5%9B%E5%88%86%E6%9E%90"><span class="nav-number">8.</span> <span class="nav-text">KPI比赛分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-number">8.1.</span> <span class="nav-text">预处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96"><span class="nav-number">8.2.</span> <span class="nav-text">特征提取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83"><span class="nav-number">8.3.</span> <span class="nav-text">模型训练</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Run-Qing Chen"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Run-Qing Chen</p>
  <div class="site-description" itemprop="description">覆苍天以为衾，卧大地以为庐。</div>
</div>


   <div class="feed-link motion-element">
     <a href="/atom.xml" rel="alternate">
       <i class="fa fa-rss"></i>
       RSS
     </a>
   </div>
 
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">181</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RexKing6" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RexKing6" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1010026261@qq.com" title="E-Mail → mailto:1010026261@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.zxpblog.cn/" title="https:&#x2F;&#x2F;www.zxpblog.cn&#x2F;" rel="noopener" target="_blank">赵小平</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://whitepuffer.github.io/" title="https:&#x2F;&#x2F;whitepuffer.github.io&#x2F;" rel="noopener" target="_blank">江斓</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kexue.fm/" title="https:&#x2F;&#x2F;kexue.fm&#x2F;" rel="noopener" target="_blank">科学空间</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yongyuan.name/" title="https:&#x2F;&#x2F;yongyuan.name&#x2F;" rel="noopener" target="_blank">袁勇</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/abcjennifer" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;abcjennifer" rel="noopener" target="_blank">Rachel Zhang</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://dmkf.xyz/" title="http:&#x2F;&#x2F;dmkf.xyz&#x2F;" rel="noopener" target="_blank">代码咖啡</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://wuxiaolong.me/" title="http:&#x2F;&#x2F;wuxiaolong.me&#x2F;" rel="noopener" target="_blank">吴小龙同学</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.tennfy.com/" title="http:&#x2F;&#x2F;www.tennfy.com&#x2F;" rel="noopener" target="_blank">TENNFY WU</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fab fa-accessible-icon"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Run-Qing Chen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">2.8m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">42:04</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"6XDsO3aHIjDk3nV6eLJCufbl-MdYXbMMI","app_key":"YK4qOc0TpkazN6exhuqsnwmB","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
