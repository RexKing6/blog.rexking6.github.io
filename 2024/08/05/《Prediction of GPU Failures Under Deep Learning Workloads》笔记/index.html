<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.rexking6.top","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#37c6c0","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"YS7HT61SEB","apiKey":"0fd1eba022e7883c76ff4a71aee2acdc","indexName":"blog_NAME","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"找不到关于 ${query} 的文章","hits_stats":"共找到 ${hits} 篇文章，花了 ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="...">
<meta property="og:type" content="article">
<meta property="og:title" content="《Prediction of GPU Failures Under Deep Learning Workloads》笔记">
<meta property="og:url" content="https://blog.rexking6.top/2024/08/05/%E3%80%8APrediction%20of%20GPU%20Failures%20Under%20Deep%20Learning%20Workloads%E3%80%8B%E7%AC%94%E8%AE%B0/">
<meta property="og:site_name" content="RexKing6&#39;s Note">
<meta property="og:description" content="...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Table_1.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Figure_1.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Figure_2.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Figure_3.png">
<meta property="og:image" content="https://image.rexking6.top/img/QQ_1722789409374.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Figure_4.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Figure_5.png">
<meta property="og:image" content="https://image.rexking6.top/img/QQ_1722789669451.png">
<meta property="og:image" content="https://image.rexking6.top/img/QQ_1722789779448.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Figure_6.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Table_4.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Figure_7.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Figure_8.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Table_5.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Figure_9.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Table_6.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Figure_10.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Table_7.png">
<meta property="og:image" content="https://image.rexking6.top/img/QQ_1722790433859.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Figure_11.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Table_8.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Figure_12.png">
<meta property="og:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Table_9.png">
<meta property="article:published_time" content="2024-08-04T16:18:17.000Z">
<meta property="article:modified_time" content="2024-08-04T16:55:33.988Z">
<meta property="article:author" content="Run-Qing Chen">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="AIOps">
<meta property="article:tag" content="故障预测">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.rexking6.top/img/1263443072031444992_cut_Table_1.png">

<link rel="canonical" href="https://blog.rexking6.top/2024/08/05/%E3%80%8APrediction%20of%20GPU%20Failures%20Under%20Deep%20Learning%20Workloads%E3%80%8B%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《Prediction of GPU Failures Under Deep Learning Workloads》笔记 | RexKing6's Note</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="RexKing6's Note" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RexKing6's Note</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/rexking6" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.rexking6.top/2024/08/05/%E3%80%8APrediction%20of%20GPU%20Failures%20Under%20Deep%20Learning%20Workloads%E3%80%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Run-Qing Chen">
      <meta itemprop="description" content="覆苍天以为衾，卧大地以为庐。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RexKing6's Note">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《Prediction of GPU Failures Under Deep Learning Workloads》笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-05 00:18:17 / 修改时间：00:55:33" itemprop="dateCreated datePublished" datetime="2024-08-05T00:18:17+08:00">2024-08-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/AIOps/" itemprop="url" rel="index"><span itemprop="name">AIOps</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/AIOps/%E6%95%85%E9%9A%9C%E9%A2%84%E6%B5%8B/" itemprop="url" rel="index"><span itemprop="name">故障预测</span></a>
                </span>
            </span>

          
            <span id="/2024/08/05/%E3%80%8APrediction%20of%20GPU%20Failures%20Under%20Deep%20Learning%20Workloads%E3%80%8B%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="《Prediction of GPU Failures Under Deep Learning Workloads》笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>图形处理器 (GPU) 是处理深度学习任务的事实上的标准。然而，不可避免的 GPU 故障在深度学习任务中会导致严重后果：它们会破坏分布式训练、崩溃推理服务，并导致服务水平协议违规。为了缓解 GPU 故障带来的问题，我们提出使用机器学习模型来预测故障。</p>
<p>本文首次研究了在大规模生产深度学习工作负载下GPU故障预测模型。作为起点，我们评估了经典预测模型，并发现这些模型的预测既不准确也不稳定。为了提高预测精度和稳定性，我们提出了几种技术，包括并行和级联模型集成机制以及滑动训练方法。我们在包含 3.5 亿条记录的四个月生产数据集上评估了我们的各种技术的表现。结果表明，我们提出的技术将预测精度从 46.3% 提高到 84.0%。</p>
<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>在大规模深度学习集群中，GPU故障是不可避免的，并且会导致严重的后果。例如，一个GPU的故障可能会中断长时间运行的分布式训练作业。开发人员会失去多个机器上数小时（有时甚至是数十小时）的工作。此外，GPU故障可能导致生产推理服务崩溃、显著增加响应延迟、违反服务水平协议（SLA），并导致收入损失。</p>
<p>GPU故障预测对于避免收入损失至关重要。例如，如果事先知道故障信息，则可以采取主动维护和重新安排等措施来减少损失。然而，在深度学习工作负载下的GPU故障预测尚未得到充分研究。一些相关的工作（Tiwari等人，2015；Nie等人，2016；2017；2018；Gupta等人，2015）分析了Titan超级计算机上的GPU故障，该计算机是一种高性能计算（HPC）系统。这些研究令人鼓舞，但它们提供的指导有限，因为：(i) 深度学习工作负载与HPC工作负载有很大的不同，(ii)正在研究的GPU类型——英伟达K20X GPU——大约有十年的历史（2012年推出），(iii)没有一项全面的研究说明如何预测GPU故障。除了GPU故障之外，人们还对其他硬件故障进行了研究，如DRAM (Sridharan等人，2013；Meza等人，2015，Pinheiro等人，2007年)、固态硬盘 (Schroeder等人，2016年)、协处理器（Oliveira等人，2017年）和其他数据中心硬件（Vishwanath和Nagappan，2010）。这些研究与我们的研究具有相同的精神，都是为了研究故障，但我们的研究侧重于GPU的独特特性，并旨在预测在深度学习工作负载下GPU的故障。本文是首次对大规模GPU集群中GPU故障进行预测的研究。</p>
<p>为了研究 GPU 故障预测，我们部署了一个系统来持续从运行中的 GPU 收集数据。出于模型训练的目的，我们将 GPU 数据集转换为时间序列数据，并采用滑动窗口方法以提高训练数据中正例样本的数量。作为起点，我们探索了各种经典模型，如长短期记忆 (LSTM) 和一维卷积神经网络 (1D-CNN)，并评估它们在 GPU 故障预测方面的性能。我们观察到这些模型的预测既不准确也不稳定（例如随着时间推移而下降）。</p>
<p>我们了解到，GPU 故障模式是复杂多样的，单个模型的学习能力可能有限。因此，我们提出了两种使用多个模型进行组合预测的模型集成机制（即并行和级联）。并行模型集成机制使用不同的模型进一步验证预测结果。级联回路模型集成机制首先过滤掉95% 的“健康”实例，然后与后一个模型一起进行预测。</p>
<p>我们还观察到，GPU 故障模式可能会随着时间推移而改变，导致训练好的模型变得不那么有效。为了使模型适应不断变化的模式，我们建议使用滑动窗口来训练模型，这样就可以在新数据上进行微调，以提高训练技术的性能。具体来说，我们定期重新训练模型，只使用最近收集的数据。我们进一步观察到滑动训练集的时间长度会影响模型性能，然而并不存在一个针对所有情况的最佳滑动训练集时间长度。因此，我们也建议动态调整滑动训练集的时间长度以更好地训练模型。</p>
<p>本文的主要贡献如下：</p>
<ul>
<li>这是 第一次 研究在大规模生产深度学习工作负载下GPU故障的预测模型。</li>
<li>我们确定了这些预测模型面临的两大挑战：精确度和稳定性。</li>
<li>我们提出了一些技术，包括并行和级联模型集成机制以及滑动训练方法，以提高预测模型的精度和稳定性。</li>
</ul>
<p>我们在包含约 3.5 亿条记录的四个月数据集上评估模型性能。最佳基线模型（即 1D-CNN）的精度仅为 46.3%。我们提出的集成方法能够将精度提高高达 11.9%(参见第 7.1 节)。滑动训练技术提高了模型的稳定性，并且与不使用该技术相比，平均精度提高了 22.8%(参见第 7.3 节)。调整训练集长度的技术可以进一步将精度提高高达 5.7%。通过结合所有这些技术，我们实现了最高达 84.0% 的平均精度。</p>
<h1 id="2-背景知识"><a href="#2-背景知识" class="headerlink" title="2 背景知识"></a>2 背景知识</h1><p>在本节中，我们介绍了 Company XYZ 的 GPU 部署情况，并详细说明了我们收集的 GPU 数据以及如何生成用于模型训练的时间序列数据集。</p>
<h3 id="2-1-GPU-部署与工作负载"><a href="#2-1-GPU-部署与工作负载" class="headerlink" title="2.1 GPU 部署与工作负载"></a>2.1 GPU 部署与工作负载</h3><p>影响 GPU 故障的重要因素之一是 GPU 的部署方式和使用方式。在本节中，我们简要介绍了公司 XYZ 中的 GPU 配置及其工作负载。 公司 XYZ 在全球拥有多个数据中心，其中包含数万个 GPU。 GPU 以每台机器 8 张卡的方式进行组织。 通过支持 RDMA 的数据中心网络连接机器。 我们从用于训练和推断深度学习模型的 GPU 收集数据。 公司 XYZ 的训练任务是大规模的，其中一些任务（例如训练 GPT-3）需要近一千个 GPU 进行协作。 我们的推理服务也非常庞大，因为我们需要处理数十亿的模型推断请求。</p>
<p>在本文中，我们对 公司 XYZ 的 GPU 进行了抽样，我们关注三种最新的 GPU 类型：V100、P4 和 T4。数据来自亚洲多个数据中心的数万个正在运行的 GPU。在本文的其余部分，我们将所有这些数据（全部）称为原始 GPU 数据集或 GPU 数据集，我们在后面会对其进行详细描述。GPU 和机器是随机选择的，因此我们的观察结果应该是普遍适用的。</p>
<h2 id="2-2-原始-GPU-数据集"><a href="#2-2-原始-GPU-数据集" class="headerlink" title="2.2 原始 GPU 数据集"></a>2.2 原始 GPU 数据集</h2><p>我们收集了静态和动态 GPU 属性。表 1 列出了每个属性的描述。大多数参数都显而易见。一个参数，“故障状态”，需要一些解释。“故障状态”表示在给定时间点 GPU 是否已失败，其中“1”表示 GPU 失败，“0”表示健康。本文中所指的 GPU 故障是从用户的角度定义的，即错误根据其外部可观察后果进行分类，而不考虑内部原因。这种基于观察的定义与我们的目标一致，即预测会影响服务和应用程序的故障。</p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Table_1.png" alt=""></p>
<p>表 1. GPU 数据集中的 GPU 和机器参数及其在我们的预测模型中的使用情况。注意，“GPU 数据集”中的“类型”是底层来源（例如 nvidia-smi）的数据类型，而“失败预测”中的“DType”是我们用于训练 ML 模型的类型。除了数据类型之外，我们还将“故障状态”转换为二进制以表示 GPU 是否出现故障，并将“机架名称”切分为数据中心名称进行训练。</p>
<h2 id="2-3-数据预处理"><a href="#2-3-数据预处理" class="headerlink" title="2.3 数据预处理"></a>2.3 数据预处理</h2><p>在本文中，我们旨在预测未来某段时间内，比如一天内，GPU 是否会失败。在收集了原始 GPU 数据集后，我们生成时间序列数据集来训练预测模型。形式化地，让 D 表示时间序列数据集。D={(Xi, yi)}Ni=1，其中 Ni 是 D 中实例的数量。Xi 表示一个时间序列，大小为 l×m，其中 l 是单个实例中的时间步数，而 m 是特征向量的维度。令 p 表示预测长度。yi 是指示变量，其中 yi=1 表示 GPU 在 p 时间内失效，而 yi=0 表示 GPU 在 p 时间内没有失效。</p>
<p>接下来，我们阐述如何将原始 GPU 数据集转换为数据集 D。首先，我们将每个 GPU 的条目分组到一个 GPU 序列号下。每个 GPU 的条目按时间排序，并且两个连续条目的间隔为 10 分钟。由于失败的 GPU 可能不会立即修复，因此一旦 GPU 失败，其状态将保持为“1”，直到其被修复为止。我们过滤掉冗余的条目，即在第一次失败后删除失败状态为“1”的条目。每个时序实例由 l 个连续条目组成，对应于 l 个时间步长。假设 Xi 中最后一个条目的时间戳为 t，则该示例的标签取决于在 [t, t + p] 时间段内后续条目的故障状态。如果在[t, t + p]时间段内所有条目的故障状态都为 0，则此时间序列的标签为 0，表示相应的 GPU 在[t, t + p]时间内不会发生故障。如果在[t, t + p]时间段内有任何条目的故障状态为 1，则此时间序列的标签为 1，表示相应的 GPU 将在此时间段内发生故障。</p>
<p>为了生成时间序列实例，我们首先探索一个分段方法。其思想是将原始数据（即每个 GPU 的长序列）分割为不同的非重叠时间序列示例。如图 1 所示，对于每个 GPU，从初始时间点开始，长度为 l（包括 l 个时间步）的观察窗口移动到下一个时间步骤。我们首先检查窗口中所有条目的故障状态是否为 0。如果不是，则继续向右移动观察窗口，直到窗口中不再有任何“1”的故障状态。然后，当前观察窗口中的数据形成一个时间序列实例，其中每个条目对应于 X_i 的一行。假设窗口中最后一个条目的时间戳为 t，则我们进一步检查时间戳 t 和 t+p 之间的条目是否具有故障状态“1”。如果在此期间存在任何故障状态为“1”的条目，则当前时间序列实例的标签 y_i 为 1，否则为 0。然后，我们将观察窗口移动到预测窗口之后的条目，并重复上述步骤以生成接下来的时间序列示例。</p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Figure_1.png" alt=""></p>
<p>然而，分段方法产生的正例样本数量非常少，使得训练效果较差。为了增加正例样本，我们提出了一种滑动窗口方法：在生成一个时间序列实例后，观察窗口滑动步长（slide step &lt; l）个条目以生成下一个时间序列实例。通过这种方式，一次故障事件可以产生多个正向时间序列实例。当l = 18、p = 144且slide step = 10时，与分段抽样相比，正例数量增加了60倍。</p>
<h1 id="3-从经典模型开始"><a href="#3-从经典模型开始" class="headerlink" title="3 从经典模型开始"></a>3 从经典模型开始</h1><p>在这一部分，我们介绍了我们探索的经典模型以及从结果中观察到的主要挑战。</p>
<h2 id="3-1-特征工程"><a href="#3-1-特征工程" class="headerlink" title="3.1 特征工程"></a>3.1 特征工程</h2><p>在训练模型之前，我们将收集到的特征编码为固定长度的数值型特征向量。如表 1 所示，我们收集的特征类型包括二进制、分类和浮点数。对于“GPU 类型”和“GPU 版本”等分类特征，我们使用独热编码。每个类别首先转换为整数 n，表示它属于第 n 类。然后我们将其编码为一个独热向量，其维度等于类别的数量。独热向量的第 n 个元素为 1，其余元素都为 0。对于浮点特征，特征值被离散化到 N_buckets 个桶中，并转换为桶索引。这种转换可以降低极端值对模型训练的影响。</p>
<h2 id="3-2-经典模型"><a href="#3-2-经典模型" class="headerlink" title="3.2 经典模型"></a>3.2 经典模型</h2><p>作为起点，我们构建了一些经典的机器学习模型，并对其在 GPU 故障预测中的性能进行了评估。我们的问题可以看作二元分类问题，即对时间序列进行“健康”或“故障”的分类。用于二元分类问题的常用方法包括梯度提升决策树（GBDT）、多层感知器（MLP）、长短期记忆（LSTM）等。我们考虑了以下模型：</p>
<ul>
<li>梯度提升决策树 (Gradient Boosting Decision Tree, GBDT): 一种集成学习算法，它由多个弱模型组成。在每个迭代中，使用前一轮迭代得到的决策树的损失函数梯度来训练一个新的决策树。我们的 GBDT 模型包含 200 棵决策树。</li>
<li>多层感知器（MLP）：一种前馈人工神经网络，旨在近似任何连续函数并解决非线性可分问题。我们构建了一个有两个隐藏层的 MLP。</li>
<li>长短期记忆网络（LSTM）：一种能够学习序列预测问题中顺序依赖关系的人工递归神经网络架构。我们构建了一个具有 10 个隐藏状态大小的 LSTM 模型。</li>
<li>1D 卷积神经网络：一种在单个方向上移动内核的卷积神经网络。1D 卷积神经网络主要应用于时间序列数据。我们使用了带有四层卷积层和两层全连接层的 1D 卷积神经网络模型。</li>
</ul>
<p>我们使用从2021年3月16日至31日收集的数据训练上述模型，并在接下来的六天内测试模型的表现。每个样本的模型输出是一个分数，记为p^i，表示该样本属于故障类的概率。由于它们最有可能是正例（故障类）实例，因此我们关注预测分数最高的前K个实例。具体而言，我们将所有实例按其预测分数p^i 排序，然后计算精度@K (Jaervelin &amp; Kekkalainen, 2017)，即正确识别的前K个实例(按分数排序)占总前K个实例的比例。在本文其余部分中，我们用精度@K 和精度来互换。</p>
<p>图2显示了上述模型的每日精确度@K。在这里，我们设置K = 2% 以关注最有可能的正例。从图中我们观察到 1D-CNN 模型在四个模型中实现了最高的精度@K。然而，1D-CNN 的精度@K仍然相当低，平均为 0.663。GBDT、MLP 和 LSTM 的平均精度@K甚至更低，分别为 0.579、0.608 和 0.474。从图 2 我们还可以看出所有模型的精度都随着时间的推移而下降。四个模型第一天到第六天精度下降了 28.6% 到 43.0%。</p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Figure_2.png" alt=""></p>
<p>从上述结果中，我们假设： ① GPU故障模式复杂多变，因此经典模型的整体精度较低。 ②GPU故障模式可能会发生变化，随着时间的推移，模型精度可能会下降。 基于这些假设，我们在第4节提出了两个模型集成机制来提高精度，并在第5节提出了一种滑动训练技术来解决预测稳定性问题。</p>
<h1 id="4-模型集成技术"><a href="#4-模型集成技术" class="headerlink" title="4 模型集成技术"></a>4 模型集成技术</h1><p>GPU故障模式 复杂且多样，因此单个经典模型可能无法很好地捕获该模式。为了提高 GPU 故障预测精度，我们提出了两种模型集成机制，即 并行 和 级联，以不同的方式对多个模型进行集成，以更有效地进行组合预测。</p>
<h2 id="4-1-平行"><a href="#4-1-平行" class="headerlink" title="4.1 平行"></a>4.1 平行</h2><p>图3显示了并行机制的推断过程。我们使用三个不同的模型进行联合决策。具体来说，测试集中的实例被馈入 1D-CNN、MLP 和 GBDT 分别，并且每个模型根据其预测分数选择一组排名前 K 的实例。然后，交集中的实例其中三组中的每一组都归类为“失败”。为了捕获不同的故障模式，我们利用了三种不同的模型来预测GPU的故障。我们使用三个模型输出的前K个交集作为输入，因为如果所有模型都预测它很快就会失败，那么这个实例更有可能是准确的，因此可以提高预测精度。</p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Figure_3.png" alt=""></p>
<h2 id="4-2-分层"><a href="#4-2-分层" class="headerlink" title="4.2 分层"></a>4.2 分层</h2><p>第二种集成方法是级联机制，如图 4 所示。我们选择 1D-CNN 模型和 MLP 模型来进行级联过程，因为这两种模型在第 3 节中具有最高的两个精度。该方法的想法是首先过滤掉最有可能“健康”的实例，然后使用第二个模型对实例进行进一步分类。</p>
<p>如图 4 所示，测试集实例首先被馈送到 1D-CNN 模型以过滤掉最有可能的“健康”实例。为了实现这一点，在训练 1D-CNN 模型时，我们为每个实例设置了一个权重 w i 来控制分类错误时的惩罚。我们将正例的权重设置得比负例高得多，这样将正例分类为负例的惩罚就会很高。令 gθ(⋅) 表示具有参数 θ 的 1D-CNN 模型，则 1D-CNN 模型的损失函数为</p>
<p><img src="https://image.rexking6.top/img/QQ_1722789409374.png" alt=""></p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Figure_4.png" alt=""></p>
<p>通过最小化公式(1)中的预测值，正类预测分数往往很高，因此我们根据其预测分数对实例进行排序，并选择排名前 k1 的实例。通过这种方式，大多数负面示例将被过滤掉。我们选择排名前 k1 的实例，这些实例应包括大部分正面示例和一些负面示例，并将其馈入第二个模型（即多层感知器模型）以进一步分类。最后，MLP 模型中排名前 k2 的实例被归类为“失败”。</p>
<h1 id="5-滑动训练技巧"><a href="#5-滑动训练技巧" class="headerlink" title="5 滑动训练技巧"></a>5 滑动训练技巧</h1><p>在第 3 节中，我们观察到 GPU 故障预测精度会随着时间的推移而降低，这可能是由于 GPU 故障模式随时间变化。这可能由多种因素造成：GPU 驱动程序升级、环境中的湿度和光照等。</p>
<p>为了解决模式变化的问题，我们建议将训练集滑动到最近收集的数据，并定期重新训练模型以捕获当前的模式。如图 5 所示，让 Tretrain 表示模型重新训练的时间间隔，Ltrain 表示训练数据的时间长度。模型在 n×Tretrain 处被保留，其中 n=1,2,…，并且训练数据来自 [nT retrain−Ltrain,nT retrain] 中收集的数据。[nT retrain,(n+1)T retrain] 被称为测试窗口。通过这种方式更新模型以匹配最近的数据。</p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Figure_5.png" alt=""></p>
<p>如上所述，模式变化的速度可能不是恒定的。因此，在不同的时间，不同的Ltrain值可能会产生不同的效果。为了探索Ltrain的影响，我们在每个测试窗口中使用了9天、12天和15天的Ltrain训练了三个模型，并测试它们的表现。表2和表3显示了平行模型在不同时间的性能示例。从表格中我们可以看到，对于测试窗口4月10日至12日，设置为9天时的精度最高@K，而对于测试窗口4月13日至15日，设置为12天时的精度最高@K。结果验证了在不同的时间，最优的Ltrain可能是不同的。</p>
<p>一般来说，较长的时间序列包含更多的数据，因此模型更有可能很好地学习映射。但由于数据可能包含许多过时的模式，所以它可能对变化的模式不敏感。较短的时间序列只包含最新的数据，这更好地帮助捕捉最近的模式，并且对变化的模式敏感。然而，它有过度拟合的风险。因此，当模式变化平滑时，较长的时间序列可能会更好，而当模式变化迅速时，较小的时间序列可能更好。</p>
<p>从上述分析中，我们可以看到没有一个最优的Ltrain。我们未来的工作尚未彻底研究通过自动调整Ltrain以实现更高精度的方法。目前，我们手动调整Ltrain，即所谓的可变长度滑动训练方法。例如，对于测试窗口2021 年4月10日至12 日，模型使用Ltrain=9 天进行训练。而对于测试窗口2021 年4月13日至15 日，模型使用Ltrain=12天进行训练。自动调整Ltrain 的一种可能解决方案是，每次重新训练模型时，我们都会用不同的Ltrain 值来训练多个模型，并选择在之前的测试窗口中精度最高的Ltrain 值用于当前的测试窗口。第9节还讨论了其他潜在的方法，如基于AutoML 的方法。</p>
<p><img src="https://image.rexking6.top/img/QQ_1722789669451.png" alt=""></p>
<p><img src="https://image.rexking6.top/img/QQ_1722789779448.png" alt=""></p>
<h1 id="6-实施"><a href="#6-实施" class="headerlink" title="6 实施"></a>6 实施</h1><p>在本节中，我们介绍了用于收集原始 GPU 数据集的数据收集基础设施。在 XYZ 公司，我们有一个数据收集系统，该系统不断从 GPU 获取运行状态，无论其是健康还是遇到故障。它还收集 GPU 的静态配置信息，例如过期日期和 GPU 所在机架。我们基于现有工具（如 nvidia-smi、dmesg 和 XYZ 公司的服务管理器）构建并部署了数据收集基础设施。它定期从 GPU 收集运行时数据，将运行时数据与静态配置相结合，并更新原始 GPU 数据集。图 6 显示了此数据收集基础设施的架构。</p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Figure_6.png" alt=""></p>
<p>该系统的工作原理如下。首先，管理员决定收集策略，该策略指定要收集哪些数据以及多频繁地收集数据，并将此策略发送给控制器。然后，控制器将此策略广播到运行在服务器上的数据收集代理（一个守护进程）。这些代理负责定期从不同的底层数据源收集数据——例如nvidia-smi、dmesg 和 /proc/。代理还负责检测失败。如果检测到故障，代理会记录故障上下文并发送一个故障报告给 公司 XYZ 的故障处理系统（图 6 中未显示）。图 6 显示了从客户端到服务端以及返回响应的流程。</p>
<p>数据收集器从代理那里接收数据，包括正常运行时数据和故障报告。收集器将这些动态数据与存储在 公司 XYZ 的其他管理数据库中的静态配置数据相结合。例如，配置管理数据库 (cmdb) 是一个这样的数据库，其中包含机器和 GPU 硬件信息。数据收集器通过 GPU 序列号（每个 GPU 的唯一标识符）将所有这些数据连接起来，并更新 GPU 数据集。</p>
<p>最后，更新后的GPU数据集存储在HDFS中，并用于生成第2.3节中描述的时间序列数据集，以进行模型训练。我们的模型训练使用了Python中的TensorFlow 2.0。</p>
<h1 id="7-评价"><a href="#7-评价" class="headerlink" title="7 评价"></a>7 评价</h1><p>在这一部分，我们分别评估了提出的技术。具体来说，我们回答了以下问题：</p>
<ul>
<li>并行机制和级联机制的表现如何，与基线相比有何不同？</li>
<li>如何在滑动训练中设置重新训练周期？</li>
<li>滑动训练和可变长度滑动训练在提高预测精度和稳定性方面有多大帮助？</li>
</ul>
<p>实验设置。我们从2021年3月到2021年6月收集了四个月的生产数据，以生成时间序列数据集。我们在并行机制（称为并行模型）和级联机制（称为级联模型）的基础上评估了几种基准模型，即1D-CNN、MLP 和 GBDT。我们选择这些基准模型是因为它们是集成方法的基本组件。我们使用以下指标来评估模型：</p>
<ul>
<li>Section 3 中引入的 Precision@K。在评估中，我们根据 Section 3 中的解释将 K 设置为 2%</li>
<li>Recall@K （Malheiros et al.， 2012）： K 时的召回率是前 K 个实例中的真正阳性实例（按分数排名）占总阳性实例的比率。与精度@k类似，我们将k设置为2%。</li>
<li>准确率。模型正确预测的比例。我们设置预测分数的阈值为 0.7，即如果 $\hat{p}_i$ 大于阈值，则实例 $i$ 被预测为正例，否则为负例。</li>
</ul>
<p>数据平衡。由于负例的数量远多于正例，训练集极度不平衡，可能导致模型性能不佳，尤其是少数类（“失败”类）。因此，在训练模型时，我们对负例进行欠采样，对正例进行过采样，以使训练集保持平衡。在样本选择后，训练集中正例与负例的比例设置为1:1，这是用于平衡数据集以供模型训练的一个常用比例。另一方面，为了测试目的，测试集中正例与负例的比例被设置得尽可能大，达到1:8。</p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Table_4.png" alt=""></p>
<h2 id="7-1-集群机制的评估"><a href="#7-1-集群机制的评估" class="headerlink" title="7.1 集群机制的评估"></a>7.1 集群机制的评估</h2><p>在这一部分，我们回答第一个问题。首先，我们通过与基准线比较并行和级联模型来验证这两种集成机制的有效性。然后，我们通过测试每日精度@ K来评估这些模型的稳定性。本节中的所有模型都是在没有滑动训练的情况下进行训练的。</p>
<p>我们使用从2021年3月16日至31日收集的数据训练上述模型，并使用从2021年4月1日至30日收集的数据测试模型性能。表4 显示了 1D-CNN、MLP、GBDT、并行和级联模型的结果。从表格中我们可以观察到，无论是 并行模型还是 级联模型，在所有基线模型中都实现了更高的精度@K。并行模型将精度@K 从最佳基线1D-CNN 的46.3％ 提高到58.2％，而级联模型将精度@K 从46.3％提高到50.1％。在五月和六月的数据上也获得了类似的结果。</p>
<p>为了评估预测的稳定性，我们进一步测试了每日精度@K。图7显示了从4月1日至6日的精度@K示例。我们可以观察到平行模型和级联模型在所有时间都优于所有基线模型。但是与基准模型类似，它们的精度@K会随着时间推移而下降。</p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Figure_7.png" alt=""></p>
<h2 id="7-2-重新训练周期评估"><a href="#7-2-重新训练周期评估" class="headerlink" title="7.2 重新训练周期评估"></a>7.2 重新训练周期评估</h2><p>在这一部分，我们回答了第二个问题：如何确定重训练周期，即在滑动训练中我们应该多久重新训练模型一次。我们将Ltrain设置为15天，并在不同的重训练周期下评估模型。具体来说，我们将重训练周期T_retrain（如第5节所述）分别设置为1天、3天、5天、7天和9天，并从4月1日至30日测试相应的模型性能。</p>
<p>图8显示了我们在不同时间间隔下重新训练模型时在四月份的平均精度@ K。从图中我们可以看到，当T retrain设置为3天时，平均精度@ K与T retrain设置为1天时相似。然而，当T retrain被设置为更长的时间（即5天、7天和9天），精度@ K显著下降。类似的结果也出现在五月和六月的数据上。因此，在接下来的实验中，我们将重训练周期设置为3天。</p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Figure_8.png" alt=""></p>
<h2 id="7-3-滑动训练的评价"><a href="#7-3-滑动训练的评价" class="headerlink" title="7.3 滑动训练的评价"></a>7.3 滑动训练的评价</h2><p>在这一部分，我们评估了滑动训练对提高预测精度和稳定性有多大帮助。滑动训练的训练集长度Ltrain设置为15天。表5显示了从4月1日至30日并行模型和级联模型和没有滑动训练的性能。从表中我们可以观察到，通过滑动训练，两个模型的整体性能都有显著提高。特别是，对于平行模型，精度@ K 从 58.2% 提高到 80.0%，对于级联模型，精度@ K 从 50.1% 提高到 78.1%。通过滑动训练，两种模型的准确率和召回率也有所提高。</p>
<p>为了评估滑动训练对精度稳定性提升的帮助，我们测试了每日精度@K。由于重训练周期T retrain设置为3天，我们计算了每3天的平均精度@K。图9显示了平行模型和级联模型有无滑动训练时的平均精度@K。从图中我们可以看到，具有滑动训练的模型的精度@K比没有滑动训练的模型更加稳定。通过滑动训练，平行模型的精度@K方差从0.058降低到0.009，级联模型的精度@K方差从0.051降低到0.014，这证明了滑动训练提高了精度的稳定性。</p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Table_5.png" alt=""></p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Figure_9.png" alt=""></p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Table_6.png" alt=""></p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Figure_10.png" alt=""></p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Table_7.png" alt=""></p>
<p>我们进一步比较了并行模型和级联模型与基线之间的性能，所有这些都具有滑动训练。结果如表 6 所示。从表格中我们可以观察到，并行模型相对于最佳基线模型（即 1D-CNN）在精确率@K 上提高了 13.0％（从 67％ 提高到 80.0％），而级联模型则相对提高了 11.1％（从 67％ 到 78.1％）。五月和六月收集的数据上也取得了类似的改进，这表明即使进行滑动训练，平行和级联模型仍然优于基线。</p>
<h2 id="7-4-变长滑动训练的评估"><a href="#7-4-变长滑动训练的评估" class="headerlink" title="7.4 变长滑动训练的评估"></a>7.4 变长滑动训练的评估</h2><p>为了验证可变长度滑动训练的有效性，我们分别使用 固定长度滑动训练 和 可变长度滑动训练 训练 平行模型和级联模型。对于固定长度滑动训练，设置训练集长度Ltrain为15天。对于可变长度滑动训练，我们训练了三个模型，其Ltrain分别为9天、12天和15天，并在每个测试窗口中使用精度@K最高的模型。图10显示了四月份数据上使用固定长度滑动训练和可变长度滑动训练的平行模型和级联模型的精度@K。表7显示了一个月内的平均精度@K、召回率@K和准确率。通过可变长度滑动训练，平行模型的精度@K提高了5.4%，级联模型的精度@K提高了2.6%。</p>
<p><img src="https://image.rexking6.top/img/QQ_1722790433859.png" alt=""></p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Figure_11.png" alt=""></p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Table_8.png" alt=""></p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Figure_12.png" alt=""></p>
<p>为了验证我们提出的技术的一般性，我们在五月和六月进一步展示了模型的表现。图11和图12显示了在五月和六月收集的有效数据上使用固定长度滑动训练和可变长度滑动训练的并行模型和级联模型的表现。从表格中我们可以看到，在五月和六月，可变长度滑动训练的并行模型和级联模型分别达到了84.4%和74.0%以及81.6%和78.5%的精度@K，这比固定长度滑动训练要好，并且是一致的。三个多月中并行模型和级连模型的平均精度分别为84.0%和76.9%。</p>
<p><img src="https://image.rexking6.top/img/1263443072031444992_cut_Table_9.png" alt=""></p>
<p>表9：与固定长度（FL）和可变长度（VL）滑动训练相比，平行模型和级联模型在6月数据上的比较。</p>
<h1 id="8-相关工作"><a href="#8-相关工作" class="headerlink" title="8 相关工作"></a>8 相关工作</h1><p>如第 1 节所述，我们的研究是首次在大规模深度学习集群中预测 GPU 故障。本节列出并讨论了与本文主题相关的其他工作。</p>
<p>预测故障。很自然地，我们希望利用模型来预测故障。事实上，许多先前的工作（Liang等人，2006；Xue等人，2015；Botezatu等人，2016；Gao等人，2020；Das等人，2018）建立了算法和模型来预见新兴故障。具体来说，Liang等人（Liang等人，2006）通过三个与故障的时间特征、空间特性和非致命事件相关的启发式方法来预测系统故障。类似地，Bontezatu等人（Botezatu等人，2016）使用SMART属性集（一组硬盘传感器参数）构建了一个分类模型来预测磁盘更换。</p>
<p>除了启发式算法和经典的统计模型，神经网络也被用于预测大规模系统中的各种状态。PRACTISE (Botezatu等人，2016) 是一种基于神经网络的时间序列预测模型，可以预测数据中心的未来负载。虽然它的目标不是故障，但使用神经网络的想法确实令人鼓舞。Gao等人(Gao等人，2020) 构建了深度神经网络来预测云数据中心的任务失败。Desh (Das等人，2018) 是另一个使用神经网络对HPC系统健康状况进行预测的例子。最相关的工作(Nie等人，2018) 研究了四种机器学习模型——包括神经网络——以预测GPU内存中的单比特错误。除了上下文的各种差异（例如不同的训练特征、HPC与DL工作负载），我们的方法侧重于构建ML模型来预测未来的GPU故障。此外，我们的方法在数据预处理方面有所不同，我们设计了几种专门的方法来更好地辅助模型训练。</p>
<p>GPU 故障。Tiwar 等人(2015 年；Nie et al., 2016 年；2017 年；2018 年；Gupta et al., 2015 年)在泰坦超级计算机上进行了一系列研究，以了解各种 GPU 故障，包括一般性地调查 GPU 错误（Tiwar 等人，2015 年），分析 GPU 软件错误（Nie et al.，2016 年）以及使用温度和功率来表征 GPU 故障（Nie et al.，2017 年）以及故障的空间特征（Gupta et al.，2015 年）。另一项关于 Blue Waters 超级计算机的研究（Di Martino et al.，2014 年）分析了 GPU 故障以及其他硬件中的 GPU 故障。他们观察到的事实之一是，GPU 是前三大故障硬件之一，而 GPU 内存比主内存对无法纠正的错误更敏感。这表明与其他硬件组件相比，GPU 更容易发生故障。相反，我们研究了 GPU 故障预测。</p>
<p>硬件故障。除了 GPU 之外，还有研究关注其他硬件组件的故障，包括 DRAM（Sridharan 等人，2013 年；Meza 等人，2015 年）、磁盘（Pinheiro 等人，2007 年）、SSD（Schroeder 等人，2016 年）、Xeon Phi 等协处理器（Oliveira 等人，2017 年）以及其他数据中心硬件（Vishwanath 和 Nagappan，2010 年）。我们对 GPU 故障预测的研究也可以扩展到其他硬件组件。</p>
<h1 id="9-讨论与结论"><a href="#9-讨论与结论" class="headerlink" title="9 讨论与结论"></a>9 讨论与结论</h1><p>在这一部分，我们讨论了预测GPU故障的下一步。首先，我们计划探索其他形式的集成机制，包括结合级联和平行机制以及改变级联和平行机制中的模型数量。为了结合级联和平行机制，我们可以用一个平行模型替代级联机制中的第一个（或第二个）模型。此外，在集成机制中有几个因素（例如，模型的数量）可以权衡精度和召回率。对于并行机制，随着添加更多的模型，精度会提高，但召回率会降低，因为更少的实例被选择。在级联机制中，当我们将第一个模型过滤掉更多实例时，精度会提高，但召回率会降低，因为一些正例可能会被过滤掉。</p>
<p>其次，我们将探讨如何自动调整 变长滑动训练。一个可能的解决方案是 将AutoML集成到变长滑动训练中。具体来说，我们可以使用不同的训练集长度 训练多个模型，并在最近收集的数据上评估它们的表现。然后将对应于最高精度模型 的训练集长度用于当前模型的训练。</p>
<p>结论。研究 GPU 故障预测模型至关重要，因为 GPU 故障在当今大规模深度学习集群中很常见、昂贵且可能造成严重后果。本文首次研究了在生产规模日志下对 GPU 故障进行预测的问题。我们观察到 GPU 故障预测所面临的挑战，并提出了一些技术来提高预测模型的精度和稳定性。所提出的技术也可用于其他故障预测问题，例如 DRAM、磁盘和固态硬盘中的故障预测。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2024\08\04\内存故障预测利器EDAC\" rel="bookmark">内存故障预测利器EDAC</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2024\08\04\如何检测GPU常见故障\" rel="bookmark">如何检测GPU常见故障</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\02\11\Dynamic-Time-Warping-动态时间规整\" rel="bookmark">Dynamic Time Warping 动态时间规整</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div>一分一毛，也是心意。</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Run-Qing Chen 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Run-Qing Chen 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Run-Qing Chen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://blog.rexking6.top/2024/08/05/%E3%80%8APrediction%20of%20GPU%20Failures%20Under%20Deep%20Learning%20Workloads%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《Prediction of GPU Failures Under Deep Learning Workloads》笔记">https://blog.rexking6.top/2024/08/05/《Prediction of GPU Failures Under Deep Learning Workloads》笔记/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/AIOps/" rel="tag"># AIOps</a>
              <a href="/tags/%E6%95%85%E9%9A%9C%E9%A2%84%E6%B5%8B/" rel="tag"># 故障预测</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/08/04/%E5%9F%BA%E4%BA%8EKubeflow%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0%E8%90%BD%E5%9C%B0%E5%AE%9E%E6%88%98/" rel="prev" title="基于Kubeflow的机器学习调度平台落地实战">
      <i class="fa fa-chevron-left"></i> 基于Kubeflow的机器学习调度平台落地实战
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/10/17/%E5%87%BA%E5%9B%BD%E6%B8%B8%E6%9C%BA%E7%A5%A8%E9%99%8D%E6%9C%AC%E9%A2%84%E5%AE%9A%E6%8C%87%E5%8D%97/" rel="next" title="出国游机票降本预定指南">
      出国游机票降本预定指南 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

    <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%91%98%E8%A6%81"><span class="nav-number">1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="nav-number">2.</span> <span class="nav-text">1 简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="nav-number">3.</span> <span class="nav-text">2 背景知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-GPU-%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD"><span class="nav-number">3.0.1.</span> <span class="nav-text">2.1 GPU 部署与工作负载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%8E%9F%E5%A7%8B-GPU-%E6%95%B0%E6%8D%AE%E9%9B%86"><span class="nav-number">3.1.</span> <span class="nav-text">2.2 原始 GPU 数据集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-number">3.2.</span> <span class="nav-text">2.3 数据预处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E4%BB%8E%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%A7%8B"><span class="nav-number">4.</span> <span class="nav-text">3 从经典模型开始</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 特征工程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 经典模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E6%A8%A1%E5%9E%8B%E9%9B%86%E6%88%90%E6%8A%80%E6%9C%AF"><span class="nav-number">5.</span> <span class="nav-text">4 模型集成技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E5%B9%B3%E8%A1%8C"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 平行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E5%88%86%E5%B1%82"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 分层</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E6%BB%91%E5%8A%A8%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7"><span class="nav-number">6.</span> <span class="nav-text">5 滑动训练技巧</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E5%AE%9E%E6%96%BD"><span class="nav-number">7.</span> <span class="nav-text">6 实施</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E8%AF%84%E4%BB%B7"><span class="nav-number">8.</span> <span class="nav-text">7 评价</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%88%B6%E7%9A%84%E8%AF%84%E4%BC%B0"><span class="nav-number">8.1.</span> <span class="nav-text">7.1 集群机制的评估</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E9%87%8D%E6%96%B0%E8%AE%AD%E7%BB%83%E5%91%A8%E6%9C%9F%E8%AF%84%E4%BC%B0"><span class="nav-number">8.2.</span> <span class="nav-text">7.2 重新训练周期评估</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E6%BB%91%E5%8A%A8%E8%AE%AD%E7%BB%83%E7%9A%84%E8%AF%84%E4%BB%B7"><span class="nav-number">8.3.</span> <span class="nav-text">7.3 滑动训练的评价</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E5%8F%98%E9%95%BF%E6%BB%91%E5%8A%A8%E8%AE%AD%E7%BB%83%E7%9A%84%E8%AF%84%E4%BC%B0"><span class="nav-number">8.4.</span> <span class="nav-text">7.4 变长滑动训练的评估</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C"><span class="nav-number">9.</span> <span class="nav-text">8 相关工作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E8%AE%A8%E8%AE%BA%E4%B8%8E%E7%BB%93%E8%AE%BA"><span class="nav-number">10.</span> <span class="nav-text">9 讨论与结论</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Run-Qing Chen"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Run-Qing Chen</p>
  <div class="site-description" itemprop="description">覆苍天以为衾，卧大地以为庐。</div>
</div>


   <div class="feed-link motion-element">
     <a href="/atom.xml" rel="alternate">
       <i class="fa fa-rss"></i>
       RSS
     </a>
   </div>
 
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">241</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">85</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">84</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RexKing6" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RexKing6" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1010026261@qq.com" title="E-Mail → mailto:1010026261@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://zhimi.vercel.app/index_zh-cn.html" title="https:&#x2F;&#x2F;zhimi.vercel.app&#x2F;index_zh-cn.html" rel="noopener" target="_blank">執迷</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://whitepuffer.github.io/" title="https:&#x2F;&#x2F;whitepuffer.github.io&#x2F;" rel="noopener" target="_blank">江斓</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kexue.fm/" title="https:&#x2F;&#x2F;kexue.fm&#x2F;" rel="noopener" target="_blank">科学空间</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yongyuan.name/" title="https:&#x2F;&#x2F;yongyuan.name&#x2F;" rel="noopener" target="_blank">袁勇</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/abcjennifer" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;abcjennifer" rel="noopener" target="_blank">Rachel Zhang</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://dmkf.xyz/" title="http:&#x2F;&#x2F;dmkf.xyz&#x2F;" rel="noopener" target="_blank">代码咖啡</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://wuxiaolong.me/" title="http:&#x2F;&#x2F;wuxiaolong.me&#x2F;" rel="noopener" target="_blank">吴小龙同学</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.tennfy.com/" title="http:&#x2F;&#x2F;www.tennfy.com&#x2F;" rel="noopener" target="_blank">TENNFY WU</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fab fa-accessible-icon"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Run-Qing Chen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">4.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">64:09</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"6XDsO3aHIjDk3nV6eLJCufbl-MdYXbMMI","app_key":"YK4qOc0TpkazN6exhuqsnwmB","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
