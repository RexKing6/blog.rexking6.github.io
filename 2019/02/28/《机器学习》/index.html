<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.rexking6.top","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#37c6c0","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"YS7HT61SEB","apiKey":"0fd1eba022e7883c76ff4a71aee2acdc","indexName":"blog_NAME","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"找不到关于 ${query} 的文章","hits_stats":"共找到 ${hits} 篇文章，花了 ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="...">
<meta property="og:type" content="article">
<meta property="og:title" content="《机器学习》">
<meta property="og:url" content="https://blog.rexking6.top/2019/02/28/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B/">
<meta property="og:site_name" content="RexKing6&#39;s Note">
<meta property="og:description" content="...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://image.rexking6.top/img/clip1551329669.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1551333728.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1551955093.png">
<meta property="og:image" content="http://image.rexking6.top/img/a1551955599.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1551955986.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1557558151.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1557567050.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1557567236.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1553785626.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1553822011.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1554628530.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1554723931.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1554724085.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1554772598.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1554773628.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1554773936.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1554777309.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1554790834.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1554796776.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1554796930.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1554798645.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559629894.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555211920.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555216724.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555223520.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555485176.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555747881.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555749552.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555749819.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555752229.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555752250.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555751062.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555760448.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555827422.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555834385.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555834408.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555834694.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555835488.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555838040.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555838055.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555896714.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555897139.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555898311.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555898435.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1555898162.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556155681.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556160271.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556155844.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556155832.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556155969.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556155982.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556157498.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556199922.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556242972.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556242990.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556243341.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556243702.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556243892.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556244243.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556244250.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556244641.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556245233.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556259650.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556259945.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556260124.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556260154.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556260169.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556260228.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556260286.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556260338.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556260348.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556260385.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556260406.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556260427.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556260463.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556260471.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556260590.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556260883.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556261043.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556261168.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556261177.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556262092.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556262108.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556262939.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556263573.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556263784.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556263813.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556276679.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556277247.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556277393.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556277942.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1556278219.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1557546370.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1557553168.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1557553216.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1557553336.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559010711.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559010824.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559011189.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559011196.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559011442.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559011683.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559011719.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559013397.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559024095.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559024132.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559024159.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559024175.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559024206.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1554628530.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559024830.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559026796.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559026864.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559026920.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559027416.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559027923.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559027941.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559027957.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559027976.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559027988.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559028014.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559028364.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559028479.png">
<meta property="og:image" content="http://image.rexking6.top/img/image-20190523200245851.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559031117.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559031946.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559032200.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559032337.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559032457.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559032466.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559032652.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559032660.png">
<meta property="og:image" content="http://image.rexking6.top/img/image-20190525192227609.png">
<meta property="og:image" content="http://image.rexking6.top/img/image-20190524154828076.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559033297.png">
<meta property="og:image" content="http://image.rexking6.top/img/image-20190524155618363.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559034317.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559034436.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559034475.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559034534.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559035051.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559035122.png">
<meta property="og:image" content="http://image.rexking6.top/img/image-20190525185749515.png">
<meta property="og:image" content="http://image.rexking6.top/img/image-20190525190356901.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559038122.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559038143.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559038229.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559038272.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559038525.png">
<meta property="og:image" content="http://image.rexking6.top/img/clip1559038557.png">
<meta property="article:published_time" content="2019-02-28T06:51:55.000Z">
<meta property="article:modified_time" content="2021-07-10T11:30:57.968Z">
<meta property="article:author" content="Run-Qing Chen">
<meta property="article:tag" content="硕士课程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://image.rexking6.top/img/clip1551329669.png">

<link rel="canonical" href="https://blog.rexking6.top/2019/02/28/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《机器学习》 | RexKing6's Note</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="RexKing6's Note" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RexKing6's Note</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/rexking6" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.rexking6.top/2019/02/28/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Run-Qing Chen">
      <meta itemprop="description" content="覆苍天以为衾，卧大地以为庐。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RexKing6's Note">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《机器学习》
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-28 14:51:55" itemprop="dateCreated datePublished" datetime="2019-02-28T14:51:55+08:00">2019-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-10 19:30:57" itemprop="dateModified" datetime="2021-07-10T19:30:57+08:00">2021-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A1%95%E5%A3%AB%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">硕士课程</span></a>
                </span>
            </span>

          
            <span id="/2019/02/28/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B/" class="post-meta-item leancloud_visitors" data-flag-title="《机器学习》" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>100k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>1:31</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>苏老师的《机器学习》。一开始的内容和吴恩达的有些相似，就记一些重要的推导；后面的主要来源于《统计学习方法》和PRML，就记得比较多。</p>
<h1 id="曲线拟合（线性回归）"><a href="#曲线拟合（线性回归）" class="headerlink" title="曲线拟合（线性回归）"></a>曲线拟合（线性回归）</h1><p><img src="http://image.rexking6.top/img/clip1551329669.png" alt=""></p>
<script type="math/tex; mode=display">
\Phi(x)=\left [\begin{aligned}&\phi^T(x_1)\\&\phi^T(x_2)\\ &\dots\\&\phi^T(x_n)\end{aligned}\right]=\left [\begin{aligned}&1 &x_1 &\dots &x_1^{d-1}\\&1 &x_2 &\dots &x_2^{d-1}\\&&&\dots\\&1 &x_n &\dots &x_n^{d-1}\end{aligned}\right],y=\left [\begin{aligned}y_1\\y_2\\ \dots\\y_n\end{aligned}\right]</script><p>经验损失：$D(\mathcal{L})=\frac{1}{n}\sum_{i=1}^n\mathcal{L}(y_i,\hat y_i)$</p>
<p>期望损失：$E(\mathcal{L})=\int\mathcal{L}(x,y)p(x,y)dxdy$</p>
<p>设：$h=\Phi w-y$，其中 $x\in\mathbb R^{n\times 1},\phi(x_1)\in\mathbb R^{d\times 1},\Phi\in\mathbb R^{n\times d}, w \in \mathbb R^{d\times 1}, y\in \mathbb R^{n\times 1}$，最小二乘法为，</p>
<script type="math/tex; mode=display">
\begin{align*}
L_D(w)&=\frac{1}{2}h^Th\\
&=\frac{1}{2}(\Phi w-y)^T(\Phi w-y)\text{ ———展开}\\
&=\frac{1}{2}(w^T\Phi^T\Phi w-w^T\Phi^Ty-y^T\Phi w+y^Ty)\text{ ———}w^T\Phi^Ty=y\Phi w\\
&=\frac{1}{2}(w^T\Phi^T\Phi w-2w^T\Phi^Ty+y^Ty)
\end{align*}</script><p>根据 $\nabla_x(x^TAx)=(A+A^T)x$，对 $w$ 求偏导：</p>
<script type="math/tex; mode=display">
\nabla_w L_D(w)=\Phi^T\Phi w-\Phi^Ty=0\\
w=(\Phi^T\Phi)^{-1}\Phi^Ty</script><h2 id="不同角度看解析解"><a href="#不同角度看解析解" class="headerlink" title="不同角度看解析解"></a>不同角度看解析解</h2><h3 id="核"><a href="#核" class="headerlink" title="核"></a>核</h3><script type="math/tex; mode=display">
\Phi^Ty=\left(\Phi_1,\Phi_2,...,\Phi_n \right)\left(\begin{aligned}y_1\\y_2\\...\\y_n\end{aligned}\right)=\sum_{i=1}^ny_i\phi(x_i)</script><p>新来一个样本 $\forall x\in \mathbb{R}^d$，则</p>
<script type="math/tex; mode=display">
\begin{align*}
\hat y&=\phi^T(x)\sum_{i=1}^n(\Phi^T\Phi)^{-1}y_i\phi(x_i)\\
&=\sum_{i=1}^n y_i\phi^T(x)(\Phi^T\Phi)^{-1}\phi(x_i)\\
&=\sum_{i=1}^ny_ik(x,x_i)
\end{align*}</script><p>$k(x,x_i)$ 即为一种核函数。</p>
<h3 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h3><p><img src="http://image.rexking6.top/img/clip1551333728.png" alt=""></p>
<p>真实值：$y \in \mathbb{R}^n$，预测值：$\hat y =\Phi w\in \mathbb{R}^n$，则虚线部分为真实值与预测值的误差 $\Phi w-y$。且虚线部分与 $\Phi$ 所构成的空间的每个分量 $\phi_i$ 都垂直，即</p>
<script type="math/tex; mode=display">
\left \{\begin{aligned}\phi_1^T(\Phi w-y)=0\\\phi_2^T(\Phi w-y)=0\\\dots\\\phi_d^T(\Phi w-y)=0 \end{aligned}\right.</script><p>即，$\Phi^T(\Phi w-y)=0$。</p>
<h3 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h3><p>可以将每个样本和标签看成计算出的参数 $w$，将特征空间投影到标签空间后，再附上一个随机变量，</p>
<script type="math/tex; mode=display">
y_i=w^Tx_i+\varepsilon,\varepsilon \sim N(0,1)</script><p>则 $D=\{\langle x_i,y_i \rangle\}_{i=1}^n$。因为 $\varepsilon$ 属于高斯分布，则 $y_i$ 也属于高斯分布，$y_i \sim N(w^Tx_i,1)$。将其展开：</p>
<script type="math/tex; mode=display">
p(y_i|x_i;w)=\frac{1}{\sqrt {2\pi}}\text{exp}(-\frac{(y_i-w^Tx_i)^2}{2})</script><p>则似然函数为：</p>
<script type="math/tex; mode=display">
\begin{align*}
\mathcal{l}(w)&=P(Y|X;w)\\
&=\prod_{i=1}^np(y_i;x_i,w)\\
&=\prod_{i=1}^n\frac{1}{\sqrt {2\pi}}\text{exp}(-\frac{(y_i-w^Tx_i)^2}{2})
\end{align*}</script><p>对数似然函数为：</p>
<script type="math/tex; mode=display">
\begin{align*}
L(w)&=\log l(w)\\
&=\text{log}\prod_{i=1}^n\frac{1}{\sqrt {2\pi}}\text{exp}(-\frac{(y_i-w^Tx_i)^2}{2})\\
&=-n\text{log}\sqrt{2\pi}-\frac{1}{2}\sum_{i=1}^n(w^Tx_i-y_i)^2
\end{align*}</script><p>其中第一项为定值，第二项为最小二乘法的损失函数。</p>
<h3 id="最大后验概率，引入正则化"><a href="#最大后验概率，引入正则化" class="headerlink" title="最大后验概率，引入正则化"></a>最大后验概率，引入正则化</h3><p>$D$ 为数据集，则 $p(w|D)\propto p(w,D)\propto p(w)p(D|w)$。</p>
<p>共轭分布定义：$p(w)$ 与 $p(w|D)$ 同分布。</p>
<p>假设 $w \sim N(\vec 0,\lambda I)$，即协方差 $\Sigma=\lambda I$。</p>
<script type="math/tex; mode=display">
\begin{align*}
p(w)&=\frac{1}{\sqrt{(2\pi)^d|\Sigma|}}\text{exp}(-\frac{1}{2}w^T\Sigma^{-1}w)\\
&=\frac{1}{\sqrt{(2\pi)^d\lambda}}\text{exp}(-\frac{1}{2\lambda}w^Tw)
\end{align*}</script><p>似然对数为</p>
<script type="math/tex; mode=display">
\begin{align*}
\text{log }p(w)=\text{log }\frac{1}{\sqrt{2\pi\lambda}}-\frac{1}{2\lambda}w^Tw
\end{align*}</script><p>同样地，第一项为定值，第二项为正则化。</p>
<h1 id="感知机（线性分类）"><a href="#感知机（线性分类）" class="headerlink" title="感知机（线性分类）"></a>感知机（线性分类）</h1><p>这里讲的感知机是单层的，用来作分类。</p>
<p>不像多层神经网络主要靠的是多层的非线性作用进行回归和分类。</p>
<p>所以，这里单纯讲了两种用于分类的激活函数。</p>
<p><img src="http://image.rexking6.top/img/clip1551955093.png" alt=""></p>
<p>问题背景：训练感知机进行二分类。</p>
<h2 id="1-1-的阶跃函数"><a href="#1-1-的阶跃函数" class="headerlink" title="[-1,1]的阶跃函数"></a>[-1,1]的阶跃函数</h2><p>激活函数：</p>
<script type="math/tex; mode=display">
y=\text{sgn}(w^Tx+b)</script><p><img src="http://image.rexking6.top/img/a1551955599.png" alt=""></p>
<p>损失函数：</p>
<script type="math/tex; mode=display">
L(w,b)=-\sum_{x^{(i)}\in M}y^{(i)}(w^Tx^{(i)}+b)=\sum_{i=1}^n\text{max}(0,-y^{(i)}(w^Tx^{(i)}+b))</script><p>其中， $M$ 是指分错的类别。</p>
<p><img src="http://image.rexking6.top/img/clip1551955986.png" alt=""></p>
<blockquote>
<p><strong>补充：</strong>如果改为SVM（支持向量机）进行分类的话，则损失函数变为：</p>
<script type="math/tex; mode=display">
L(w,b)=-\sum_{x^{(i)}\in M}y^{(i)}(w^Tx^{(i)}+b)=\sum_{i=1}^n\text{max}(0,1-y^{(i)}(w^Tx^{(i)}+b))</script><p>这是因为SVM多限定了一个最大距离。</p>
</blockquote>
<p>对损失函数求导：</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial w}=-y^{(i)}x^{(i)}\\
\frac{\partial L}{\partial b}=-y^{(i)}</script><p>所以随机下降的更新规则为：</p>
<script type="math/tex; mode=display">
w\leftarrow w-(-\eta y^{(i)}x^{(i)})=w+\eta y^{(i)}x^{(i)}\\
b\leftarrow b-(-\eta y^{(i)})=b+\eta y^{(i)}</script><h2 id="Logistic函数"><a href="#Logistic函数" class="headerlink" title="Logistic函数"></a>Logistic函数</h2><script type="math/tex; mode=display">
h(x)=\frac{1}{1+e^{-(w^Tx+b)}}</script><p>假设：</p>
<script type="math/tex; mode=display">
\begin{align*}
&P(y=1|x;w)=h(x)\\
&P(y=0|x;w)=1-h(x)
\end{align*}</script><p>以上为样本 $x$ 被分为某一类分别的概率，则 $x$ 被分到真实标签的概率为：</p>
<script type="math/tex; mode=display">
p(y|x;w)=(h(x))^y(1-h(x))^{1-y}\\</script><p>则似然函数为：</p>
<script type="math/tex; mode=display">
\begin{align*}
L(w)&=p(\vec y|X;w) \\
&=\prod_{i=1}^np(y^{(i)}|x^{(i)};w) \\
&=\prod_{i=1}^n(h(x^{(i)}))^{y^{(i)}}(1-h(x^{(i)}))^{1-y^{(i)}}
\end{align*}</script><p>似然函数越大越好，而损失函数越小越好，所以我们将似然函数取负再取对数，</p>
<script type="math/tex; mode=display">
\begin{align*}
-l(w)&=-\log \space L(w) \\
&=-\sum_{i=1}^n\left[ y^{(i)}\log \space h(x^{(i)})+(1-y^{(i)})\log(1-h(x^{(i)}))\right]
\end{align*}</script><p>求导：</p>
<script type="math/tex; mode=display">
\begin{align*}
-\frac{\partial l(w)}{\partial w_j} &= -(y\frac{1}{h(x)}-(1-y)\frac{1}{1-h(x)})\frac{\partial}{\partial w_j}h(x) \\
&= -(y\frac{1}{h(x)}-(1-y)\frac{1}{1-h(x)})h(x)(1-h(x))\frac{\partial w^Tx}{\partial w_j}\\
&=-(y(1-h(x))-(1-y)h(x))x_j \\
&=-(y-h(x))x_j
\end{align*}</script><p>所以，对于单个样本来说，</p>
<script type="math/tex; mode=display">
-\frac{\partial l(w)}{\partial w}=-(y-h(x))x</script><p>所以随机下降的更新规则为：</p>
<script type="math/tex; mode=display">
w\leftarrow w-\eta[-(y^{(i)}-h(x^{(i)}))x^{(i)}]=w+\eta y^{(i)}x^{(i)}-\eta h(x^{(i)})x^{(i)}</script><h1 id="支持向量机SVM"><a href="#支持向量机SVM" class="headerlink" title="支持向量机SVM"></a>支持向量机SVM</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>支持向量机（support vector machine，SVM）是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机。支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划的问题，也等价于正则化的合页损失函数的最小化问题。支持向量机的学习算法是求解凸二次规划的最优化算法。</p>
<h3 id="线性可分"><a href="#线性可分" class="headerlink" title="线性可分"></a>线性可分</h3><p>如果一个线性函数能够将样本分开，称这些数据样本是线性可分的。那么什么是线性函数呢？其实很简单，在二维空间中就是一条直线，在三维空间中就是一个平面，以此类推，如果不考虑空间维数，这样的线性函数统称为超平面。我们看一个简单的二维空间的例子，O代表正类，X代表负类，样本是线性可分的，但是很显然不只有这一条直线可以将样本分开，而是有无数条，我们所说的线性可分支持向量机就对应着能将数据正确划分并且间隔最大的直线。</p>
<h3 id="间隔最大"><a href="#间隔最大" class="headerlink" title="间隔最大"></a>间隔最大</h3><p>一般来说，一个点距离分离超平面的远近可以表示分类预测的确信度，如图中的 $A, B$ 两个样本点，$B$ 点被预测为正类的确信度要大于 $A$ 点，所以SVM的目标是寻找一个超平面，使得离超平面较近的异类点之间能有更大的间隔，即不必考虑所有样本点，只需让求得的超平面使得离它近的点间隔最大。</p>
<p><img src="http://image.rexking6.top/img/clip1557558151.png" alt=""></p>
<h3 id="函数间隔与几何间隔"><a href="#函数间隔与几何间隔" class="headerlink" title="函数间隔与几何间隔"></a>函数间隔与几何间隔</h3><p>给定一个训练样本 $(x_i,y_i)$，$x$ 是特征，$y$ 是标签，$i$ 表示第 $i$ 个样本。定义函数间隔为： </p>
<script type="math/tex; mode=display">
\hat \gamma_i=y_i(w·x_i+b)</script><p>函数间隔可以表示分类预测的正确性及确信度，但是选择分离超平面时，只有函数间隔还不够。因为只要成比例的改变 $w$ 和 $b$ ，例如将他们改为 $2w$ 和 $2b$ ，超平面并没有改变，但函数间隔却成为原来的2倍。</p>
<p>这一事实告诉我们，可以对分离超平面的法向量 $w$ 加某些约束，如规范化，$||w||=1$，使得间隔是确定的。这时候函数间隔就成为了几何间隔。</p>
<script type="math/tex; mode=display">
\gamma_i=y_i\left(\frac{w}{||w||}·x_i+\frac{b}{||w||}\right)</script><p>可以把几何间隔理解为函数间隔的归一化形式。</p>
<h3 id="间隔最大化"><a href="#间隔最大化" class="headerlink" title="间隔最大化"></a>间隔最大化</h3><p>间隔最大化的直观解释是：对训练数据集找到几何间隔最大的超平面意味着以充分大的确信度对训练数据进行分类。也就说，不仅将正负实例分开，而且对最难分的实例点（离超平面最近的点）也有足够大的确信度将它们分开。这样的超平面应该对未知的新实例又很大的分类预测能力。</p>
<p>这个问题可以表示为下面的约束最优化问题：</p>
<script type="math/tex; mode=display">
\max_{w,b}\left(\min_{i=1,2,\dots,n}\gamma_i\right)\Leftrightarrow\left\{\begin{aligned}&\max_{w,b}\gamma\\&\text{s.t. }y_i\left(\frac{w^Tx_i+b}{||w||}\right)\ge \gamma \\\end{aligned}\right.</script><p>即我们希望最大化超平面 $(w,b)$ 关于训练数据集的几何间隔 $\gamma$。约束条件表示的是超平面 $(w,b)$ 关于每个训练样本的几何间隔至少是 $\gamma$。</p>
<p>根据几何间隔和函数间隔的关系是，可以改写为，</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}&\max_{w,b}\gamma\\&\text{s.t. }y_i\left(\frac{w^Tx_i+b}{||w||}\right)\ge \gamma \\\end{aligned}\right.\Leftrightarrow\left\{\begin{aligned}&\max_{w,b}\frac{\hat \gamma}{||w||}\\&\text{s.t. }y_i\left(\frac{w^Tx_i+b}{||w||}\right)\ge \frac{\hat \gamma}{||w||}\\\end{aligned}\right.\Leftrightarrow\left\{\begin{aligned}&\max_{w,b}\frac{\hat \gamma}{||w||}\\&\text{s.t. }y_i\left({w^Tx_i+b}\right)\ge \hat \gamma \\\end{aligned}\right.</script><p>函数间隔 $\hat \gamma$ 的取值并不影响最优化问题的解。这样，就可以取 $\hat \gamma=1$。将 $\hat \gamma=1$ 代入上面的最优化问题。注意到最大化 $\frac{1}{||w||}$ 和最小化 $\frac{1}{2}||w||^2$ 是等价的，所以我们可以改写为</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}&\max_{w,b}\frac{\hat \gamma}{||w||}\\&\text{s.t. }y_i\left({w^Tx_i+b}\right)\ge \hat \gamma \\\end{aligned}\right.\Leftrightarrow\left\{\begin{aligned}&\max_{w,b}\frac{1}{||w||}\\&\text{s.t. }y_i\left({w^Tx_i+b}\right)\ge 1 \\\end{aligned}\right.\Leftrightarrow\left\{\begin{aligned}&\min_{w,b}\frac{1}{2}||w||^2\\&\text{s.t. }y_i\left({w^Tx_i+b}\right)-1\ge 0 \\\end{aligned}\right.</script><p>这就是一个凸二次规划问题。</p>
<h2 id="硬间隔最大化"><a href="#硬间隔最大化" class="headerlink" title="硬间隔最大化"></a>硬间隔最大化</h2><h3 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h3><p>原始问题为：</p>
<script type="math/tex; mode=display">
\min_{x\in \mathbb R^n}f(x)\\
\begin{aligned}
\text{s.t. }&c_i\le 0,i=1,\dots,k\\
&h_j=0,j=1,\dots,l
\end{aligned}</script><p>拉格朗日函数为：</p>
<script type="math/tex; mode=display">
L(x,\alpha,\beta)=f(x)+\sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x),\ \alpha_i\ge0</script><p>考虑 $x$ 的函数：</p>
<script type="math/tex; mode=display">
\theta_p(x)=\max_{\alpha_i,\beta_j:\alpha_i\ge0}L(x,\alpha,\beta)</script><p>其中，$p$ 表示原问题。</p>
<ol>
<li><p>如果不满足条件，即 $c_i(x)&gt;0$ 或 $h_j(x)\neq 0$，则：</p>
<script type="math/tex; mode=display">
\theta_p(x)=\max_{\alpha_i,\beta_j:\alpha_i\ge0}\left[f(x)+\sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x)\right]=+\infty</script></li>
<li><p>如果 $x$ 满足约束条件，则：</p>
<script type="math/tex; mode=display">
\theta_p(x)=f(x)</script></li>
</ol>
<p>所以，</p>
<script type="math/tex; mode=display">
\theta_p(x)=\left\{\begin{aligned}&f(x)&&,x满足原始问题约束\\&+\infty&&,其他\end{aligned}\right.</script><p>考虑极小化的问题：</p>
<script type="math/tex; mode=display">
\min_x\theta_p(x)=\min_x\max_{\alpha_i,\beta_j:\alpha_i\ge0}L(x,\alpha,\beta)</script><p>它和原问题是等价的，即它们有相同的解，称为广义拉格朗日的极小极大问题。即在满足约束的条件下，通过 $x$ 使问题最小化。</p>
<p>定义原始问题的最优值：</p>
<script type="math/tex; mode=display">
p^\ast=\min_x\theta_p(x)</script><p>对偶问题定义为：</p>
<script type="math/tex; mode=display">
\theta_d(\alpha,\beta)=\min_xL(x,\alpha,\beta)</script><p>极大化上述问题：</p>
<script type="math/tex; mode=display">
\max_{\alpha_i,\beta_j:\alpha_i\ge 0}\theta_d(\alpha,\beta)=\max_{\alpha_i,\beta_j:\alpha\ge0}\min_xL(x,\alpha,\beta)</script><p>上述问题称为广义拉格朗日函数的极大极小问题。</p>
<p>定义对偶问题的最优值：</p>
<script type="math/tex; mode=display">
d^\ast=\max_{\alpha_i,\beta_j:\alpha_i\ge0}\theta_d(\alpha,\beta)</script><p>原始问题与对偶问题的关系：对任意的 $\alpha$，$\beta$ 和 $x$，有：</p>
<script type="math/tex; mode=display">
\theta_d(\alpha,\beta)=\min_xL(x,\alpha,\beta)\le L(x,\alpha,\beta)\le \max_{\alpha_i,\beta_j:\alpha_i\ge0}L(x,\alpha,\beta)=\theta_p(x)</script><p>即，</p>
<script type="math/tex; mode=display">
\theta_d(\alpha,\beta)\le \theta_p(x)</script><p>即，</p>
<script type="math/tex; mode=display">
\max_{\alpha_i,\beta_j:\alpha\ge0}\theta_d(\alpha,\beta)\le\min_x\theta_p(x)</script><p>即，</p>
<script type="math/tex; mode=display">
d^\ast=\max_{\alpha_i,\beta_j:\alpha_i\ge 0}\min_x L(x,\alpha,\beta)\le\min_x\max_{\alpha_i,\beta_j:\alpha_i\ge0}L(x,\alpha,\beta)=p^\ast</script><p>KKT：假设 $L(x,\alpha,\beta)$ 和 $c_i(x)$ 是凸函数，$h_j(x)$ 是仿射函数，且约束 $c_i(x)$ 严格可执行，则满足以下条件后，$x^\ast$，$\alpha^\ast$ 和 $\beta^\ast$ 为极值解。</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}
&\nabla_xL(x^\ast,\alpha^\ast,\beta^\ast)=0\\
&\nabla_\alpha L(x^\ast,\alpha^\ast,\beta^\ast)=0\\
&\nabla_\beta L(x^\ast,\alpha^\ast,\beta^\ast)=0\\
&\alpha_i^\ast c_i(x^\ast)=0,i=1,\dots,k\\
&c_i(x^\ast)\le0,i=1,\dots,k\\
&\alpha_i^\ast\ge 0,i=1,\dots,k\\
&h_j(x^\ast)=0,i=1,\dots,l
\end{aligned}\right.</script><p>其中，$\alpha_i^\ast c_i(x^\ast)=0$ 称为KKT的对偶互补条件。若 $\alpha_i^\ast&gt;0$，则 $c_i(x^\ast)=0$。</p>
<h3 id="回到原问题"><a href="#回到原问题" class="headerlink" title="回到原问题"></a>回到原问题</h3><p><strong>注意：支持向量在不同的地方存在着不同的定义。第一种定义：在间隔超平面上，即使等式 $y(x_1w_1+x_2w_2+b)=1$ 成立的数据点为支持向量；第二种定义，当 $\alpha_i&gt;0$ 时，样本 $x_i$ 为支持向量，第二种的支持向量与第一种的差别关键在于 $\alpha_i(y_i(w^Tx_i+b)-1)=0$ 中，$\alpha_i$ 和 $y_i(w^Tx_i+b)-1$ 有可能同时为0。</strong></p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}&\min_{w,b}\frac{1}{2}||w||^2\\&\text{s.t. }y_i\left({w^Tx_i+b}\right)-1\ge 0 \ ,i=1,\dots,N \\\end{aligned}\right.\Leftrightarrow\left\{\begin{aligned}&\min_{w,b}\frac{1}{2}||w||^2\\&\text{s.t. }1-y_i\left({w^Tx_i+b}\right)\le 0,\ i=1,\dots,N \\\end{aligned}\right.</script><p>拉格朗日函数为：</p>
<script type="math/tex; mode=display">
\begin{align*}
L(w,b,\alpha)&=\frac{1}{2}||w||^2+\sum_{i=1}^N\alpha_i-\sum_{i=1}^N\alpha_iy_iw^Tx_i-\sum_{i=1}^N\alpha_iy_ib\\
&=\frac{1}{2}w^Tw+\sum_{i=1}^N\alpha_i-w^T(\sum_{i=1}^N\alpha_iy_ix_i)-b(\sum_{i=1}^N\alpha_iy_i)
\end{align*}</script><p>求偏导取极值，</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}&\frac{\partial L(w,b,\alpha)}{\partial w}=w-\sum_{i=1}^N\alpha_iy_ix_i=0,\ w=\sum_{i=1}^N\alpha_iy_ix_i\\&\frac{\partial L(w,b,\alpha)}{\partial b}=-\sum_{i=1}^N\alpha_iy_i=0\end{aligned}\right.</script><p>将上式结果代入，</p>
<script type="math/tex; mode=display">
\begin{align*}
L(w,b,\alpha)&=\frac{1}{2}w^Tw+\sum_{i=1}^N\alpha_i-w^T(\sum_{i=1}^N\alpha_iy_ix_i)-b(\sum_{i=1}^N\alpha_iy_i)\\
&=\frac{1}{2}w^Tw+\sum_{i=1}^N\alpha_i-w^Tw\\
&=\sum_{i=1}^N\alpha_i-\frac{1}{2}w^Tw\\
&=-\frac{1}{2}\langle\sum_{i=1}^N\alpha_iy_ix_i,\sum_{i=1}^N\alpha_iy_ix_i\rangle+\sum_{i=1}^N\alpha_i
\end{align*}</script><p>即问题变成了，</p>
<script type="math/tex; mode=display">
\min_{w,b}L(w,b,\alpha)=-\frac{1}{2}\langle\sum_{i=1}^N\alpha_iy_ix_i,\sum_{i=1}^N\alpha_iy_ix_i\rangle+\sum_{i=1}^N\alpha_i</script><p>它的对偶问题为：</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}&\max_{\alpha_i:\alpha_i\ge0}-\frac{1}{2}\langle\sum_{i=1}^N\alpha_iy_ix_i,\sum_{i=1}^N\alpha_iy_ix_i\rangle+\sum_{i=1}^N\alpha_i\\&\text{s.t. }\sum_{i=1}^N\alpha_iy_i=0\end{aligned}\right.</script><p>符号取反，</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}&\min_{\alpha_i:\alpha_i\ge0}\frac{1}{2}\langle\sum_{i=1}^N\alpha_iy_ix_i,\sum_{i=1}^N\alpha_iy_ix_i\rangle-\sum_{i=1}^N\alpha_i\\&\text{s.t. }\sum_{i=1}^N\alpha_iy_i=0\end{aligned}\right.</script><p>把目标函数展开，</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}&\min_{\alpha_i:\alpha_i\ge0}\frac{1}{2}\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j\langle x_i,x_j\rangle-\sum_{i=1}^N\alpha_i\\&\text{s.t. }\sum_{i=1}^N\alpha_iy_i=0\end{aligned}\right.</script><p>设 $\alpha^\ast=(\alpha_1^\ast,\alpha_2^\ast,\dots,\alpha_N^\ast)$ 是上述问题的最优解，设原始问题最优解 $w^\ast$ 和 $b^\ast$。</p>
<p>KKT条件为：</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}
&\nabla_wL(w^\ast,b^\ast,\alpha^\ast)=w^\ast-\sum_{i=1}^N\alpha_i^\ast y_ix_i=0,w^\ast=\sum_{i=1}^N\alpha_i^\ast y_ix_i\\
&\nabla_bL(w^\ast,b^\ast,\alpha^\ast)=-\sum_{i=1}^N\alpha_i^\ast y_i=0\\
&\alpha_i^\ast(y_i(w^\ast x_i+b^\ast)-1)=0,i=1,\dots,N\\
&y_i(w^\ast x_i+b^\ast)-1\ge0,i=1,\dots,N\\
&\alpha_i\ge 0,i=1,\dots,N
\end{aligned}\right.</script><p>由上式可得：$\exists \alpha_j^\ast\neq 0\Leftrightarrow y_j(w^{\ast T}x_j+b^\ast)=1$，因为 $y_j=\pm 1$，所以 $w^{\ast T} x_j+b^\ast=\pm 1$，得：</p>
<script type="math/tex; mode=display">
y_j(w^{\ast T} x_j+b^\ast)=1=y_j^2\ \Rightarrow\ b^\ast=y_j-w^{\ast T} x_j=y_j-\sum_{i=1}^N\alpha_i^\ast y_i x_i ·x_j</script><p>这表示只有部分点能起到作用，即支持向量。</p>
<p>最终，分类决策函数为：</p>
<script type="math/tex; mode=display">
f(x)=\text{sign}(\sum_{i=1}^N\alpha_i^\ast y_i(x_i·x)+b^\ast)</script><p>其中，$b^\ast=y_j-w^{\ast T} x_j$。</p>
<p><strong>注意：有两个地方需要求偏导：1. KKT；2. 取极值。KKT条件中的偏导为0，是最优解 $w^\ast, b^\ast$；取极值，是在原问题得出后，偏导为0，代入，得对偶问题。</strong></p>
<h2 id="软间隔最大化"><a href="#软间隔最大化" class="headerlink" title="软间隔最大化"></a>软间隔最大化</h2><p>引入松弛变量，$\xi_i$ 表示样本逾越的程度。</p>
<ul>
<li>$\xi_i<0,y_i(w^Tx_i+b)=1-\xi_i>1$，未逾越且很远；</li>
<li>$\xi_i=0,y_i(w^Tx_i+b)=1-\xi_i=1$，在最大间隔边界上；</li>
<li>$0&lt;\xi_i&lt;1$，跨越了最大间隔边界，依然线性可分不过间隔变窄；</li>
<li>$\xi_i=1,y_i(w^Tx_i+b)=1-\xi_i=0$，到达“中线”，间隔称为“线”；</li>
<li>$\xi_i&gt;1,y_i(w^Tx_i+b)=1-\xi_i&lt;0$，跨越了“中线”，线性不可分。</li>
</ul>
<p>引入松弛变量，约束条件变为：</p>
<script type="math/tex; mode=display">
y_i(w^Tx_i+b)\ge 1-\xi_i</script><p>即允许部分犯错。</p>
<p>问题变成：</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}&\min_{w,b,\xi}\frac{1}{2}||w||^2+C\sum_{i=1}^N\xi_i\\&\text{s.t. }y_i\left({w^Tx_i+b}\right)\ge1-\xi_i \ ,i=1,\dots,N \\&\xi_i\ge0,i=1,\dots,N\end{aligned}\right.</script><p>拉格朗日函数：</p>
<script type="math/tex; mode=display">
L(w,b,\xi,\alpha,\mu)=\frac{1}{2}||w||^2+C\sum_{i=1}^N\xi_i-\sum_{i=1}^N\alpha_i(y_i(w^Tx_i+b)-1+\xi_i)-\sum_{i=1}^N\mu_i\xi_i</script><p>求偏导为：</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}&\frac{\partial L(w,b,\xi,\alpha,\mu)}{\partial w}=w-\sum_{i=1}^N\alpha_iy_ix_i=0, w=\sum_{i=1}^N\alpha_iy_ix_i\\&\frac{\partial L(w,b,\xi,\alpha,\mu)}{\partial b}=-\sum_{i=1}^N\alpha_iy_i=0\\&\frac{\partial L(w,b,\xi,\alpha,\mu)}{\partial \xi_i}=C-\alpha_i-\mu_i=0\end{aligned}\right.</script><p>代入拉格朗日函数，</p>
<script type="math/tex; mode=display">
\begin{align*}
\min_{w,b,\xi}L(w,b,\xi,\alpha,\mu)&=-\frac{1}{2}w^Tw+C\sum_{i=1}^N\xi_i+\sum_{i=1}^N\alpha_i-\sum_{i=1}^N\alpha_i\xi_i-\sum_{i=1}^N\mu_i\xi_i\\
&=-\frac{1}{2}\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j\langle x_i,x_j\rangle+\sum_{i=1}^N\alpha_i
\end{align*}</script><p>对偶问题为：</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}&\max_\alpha&&-\frac{1}{2}\sum_{i=1}^N\sum_{j=1}^Ny_iy_j\langle x_i,x_j\rangle+\sum_{i=1}^N\alpha_i\\&\text{s.t. }&&\sum_{i=1}^N\alpha_iy_i=0\\&&&c-\alpha_i-y_i=0\\
&&&\alpha_i\ge 0\\
&&&\mu_i\ge 0,i=1,2,\dots,N\end{aligned}\right.</script><p>符号取反为：</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}&\min_\alpha&&\frac{1}{2}\sum_{i=1}^N\sum_{j=1}^Ny_iy_j\langle x_i,x_j\rangle-\sum_{i=1}^N\alpha_i\\&\text{s.t. }&&\sum_{i=1}^N\alpha_iy_i=0\\&&&0\le \alpha_i\le C,i=1,\dots,N\end{aligned}\right.</script><p>同样地，设 $\alpha^\ast$ 为上述问题最优解，原始最优解为 $w^\ast$ 和 $b^\ast$。</p>
<p>KKT条件为：</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}
&\nabla_wL(w^\ast,b^\ast,\xi^\ast,\alpha^\ast,\mu^\ast)=w^\ast-\sum_{i=1}^N\alpha_i^\ast y_ix_i=0, w^\ast=\sum_{i=1}^N\alpha_i^\ast y_ix_i\\
&\nabla_b L(w^\ast,b^\ast,\xi^\ast,\alpha^\ast,\mu^\ast)=-\sum_{i=1}^N\alpha_i^\ast y_i=0\\
&\nabla_{\xi_i} L(w^\ast,b^\ast,\xi^\ast,\alpha^\ast,\mu^\ast)=C-\alpha_i^\ast-\mu_i^\ast=0\\
&\alpha_i^\ast(y_i(w^{\ast T} x_i+b^\ast)-1+\xi_i^\ast)=0,i=1,\dots,N\\
&\mu_i^\ast \xi_i^\ast =0,i=1,\dots,N\\
&y_i(w^{\ast T} x_i+b^\ast)-1+\xi_i^\ast\ge0,i=1,\dots,N\\
&\xi_i\ge 0,\alpha_i\ge 0,\mu_i\ge 0,i=1,\dots,N
\end{aligned}\right.</script><p>若存在 $\alpha^\ast$ 的一个分量 $\alpha_j^\ast$，</p>
<ol>
<li>$0&lt;\alpha_j^\ast&lt;C$，则：<script type="math/tex; mode=display">
y_i(w^{\ast T} x_i+b^\ast)-1=0</script>则：<script type="math/tex; mode=display">
b^\ast=y_j-\sum_{i=1}^Ny_i\alpha_i^\ast\langle x_i,x_j\rangle</script>决策函数为：<script type="math/tex; mode=display">
f(x)=\text{sign}(\sum_{i=1}^N\alpha_i^\ast y_i\langle x,x_i\rangle+b^\ast)</script>满足该条件的点位于间隔平面上，即都满足于 $y_i(w^{\ast T} x_i+b^\ast)-1=0$ ，且 $w^\ast, b^\ast$ 都唯一。</li>
</ol>
<ol>
<li>$a_j^\ast=0$，全部为零，不可能，不考虑。</li>
</ol>
<ol>
<li>$\alpha_j^\ast=C$，即去除$\alpha_j^\ast=0$ 的数据点后，没有 $0&lt;\alpha_j^\ast&lt;C$ 的数据点，只有 $\alpha_j^\ast=C$ 中，正负样本的数量相等。这种情况下，根据<script type="math/tex; mode=display">
\alpha_i^\ast(y_i(w^{\ast T} x_i+b^\ast)-1+\xi_i^\ast)=0</script>则：<script type="math/tex; mode=display">
y_i(w^{\ast T} x_i+b^\ast)-1+\xi_i^\ast=0</script>之后，取 $\xi_i^\ast$ 的值，平均多个点求出 $\bar b^\ast$。</li>
</ol>
<h2 id="序列最小最优化算法"><a href="#序列最小最优化算法" class="headerlink" title="序列最小最优化算法"></a>序列最小最优化算法</h2><p>当训练样本容量很大时，我们需要一些快速实现算法来提高支持向量机的效率。</p>
<p>SMO算法是一种启发式算法，其基本思路是：如果所有变量的解都满足此最优化问题的KKT条件，那么这个最优化问题的解就得到了。整个SMO算法包括两个部分：求解两个变量二次规划的解析方法和选择变量的启发式方法。下面给出SMO算法的具体步骤：</p>
<ol>
<li>取初值 $\alpha^{(0)}=0$，令 $k=0$；</li>
<li>选取优化变量 $\alpha_1^{(k)},\alpha_2^{(k)}$，解析求解两个变量的最优化问题，求得最优解 $\alpha_1^{(k+1)},\alpha_2^{(k+1)}$，更新为 $\alpha$ 为 $\alpha^{(k+1)}$；</li>
<li>若在精度 $\varepsilon$ 范围内满足停机条件，则转(4)；否则令 $k=k+1$，转(2)；</li>
<li>取 $\hat \alpha = \alpha^{(k+1)}$。</li>
</ol>
<h2 id="SVM的损失函数"><a href="#SVM的损失函数" class="headerlink" title="SVM的损失函数"></a>SVM的损失函数</h2><p>SVM的损失函数为：</p>
<script type="math/tex; mode=display">
\min_{w,b}\sum_{i=1}^N\max(0,1-y_i(w^Tx_i+b))+\lambda||w||^2</script><p>原始最优化问题是：</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}&\min_{w,b,\xi}\frac{1}{2}||w||^2+C\sum_{i=1}^N\xi_i\\&\text{s.t. }y_i\left({w^Tx_i+b}\right)\ge1-\xi_i \ ,i=1,\dots,N \\&\xi_i\ge0,i=1,\dots,N\end{aligned}\right.</script><p>要让两者等价，首先有：</p>
<script type="math/tex; mode=display">
\xi_i\ge1-y_i(w^Tx_i+b)</script><p>也就是说，当样本点被正确分类且函数间隔 $y_i(w^Tx_i+b)$ 大于1时，损失为0，否则损失是 $1-y_i(w^Tx_i+b)$ ，图表示为：</p>
<p><img src="http://image.rexking6.top/img/clip1557567050.png" alt=""></p>
<p>称为合页损失（或铰链损失，hinge loss）。</p>
<p>对比一下：</p>
<ul>
<li>感知机：$L(w,b)=-\sum_{x_i\in M}y_i(w^Tx_i+b)=\sum_{i=1}^N\max(0,-y_i(w^Tx_i+b))$</li>
<li>SVM：$L(w,b)=-\sum_{x_i\in M}y_i(w^Tx_i+b)=\sum_{i=1}^N\max(0,1-y_i(w^Tx_i+b))$</li>
</ul>
<p><img src="http://image.rexking6.top/img/clip1557567236.png" alt=""></p>
<p>其中绿线表示SVM的损失函数，紫线表示感知机的损失函数，当 $f(x)$ 大于0的时候，感知机的loss直接就为0了，也就是说，它只需要分对就行了，“做事”比较粗糙，而对于SVM来说，$f(x)$ 大于0，损失依然存在，直到 $f(x)$ 大于等于1，它才对分类结果比较满意，loss才降为0，换句话来说，SVM“做事”比较严谨。</p>
<p>而当 $\lambda=\frac{1}{2C}$ 时，可以看出SVM是建立在结构风险最小化的基础上的。</p>
<h2 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h2><p>其中 $\langle x_i,x_j\rangle$ 计算的是数据矩阵的第 $i$ 维与第 $j$ 维的内积，这其实是比较低维的输入空间，如果将它通过核技巧，将它映射到高维，变得线性可分，再依靠SVM在线性可分问题上强大的分类能力，问题似乎变得简单起来了。</p>
<p>常见的核函数有：</p>
<ul>
<li>Linear：$k(x_i,x_j)=x_i^Tx_j$</li>
<li>Polynomial：$k(x_i,x_j)=(ax_i^Tx_j+c)^d$</li>
<li>Gaussian：$k(x_i,x_j)=\exp(-\frac{||x_i-x_j||^2}{2\sigma^2})$</li>
<li>Sigmoid：$k(x_i,x_j)=\tanh (ax_i^Tx_j+c)$</li>
</ul>
<h1 id="Logistic回归分类模型"><a href="#Logistic回归分类模型" class="headerlink" title="Logistic回归分类模型"></a>Logistic回归分类模型</h1><p>（注：因为上课所讲的和PPT里所用的符号有冲突，这里个人统一了一下，可能会有遗漏。）</p>
<p>接上节课所说的，Logistic回归分类模型的对数损失函数为：</p>
<script type="math/tex; mode=display">
L(w)=\sum_{i=1}^n[-(y_i\text{ln}\sigma_i+(1-y_i)\text{ln}(1-\sigma_i))],\tag 1</script><p>其中，$\sigma_i=\frac{1}{1+\text{exp}(-w^Tx_i)}$。</p>
<h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>求解损失函数的梯度，即对 $w$ 的偏导为：</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial w}=\sum_{i=1}^n(\sigma_i-y_i)x_i,</script><p>其矩阵形式为：</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial w}=X^T(\vec \sigma-\vec y).\tag 2</script><p>利用梯度下降法的算法流程为：</p>
<p><img src="http://image.rexking6.top/img/clip1553785626.png" alt=""></p>
<h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><p>简单地说，牛顿法是二阶逼近，梯度下降法是一阶逼近。</p>
<p>牛顿法是利用泰勒级数来进行逼近。首先，对 $f(x)$ 的级数展开至两次，</p>
<script type="math/tex; mode=display">
f(x_0+\Delta x)=f(x_0)+f'(x_0)\Delta x+\frac{f''(x_0)}{2}\Delta x^2+R(\Delta x)</script><p>现假设：</p>
<script type="math/tex; mode=display">
g(\Delta x)=f(x_0)+f'(x_0)\Delta x+\frac{f''(x_0)}{2}\Delta x^2</script><p>$g(\Delta x)$ 是一个关于 $\Delta x$ 的一元二次方程，一元二次方程的最小值求法：</p>
<script type="math/tex; mode=display">
f(x)=ax^2+bx+c,</script><p>$f(x)$ 的极值点为 $-\frac{b}{2a}$。所以，$g(\Delta x)$ 的极值为：</p>
<script type="math/tex; mode=display">
-\frac{f'(x_0)}{f''(x_0)},</script><p>此时 $f(x_0+\Delta x)$ 的极值为：</p>
<script type="math/tex; mode=display">
x_1 = x_0-\frac{f'(x_0)}{f''(x_0)},</script><p>以此类推，</p>
<script type="math/tex; mode=display">
x_n=x_{n-1}-\frac{f'(x_{n-1})}{f''(x_{n-1})}</script><p>当 $f(x)$ 是一个多元函数时，则为：</p>
<script type="math/tex; mode=display">
x_n=x_{n-1}-\frac{\nabla f(x_{n-1})}{\mathbb{H}(f(x_{n-1}))}</script><hr>
<p>将牛顿法应用到Logistic回归分类模型，则总的算法流程为：</p>
<p><img src="http://image.rexking6.top/img/clip1553822011.png" alt=""></p>
<p>其中，$g$ 为一阶导 $\frac{\partial L}{\partial w}$，所以我们需要求出 $L(w)$ 的二阶偏导，</p>
<script type="math/tex; mode=display">
\frac{\partial^2L(w)}{\partial w_j \partial w_k}=\sum_{i=1}^nx_i^{(j)}\sigma_i(1-\sigma_i)x_i^{(k)},</script><p>其中，$j$ 和 $k$ 表示的是第几维，$i$ 表示的是第几个样本。写成矩阵形式为：</p>
<script type="math/tex; mode=display">
\mathbb{H}=X^TBX,\tag 3</script><p>其中，</p>
<script type="math/tex; mode=display">
B=\left(\begin{align}\sigma_1(1-\sigma_1)\\&\ddots\\&& \sigma_n(1-\sigma_n) \end{align}\right).</script><p>$w^{t+1}$ 的更新方式如上图所示，</p>
<script type="math/tex; mode=display">
w^{t+1}\leftarrow w^t-\mathbb{H}^{-1}g,</script><p>将 $L(w)$ 的一阶偏导和二阶偏导，即(2)式和(3)式代入得，</p>
<script type="math/tex; mode=display">
w^{t+1}\leftarrow w^t-(X^TBX)^{-1}X^T(\vec \sigma-\vec y).</script><p>对上式进行变换，</p>
<script type="math/tex; mode=display">
\begin{align*}
w^{t+1}&=w^t-(X^TBX)^{-1}X^T(\vec \sigma - \vec  y)\\
&=(X^TBX)^{-1}X^TBXw^t-(X^TBX)^{-1}X^TBB^{-1}(\vec \sigma - \vec  y)\\
&=(X^TBX)^{-1}X^TB(Xw^t-B^{-1}(\vec \sigma-\vec y))\\
&=(X^TBX)^{-1}X^TBS^t
\end{align*}\tag 4</script><p>其中，$S^t=Xw^t-B^{-1}(\vec \sigma-\vec y)$。</p>
<hr>
<p>这里先不管上面的，介绍一种算法：迭代重加权最小二乘法（Iterative Reweighted Least Squares，IRLS），即是说，每次迭代更新参数时，它会有一个随着迭代次数 $t$ 变化的权重 $\widetilde W^{t}$ 在影响。</p>
<p>它被应用于p范数损失函数的优化，本质上是用2范数来近似替代p范数。</p>
<p>算法表示为：</p>
<script type="math/tex; mode=display">
\beta^{(t+1)}=\text{arg min}_\beta \sum_{i=1}^n\tilde w_i^t|\tilde y_i-\widetilde X_i\beta|^2=(\widetilde X^T\widetilde W^t\widetilde X)^{-1}\widetilde X^T\widetilde W^t\widetilde y.</script><p>与上面的(4)式比对，</p>
<script type="math/tex; mode=display">
\begin{align*}
\widetilde X&=X\\
\widetilde W^t&=B\\
\tilde y&=S^t
\end{align*}</script><hr>
<p>所以，(4)式在某种程度上，可以看作是以下问题的梯度下降法，</p>
<script type="math/tex; mode=display">
\text{arg min}_w \sum_{i=1}^n\sigma_i(1-\sigma_i)(w^Tx_i-S_i^t).</script><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d429c9de8f63">牛顿法和梯度下降法的学习</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Iteratively_reweighted_least_squares">Iteratively reweighted least squares</a></li>
</ol>
<h1 id="产生式模型"><a href="#产生式模型" class="headerlink" title="产生式模型"></a>产生式模型</h1><p>之前我们学习的几种算法，包括Logistic回归、SVM和感知机，都是属于判别式模型。它们是直接对 $p(y|x)$ 进行建模或者直接学习输入空间到输出空间的映射关系，其中，$x$ 是某类样例的特征，$y$ 是某类样例的分类标记。</p>
<p>今天要讲的产生式模型，又称“生成式模型”。其中经典算法有：朴素贝叶斯、隐式马尔可夫模型和高斯判别模型。产生式模型实对 $p(x|y)$ （条件概率）和 $p(y)$ （先验概率）进行建模，然后按贝叶斯法则求出后验概率 $p(y|x)$：</p>
<script type="math/tex; mode=display">
p(y|x)=\frac{p(x|y)p(y)}{p(x)},</script><p>使得后验概率最大的类别 $y$ 即是新样例的预测值：</p>
<script type="math/tex; mode=display">
\text{arg max}_y p(y|x)=\text{arg max}_y \frac{p(x|y)p(y)}{p(x)} = \text{arg max}_y p(x|y)p(y).</script><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>朴素贝叶斯主要解决的是特征为离散值的问题。</p>
<p>它主要基于以下两个假设：</p>
<ol>
<li>各个维度独立，即 $P(X_1,\cdots,X_d|Y)=\prod_{j=1}^dP(X_j|Y)$，这也是它被称为”朴素“的原因；</li>
<li>各个维度的取值为0或1，即 $X_i\in\{0, 1\}$。</li>
</ol>
<p>而与朴素贝叶斯的假设相反的，称为贝叶斯网络，它假设各个维度都不独立。贝叶斯网络还有很多名字：有向无环概率图、信念网络、置信网络等，有些听起来感觉很叼，但它们都指的是贝叶斯网络。</p>
<hr>
<p>假设现在有一些数据 $D$，标签为0或1，</p>
<script type="math/tex; mode=display">
D=\{\langle x_i,y_i\rangle\}_{i=1}^n,x_i\in\mathbb{R}^d,y_i\in\{0,1\}</script><p>二分类问题，可用伯努利分布来刻画：</p>
<ol>
<li>标签的分布为：</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">$y_i=1$</th>
<th style="text-align:center">$y_i=0$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$p(y_i)$</td>
<td style="text-align:center">$\varphi_1$</td>
<td style="text-align:center">$1-\varphi_1$</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
p(y_i)=(\varphi_1)^{y_i}(1-\varphi_1)^{1-y_i}.\tag 5</script><ol>
<li>当样本的标签为0时，其第 $j$ 维特征的分布为：</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">$x_{ij}=1$</th>
<th style="text-align:center">$x_{ij}=0$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$p(x_{ij}</td>
<td style="text-align:center">y_i=0)$</td>
<td style="text-align:center">$\varphi_{j0}$</td>
<td>$1-\varphi_{j0}$</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
p(x_{ij}|y_i=0)=(\varphi_{j0})^{x_{ij}}(1-\varphi_{j0})^{1-x_{ij}},</script><p>其中，$x_{ij}$ 表示的是第 $i$ 样本的第 $j$ 维特征。</p>
<ol>
<li>当样本的标签为1时，其第 $j$ 维特征的分布为：</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">$x_{ij}=1$</th>
<th style="text-align:center">$x_{ij}=0$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$p(x_{ij}</td>
<td style="text-align:center">y_i=1)$</td>
<td style="text-align:center">$\varphi_{j1}$</td>
<td>$1-\varphi_{j1}$</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
p(x_{ij}|y_i=1)=(\varphi_{j1})^{x_{ij}}(1-\varphi_{j1})^{1-x_{ij}},</script><p>似然函数为：</p>
<script type="math/tex; mode=display">
\begin{align*}
L(\phi)&=\prod_{i=1}^n p(\langle x_i, y_i\rangle)\\
&=\prod_{i=1}^n \left[p(y_i)p(x_i|y_i)\right]\\
&=\prod_{i=1}^n \left[p(y_i)\prod_{j=1}^d p(x_{ij}|y_i)\right]\\
&=\prod_{i=1}^n \left[p(y_i)\times\left(\prod_{j=1}^dp(x_{ij}|y_i=1)\right)^{1(y_i=1)}\times \left(\prod_{j=1}^dp(x_{ij}|y_i=0)\right)^{1(y_i=0)}\right]
\end{align*}</script><p>对数似然函数为：</p>
<script type="math/tex; mode=display">
\begin{align*}
\text{ln}L(\phi)&=\text{ln}\prod_{i=1}^n \left[p(y_i)\times\left(\prod_{j=1}^dp(x_{ij}|y_i=1)\right)^{1(y_i=1)}\times \left(\prod_{j=1}^dp(x_{ij}|y_i=0)\right)^{1(y_i=0)}\right]\\
&=\sum_{i=1}^n\left[\text{ln}p(y_i)+1(y_i=1)\text{ln}\left(\prod_{j=1}^dP(x_{ij}|y_i=1)\right)+1(y_i=0)\text{ln}\left(\prod_{j=1}^dP(x_{ij}|y_i=0)\right)\right]\\
&=\sum_{i=1}^n\left[\text{ln}\left((\varphi_1)^{y_i}(1-\varphi_1)^{1-y_i}\right)+1(y_i=0)\text{ln}\left(\prod_{j=1}^d(\varphi_{j0})^{x_{ij}}(1-\varphi_{j0})^{1-x_{ij}}\right)\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ +1(y_i=1)\text{ln}\left(\prod_{j=1}^d(\varphi_{j1})^{x_{ij}}(1-\varphi_{j1})^{1-x_{ij}}\right)\right]\\
&=\sum_{i=1}^n\left(y_i\text{ln}\varphi_1+(1-y_i)\text{ln}(1-\varphi_1)\right)+\sum_{i=1}^n\left[1(y_i=0)\sum_{j=1}^d\left(x_{ij}\text{ln}\varphi_{j0}+(1-x_{ij})\text{ln}(1-\varphi_{j0})\right)\right]\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ +\sum_{i=1}^n\left[1(y_i=1)\sum_{j=1}^d\left(x_{ij}\text{ln}\varphi_{j1}+(1-x_{ij})\text{ln}(1-\varphi_{j1})\right)\right]
\end{align*}</script><p>为了最大化对数似然函数，</p>
<script type="math/tex; mode=display">
\varphi_{MLE}=\text{arg max}_\varphi L(\phi)=\text{arg max}_\varphi \text{ln}L(\phi),</script><p>对其各个参数求偏导，并令偏导数为零，即：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\frac{\partial \text{ln}L}{\partial \varphi_1}=\sum_{i=1}^n\left(y_i·\frac{1}{\varphi_1}-(1-y_i)·\frac{1}{(1-\varphi_1)}\right)=0\tag 6\\
&\frac{\partial \text{ln}L}{\partial \varphi_{j0}}=\sum_{i=1}^n\left(1(y_i=0)\left(x_{ij}·\frac{1}{\varphi_{j0}}-(1-x_{ij})·\frac{1}{(1-\varphi_{j0})}\right)\right)=0 \tag 7\\
&\frac{\partial \text{ln}L}{\partial \varphi_{j1}}=\sum_{i=1}^n\left(1(y_i=1)\left(x_{ij}·\frac{1}{\varphi_{j1}}-(1-x_{ij})·\frac{1}{(1-\varphi_{j1})}\right)\right)=0 \tag 8\\
\end{align*}</script><p>接下来，我们从(6)式开始推，</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{i=1}^n\left(y_i·\frac{1}{\varphi_1}-(1-y_i)·\frac{1}{(1-\varphi_1)}\right)&=0\\
\sum_{i=1}^n\left(\frac{y_i(1-\varphi_1)-(1-y_i)\varphi_1}{\varphi_1(1-\varphi_1)}\right)&=0\\
\sum_{i=1}^n\left(\frac{y_i-\varphi_1}{\varphi_1(1-\varphi_1)}\right)&=0\\
\frac{\sum_{i=1}^n(y_i-\varphi_1)}{\varphi_1(1-\varphi_1)}&=0\\
\sum_{i=1}^n(y_i-\varphi_1)&=0\\
\sum_{i=1}^ny_i-n\varphi_1&=0\\
\varphi_1 &=\frac{\sum_{i=1}^n1\{y_i=1\}}{n}\tag 9
\end{align*}</script><p>然后是(7)式，类似上式，步骤稍微跳跃一下</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{i=1}^n\left(1(y_i=0)\left(x_{ij}·\frac{1}{\varphi_{j0}}-(1-x_{ij})·\frac{1}{(1-\varphi_{j0})}\right)\right)&=0\\
\sum_{i=1}^n\left(1(y_i=0)\left(\frac{x_{ij}(1-\varphi_{j0})-(1-x_{ij})\varphi_{j0}}{\varphi_{j0}(1-\varphi_{j0})}\right)\right)&=0\\
\sum_{i=1}^n\left(1(y_i=0)\left(x_{ij}-\varphi_{j0}\right)\right)&=0\\
\sum_{i=1}^n1\{y_i=1\wedge x_{ij}=1\}-\sum_{i=1}^n1\{y_i=0\}\varphi_{j0}&=0\\
\varphi_{j0}&=\frac{\sum_{i=1}^n1\{y_i=0\wedge x_{ij}=1\}}{\sum_{i=1}^n1\{y_i=0\}}\tag{10}
\end{align*}</script><p>同理可得，</p>
<script type="math/tex; mode=display">
\varphi_{j1}=\frac{\sum_{i=1}^n1\{y_i=1\wedge x_{ij}=1\}}{\sum_{i=1}^n1\{y_i=1\}}.\tag{11}</script><p>推导完成。</p>
<p>因为朴素贝叶斯模型简单，所以只需要少量样本就足够训练。</p>
<p><strong>零概率问题</strong>：零概率问题就是在计算新实例的概率时，如果某个分量在训练集中从没有出现过，会导致整个实例的概率计算结果为0，这显然是不合理的。为了解决这个问题，引出拉普拉斯平滑：</p>
<script type="math/tex; mode=display">
P(w|c)=\frac{\text{num}(w,c)+\varepsilon}{\text{num}(c)+2\varepsilon}</script><p><strong>属性缺失问题</strong>：如果数据中某个可能维度的值缺失，可以不用管，不会受到影响。原因是不用管意味着计算概率时忽略该维度的影响，即没有对该维度加入先验。</p>
<p>而在最开始提到的贝叶斯网络，即概率图，该模型中每个结点之间都是相关的，所以复杂度最大能达到 $C_d^2$ ，其中 $d$ 为样本 $x_i$ 的特征维数。</p>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>朴素贝叶斯法将实例分到后验概率最大的类中，这等价于<strong>期望风险最小化</strong>。假设选择0-1损失函数：</p>
<script type="math/tex; mode=display">
L(Y,f(X))=\left\{\begin{align}&1,&&Y\neq f(X)\\&0,&&Y=f(X)\end{align}\right.</script><p>式中 $f(X)$ 是分类决策函数。这时，期望风险函数为，</p>
<script type="math/tex; mode=display">
\begin{align*}
R_{\text{exp}}(f)&=E[L(Y,f(X))]\\
&=E_X \left[\sum_{k=1}^KL(c_k,f(X))P(c_k|X)\right]
\end{align*}</script><p>为了使期望风险最小化，只需对 $X=x$ 逐个极小化，</p>
<script type="math/tex; mode=display">
Y\in\{c_1,c_2,\dots,c_K\}\\
\begin{align*}
R_{\text{exp}}(f)&=E[L(Y,f(x))]\\
&=\iint L(Y=y,f(X=x))P(X=x,Y=y)dxdy\\
&=\iint L(Y=y,f(X=x))P(Y=y|X=x)p(X=x)dxdy\\
&=\int \left\{\int[L(Y=y,f(X=x))P(Y=y|X=x)]dy\right\}p(X=x)dx\\
&=\int \left\{\sum_{k=1}^KL(c_k,f(X=x))P(c_k|X=x)\right\}p(X=x)dx\\
&=E_X \left[\sum_{k=1}^KL(c_k,f(X))P(c_k|X)\right]
\end{align*}</script><p>由此得到：</p>
<script type="math/tex; mode=display">
\begin{align*}
f(x)&=\text{arg min}_{y\in Y}\sum_{k=1}^KL(c_k,y)P(c_k|X=x)\\
&=\text{arg min}_{y\in Y}\sum_{k=1}^KP(y\neq c_k|X=x)\\
&=\text{arg min}_{y\in Y}(1-P(y=c_k|X=x))\\
&=\text{arg max}_{y\in Y}P(y=c_k|X=x)
\end{align*}</script><p>这样一来，根据期望风险最小化准则就得到了后验概率最大化准则：</p>
<script type="math/tex; mode=display">
f(x)=\text{arg max}_{c_k}P(c_k|X=x)</script><h3 id="高斯判别分析"><a href="#高斯判别分析" class="headerlink" title="高斯判别分析"></a>高斯判别分析</h3><p>在朴素贝叶斯中，我们假设 $x$ 是离散的，服从多项分布（包括伯努利分布）。在高斯判别分析（Gaussian discriminant analysis，GDA）中，我们假设 $x$ 是连续的，服从高斯分布。根据以下公式，判别样本 $x$ 的标签。</p>
<script type="math/tex; mode=display">
\begin{align*}
y^\ast&=\text{arg max}_{y\in\{0,1\}}p(y|x)\\
&=\text{arg max}_{y\in\{0,1\}}p(y)p(x|y)\\
&\Leftrightarrow\frac{p(y=1)p(x|y=1)}{p(y=0)p(x|y=0)}?>1\\
&\Leftrightarrow\text{ln}\left[\frac{p(y=1)p(x|y=1)}{p(y=0)p(x|y=0)}\right]?>0
\end{align*}</script><p>该模型基于两点假设，$y$ 服从伯努利分布，特征 $x$ 是多元高斯分布。写出分布概率密度为：</p>
<script type="math/tex; mode=display">
\begin{align*}
&p(y=1)=\phi,&&p(y=0)=1-\phi\\
&p(x|y=1)\sim N(\mu_1,\Sigma),&&p(x|y=1)=(2\pi)^{-\frac{d}{2}}|\Sigma|^{-\frac{1}{2}}\text{exp}\left\{-\frac{1}{2}(x-\mu_1)^T\Sigma(x-\mu_1)\right\}\\
&p(x|y=0)\sim N(\mu_0,\Sigma),&&p(x|y=0)=(2\pi)^{-\frac{d}{2}}|\Sigma|^{-\frac{1}{2}}\text{exp}\left\{-\frac{1}{2}(x-\mu_0)^T\Sigma(x-\mu_0)\right\}
\end{align*}</script><p>所以，比较 $p(y=1)p(x|y=1)$ 和 $p(y=0)p(x|y=0)$ 的大小：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\text{ln}\left[\frac{p(y=1)p(x|y=1)}{p(y=0)p(x|y=0)}\right]\\
=&\text{ln}\frac{\phi \times(2\pi)^{-\frac{d}{2}}|\Sigma|^{-\frac{1}{2}}\text{exp}\left\{-\frac{1}{2}(x-\mu_1)^T\Sigma(x-\mu_1)\right\}}{(1-\phi) \times(2\pi)^{-\frac{d}{2}}|\Sigma|^{-\frac{1}{2}}\text{exp}\left\{-\frac{1}{2}(x-\mu_0)^T\Sigma(x-\mu_0)\right\}}\\
=&(\mu_1^T\Sigma-\mu_0^T\Sigma)x+\frac{1}{2}\mu_0^T\Sigma\mu_0-\frac{1}{2}\mu_1\Sigma\mu_1+\text{ln}\frac{\phi}{1-\phi}\\
=&w^Tx+b
\end{align*}</script><p>可以看到GDA实际上是一个线性模型，这是一个判别式模型。产生式模型有其对应的判别式模型，这样的组合叫做“产生式-判别式”对；判别式模型不一定有其对应的产生式模型。</p>
<ul>
<li>训练样本多的情况下，采用判别式；</li>
<li>训练样本少的情况下，采用产生式。</li>
</ul>
<h2 id="隐马尔可夫模型"><a href="#隐马尔可夫模型" class="headerlink" title="隐马尔可夫模型"></a>隐马尔可夫模型</h2><p>隐马尔可夫模型是关于时序的概率模型，描述由一个隐藏的马尔可夫链随机生成不可观测的状态随机序列，再由各个状态生成一个观测而产生观测随机序列的过程。</p>
<p>隐马尔可夫链随机生成的状态的序列，成为状态序列；每个状态生成一个观测，而由此产生的观测的随机序列，称为观测序列。序列的每一个位置又可以看作是一个时刻。</p>
<p><img src="http://image.rexking6.top/img/clip1554628530.png" alt=""></p>
<p>隐马尔可夫模型由初始概率分布、状态转移概率和观测概率（又称“发射概率”）确定。隐马尔可夫模型的形式定义如下，设 $Q$ 是所有可能的状态的集合，$V$ 是所有可能的观测的集合，</p>
<ul>
<li>状态序列：$O_t\in Q=\{q_1,q_2,\dots,q_N\}$</li>
<li>观测序列：$I_t\in V=\{v_1,v_2,\dots,v_M\}$</li>
</ul>
<p>其中，$N$ 是可能的状态数，$M$ 是可能的观测数。</p>
<p>隐马尔可夫模型可用三元符号表示，即 $\lambda=(A, B, \Pi)$，</p>
<ul>
<li>$A$ —状态转移概率矩阵：$A=[a_{ij}]_{N\times N}, a_{ij}=P(I_{t+1}=q_j|I_t=q_i)$</li>
<li>$B$—观测概率矩阵：$B=[b_j(k)]_{N\times M},b_j(k)=P(O_t=v_k|I_t=q_j)$</li>
<li>$\Pi$—初始状态概率矩阵：$\Pi=(\pi_i)_{1\times N},\pi_i=P(I_1=q_i)$</li>
</ul>
<p>隐马尔可夫模型有三个基本问题：</p>
<ol>
<li><strong>概率计算问题</strong>：给定模型 $\lambda=(A,B,\Pi)$ 和观测序列 $O=(o_1,o_2,\dots,o_T)$，计算在模型 $\lambda$ 下观测序列 $O$ 出现的概率 $P(O|\lambda)$。</li>
<li><strong>学习问题</strong>：已知观测序列 $O=(o_1,o_2,\dots,o_T)$，估计模型 $\lambda=(A,B,\Pi)$ 参数，使得在该模型下观测序列概率 $P(O|\lambda)$ 最大。即用极大似然估计的方法估计参数。</li>
<li><strong>预测问题</strong>：也成为解码问题。已知模型 $\lambda=(A,B,\Pi)$ 和观测序列 $O=(o_1,o_2,\dots,o_T)$，求对给定观测序列条件概率 $P(I|O)$ 最大的状态序列 $I=(i_1,i_2,\dots,i_T)$。</li>
</ol>
<p>第一个问题对应的算法是前向—后向算法（Forward-Backward algorithm），第二个则是模型训练问题，第三个问题可用维特比算法解决。</p>
<h3 id="推理（概率计算）问题"><a href="#推理（概率计算）问题" class="headerlink" title="推理（概率计算）问题"></a>推理（概率计算）问题</h3><p>已知：模型 $\lambda=(A,B,\Pi)$ 和观测序列 $O=(o_1,o_2,\dots,o_T)$，求：$P(O|\lambda)$。</p>
<h4 id="1-直接计算法"><a href="#1-直接计算法" class="headerlink" title="1.直接计算法"></a>1.直接计算法</h4><p>通过列举所有可能的长度为 $T$ 的状态序列 $I=(i_1,i_2,\dots,i_T)$，求各个状态序列 $I$ 与观测序列 $O=(o_1,o_2,\dots,o_T)$ 的联合概率 $P(O,I|\lambda)$，然后对所有可能的状态序列求和，得到 $P(O|\lambda)$。</p>
<script type="math/tex; mode=display">
\begin{align*}
P(O)&=P(O_1,O_2,\dots,O_T) \\
&=\sum_I P(O,I)=\sum_I \left[P(O|I)P(I)\right]\\
&=\sum_I \left[P(O_1,O_2,\dots,O_T|I_1,I_2,\dots,I_T)P(I_1,I_2,\dots,I_T)\right]\\
&=\sum_I \left[P(O_1|I_1)\times P(O_2|I_2)\times \dots \times P(O_T|I_T)\times P(I_1)\times P(I_2|I_1)\times \dots\times P(I_T|I_{T-1})\right]\\
&= \sum_{I_1,\dots,I_T}\left[\left(\prod_{t=1}^TP(O_t|I_t)\right)\times\left(\prod_{t=1}^{T-1}P(I_{t+1}|I_t)\right)\times P(I_1)\right]\\
&=\sum_{I_1}\sum_{I_2}\sum_{I_3}\sum_{I_4}\dots\sum_{I_T}\left[\left(\prod_{t=1}^TP(O_t|I_t)\right)\times\left(\prod_{t=1}^{T-1}P(I_{t+1}|I_t)\right)\times P(I_1)\right]
\end{align*}</script><p>稍微分析一下就可以发现，对于某个长度为 $T$ 的状态序列，求和需要花费 $O(T)$ 时间，由于状态序列共有 $N^T$ 种，故直接计算的算法时间复杂度为 $O(TN^T)$。对于稍长的马尔可夫链来说，其联合分布的计算时间是难以忍受的。</p>
<h4 id="2-前向算法"><a href="#2-前向算法" class="headerlink" title="2.前向算法"></a>2.前向算法</h4><p>直接计算法通过枚举所有可能的状态序列来求解概率，由于每次计算新状态序列对应的概率时，会重复计算每个求和号中的结果，所以直接计算法存在大量重复的运算。</p>
<p>考虑一般的多级求和问题的求解：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^N\sum_{j=1}^N\sum_{k=1}^Ni\times j\times k=\sum_{i=1}^N\left(i\sum_{j=1}^N\left(j\sum_{k=1}^Nk\right)\right)</script><script type="math/tex; mode=display">
\begin{align*}
&\sum_{i=1}^N\sum_{j=1}^N\sum_{k=1}^Nf_0(i)\times f_1(i,j)\times f_2(j)\times f_3(j,k)\times f_4(k)\\
=&\sum_{k=1}^Nf_4(k)\times \left(\sum_{j=1}^Nf_3(j,k)\times f_2(j)\times\left(\sum_{i=1}^Nf_0(i)\times f_1(i,j)\right)\right)
\end{align*}</script><p>每个靠外的求和问题都依赖于内部求和问题的求解。故每次求解时，可以保存子问题的求解结果，避免重复计算。</p>
<p>假设现在只有一个观测：</p>
<p><img src="http://image.rexking6.top/img/clip1554723931.png" alt=""></p>
<script type="math/tex; mode=display">
\begin{align*}
P(O)&=P(o_1)\\
&=\sum_{I_1}P(O_1,I_1)\\
&=\sum_{I_1}P(O_1|I_1)P(I_1)\\
&=\sum_{i=1}^N P(O_1=o_1|I_1=i)P(I_1=i)\\
&=\sum_{i=1}^N \alpha_1(i)
\end{align*}</script><p>两个观测：</p>
<p><img src="http://image.rexking6.top/img/clip1554724085.png" alt=""></p>
<script type="math/tex; mode=display">
\begin{align*}
P(O)&=P(o_1,o_2)=\sum_{I_2}\sum_{I_1}P(O_1,O_2,I_1,I_2)\\
&=\sum_{I_2}\sum_{I_1}P(O_2|I_2)P(I_2|I_1)P(O_1|I_1)P(I_1)\\
&=\sum_{I_2}\left(P(O_2|I_2)\sum_{I_1}P(I_2|I_1)P(O_1|I_1)P(I_1)\right)\\
&=\sum_{I_2}\left(P(O_2|I_2)\sum_{i=1}^NP(I_2|I_1=i)\alpha_1(i)\right)\\
&=\sum_{j=1}^N\left(P(O_2=o_2|I_2=j)\sum_{i=1}^NP(I_2=j|I_1=i)\alpha_1(i)\right)\\
&=\sum_{j=1}^N\alpha_2(j)
\end{align*}</script><p>三个观测：</p>
<p><img src="http://image.rexking6.top/img/clip1554772598.png" alt=""></p>
<script type="math/tex; mode=display">
\begin{align*}
P(O)&=P(o_1,o_2,o_3)=\sum_{I_3}\sum_{I_2}\sum_{I_1}P(O_1,O_2,O_3,I_1,I_2,I_3)\\
&=\sum_{I_3}\sum_{I_2}\sum_{I_1}P(O_3|I_3)P(I_3|I_2)P(O_2|I_2)P(I_2|I_1)P(O_1|I_1)P(I_1)\\
&=\sum_{I_3}P(O_3|I_3)\left(\sum_{I_2}P(I_3|I_2)P(O_2|I_2)\left(\sum_{I_1}P(I_2|I_1)P(O_1|I_1)P(I_1)\right)\right)\\
&=\sum_{I_3}P(O_3|I_3)\left(\sum_{i=1}^NP(I_3|I_2=i)\alpha_2(i)\right)\\
&=\sum_{j=1}^NP(O_3=o_3|I_3=j)\left(\sum_{i=1}^NP(I_3=j|I_2=i)\alpha_2(i)\right)\\
&=\sum_{j=1}^N\alpha_3(j)
\end{align*}</script><p>总结规律，得：</p>
<script type="math/tex; mode=display">
\begin{align*}
\alpha_1(j)&=P(O_1=o_1|I_1=j)P(I_1=j)\\
\alpha_2(j)&=P(O_2=O_2|I_2=j)\left(\sum_{i=1}^NP(I_2=j|I_1=i)\alpha_1(i)\right)\\
\alpha_3(j)&=P(O_3=o_3|I_3=j)\left(\sum_{i=1}^NP(I_3=j|I_2=i)\alpha_2(i)\right)\\
\dots\\
\alpha_{t+1}(j)&=P(O_{t+1}=o_{t+1}|I_{t+1}=j)\sum_{i=1}^NP(I_{t+1}=j|I_t=i)\alpha_t(i)\\
\alpha_{t+1}(j)&=\left(\sum_{i=1}^N\alpha_t(i)a_{ij}\right)b_j(o_{t+1})
\end{align*}</script><p>有了上述推导之后，再来看概率计算问题：</p>
<p><img src="http://image.rexking6.top/img/clip1554773628.png" alt=""></p>
<p>对于原本时间复杂度很高的问题，可通过变量消除法来解决，首选计算出 $\alpha_1(i_1)$，消去 $I_1$，然后据此可得到 $\alpha_2(i_2)$，依次类推，从内到外，依次消除变量。</p>
<p><strong>本质：sum-product过程</strong></p>
<p><img src="http://image.rexking6.top/img/clip1554773936.png" alt=""></p>
<p>在 $t+1$ 时刻，状态取值为 $j$ 的概率 $\alpha_{t+1}(j)$ 等于在 $t$ 时刻状态取值为 $i$ 的概率 $\alpha_t(i)$ 乘以从状态 $i$ 转移到状态 $j$ 的概率 $a_{ij}$，因为在 $t$ 时刻状态有 $N$ 种可能，因此对所有状态求和（sum），然后乘以在 $t+1$ 时刻，状态为 $j$ 时产生观测 $o_{t+1}$ 的概率 $b_j(o_{t+1})$（product）。</p>
<p><strong>从概率的角度看待前向算法</strong></p>
<script type="math/tex; mode=display">
\begin{align*}
\alpha_t(i)&=P(o_1,o_2,\dots,o_t,I_t=i)\\
\alpha_{t+1}(j)&=P(o_1,o_2,\dots,o_t,o_{t+1},I_{t+1}=j)\\
&=\sum_iP(o_1,o_2,\dots,o_t,I_t=i,o_{t+1},I_{t+1}=j)\\
&=\sum_i\left(P(o_1,o_2,\dots,o_t,I_t=i)\times P(I_{t+1}=j|o_1,o_2,\dots,o_t,I_t=i)\\\times 
P(o_{t+1}|o_1,o_2,\dots,o_t,I_t=i,I_{t+1}=j)\right)\\
&=\sum_{i}\left(\alpha_t(i)P(I_{t+1}=j|I_t=i)P(o_{t+1}|I_{t+1}=j)\right)\\
&=\left(\sum_i\alpha_t(i)a_{ij}\right)\times b_j(o_{t+1})
\end{align*}</script><p>公式第一行通过增加一个 $t$ 时刻的状态 $I_t=i$，在对 $i$ 求和与原式等价，并在第二行使用贝叶斯公式展开第一项变为前向概率，后续推导继续使用贝叶斯公式化简。值得注意的是，由于 $t+1$ 时刻的观测 $o_{t+1}$ 与前面的观测 $o_1\sim o_t$ 以及 $t$ 时刻的状态 $I_t=i$ 并没有关系，故后一项条件概率可化简为第三行的形式。</p>
<p>有了前面的分析，观测序列概率的前向算法如下：</p>
<p><img src="http://image.rexking6.top/img/clip1554777309.png" alt=""></p>
<p><strong>一道例题</strong></p>
<p>考虑盒子和球模型 $\lambda=(A,B,\Pi)$，状态集合 $Q=\{1,2,3\}$，观测集合 $V=\{$红, 白$\}$，</p>
<script type="math/tex; mode=display">
A=\left[\begin{aligned}&0.5&0.2&&0.3\\&0.3&0.5&&0.2\\&0.2 &0.3&&0.5\end{aligned}\right],B=\left[\begin{aligned}&0.5&0.5\\&0.4&0.6\\&0.7 &0.3\end{aligned}\right], \pi=(0.2\ \ 0.4\ \ 0.4)</script><p>设 $T=3$，$X=($红, 白, 红$)$，使用前向算法计算 $P(X|\lambda)$。</p>
<ol>
<li><p>初始值</p>
<p>第一观测 $x_1=$红，则计算出这种观测来自的盒子的概率分布为：</p>
<script type="math/tex; mode=display">
\begin{align*}
\alpha_1(Y_1)&=\pi b_1(x_1=红)\\
&=(0.2\ 0.4\ 0.4)·(0.5\ 0.4\ 0.7)\\
&=(0.1\ 0.16\ 0.28)
\end{align*}</script></li>
<li><p>递推</p>
<p>由前向公式向前递推计算到 $T=3$ 时的前向概率</p>
<script type="math/tex; mode=display">
\begin{align*}
\alpha_2(Y_2)&=b_2(x_2=白)\sum_{y_1}\alpha_1(Y_1)a_{y_1y_2}\\
&=(0.5\ 0.6\ 0.3)·\left(\begin{aligned}0.1\times 0.5+0.16\times0.3+0.28\times0.2\\0.1\times 0.2+0.16\times0.5+0.28\times0.3\\0.1\times 0.3+0.16\times0.2+0.28\times0.5\end{aligned}\right)^T\\
&=(0.5\ 0.6\ 0.3)·\left(\begin{aligned}0.154\\0.184\\0.202\end{aligned}\right)^T\\
&=(0.077\ 0.1104\ 0.0606)
\end{align*}</script></li>
</ol>
<p>​    进一步计算第三时刻的前向概率：</p>
<script type="math/tex; mode=display">
\begin{align*}
\alpha_3(Y_3)&=b_3(x_3=红)\sum_{y_2}\alpha_2(Y_2)a_{y_2y_3}\\
&=(0.5\ 0.4\ 0.7)·\left(\begin{aligned}0.077\times 0.5+0.1104\times0.3+0.0606\times0.2\\0.077\times 0.2+0.1104\times0.5+0.0606\times0.3\\0.077\times 0.3+0.1104\times0.2+0.0606\times0.5\end{aligned}\right)^T\\
&=(0.5\ 0.4\ 0.7)·\left(\begin{aligned}0.08374\\0.08878\\0.07548\end{aligned}\right)^T\\
&=(0.04187\ 0.035512\ 0.052836)
\end{align*}</script><ol>
<li><p>停止</p>
<p>计算得到边缘分布为：</p>
<script type="math/tex; mode=display">
P(x_1,x_2,x_3;\lambda)=\sum_{y_3}\alpha_3(x_3)=0.130218</script></li>
</ol>
<h4 id="3-后向算法"><a href="#3-后向算法" class="headerlink" title="3.后向算法"></a>3.后向算法</h4><p>有前向算法就有后向算法。后向算法通过从后往前逆向计算“状态路径的最优结构”实现边缘分布的求解如下图所示。</p>
<p><img src="http://image.rexking6.top/img/clip1554790834.png" alt=""></p>
<script type="math/tex; mode=display">
\begin{align*}
P(O)&=P(O_1,O_2,\dots,O_T)\\
&=\sum_IP(O_1,O_2,\dots,O_T,I_1,I_2,\dots,I_T)\\
&=\sum_{I_1,\dots,I_T}P(I_1)P(O_1|I_1)P(I_2|I_1)P(O_2|I_2)\dots P(I_T|I_{T-1})P(O_T|I_T)\\
&=\sum_{I_1}P(I_1)P(O_1|I_1)\left(\sum_{I_2}P(I_2|I_1)P(O_2|I_2)\dots\left(\sum_{I_T}P(I_T|I_{T-1})P(O_T|I_T)1\right)\right)\\
&=\sum_{I_1}P(I_1)P(O_1|I_1)\beta_1(I_1)\\
&=\sum_{i=1}^N\pi_ib_i(o_1)\beta_1(i)
\end{align*}</script><p>递推公式为：</p>
<script type="math/tex; mode=display">
\begin{align*}
\beta_t(i)&=\sum_{j=1}^NP(I_{t+1}+j|I_t=i)P(O_{t+1}=o_{t+1}|I_{t+1}=j)\beta_{t+1}(I_{t+1}=j)\\
&=\sum_{j=1}^Na_{ij}b_j(o_{t+1})\beta_{t+1}(j)
\end{align*}</script><p>其中，$i=1,2,\dots,N, t=T-1,T-2,\dots,1$ 。</p>
<h4 id="4-前向-后向"><a href="#4-前向-后向" class="headerlink" title="4.前向-后向"></a>4.前向-后向</h4><script type="math/tex; mode=display">
\begin{align*}
P(O|\lambda)&=\sum_{i=1}^N\sum_{j=1}^NP(o_1,\dots,o_t,I_t=i,I_{t+1}=j,o_{t+1},\dots,o_T)\\
&=\sum_{i=1}^N\sum_{j=1}^NP(o_1,\dots,o_t,I_t=i)\times P(I_{t+1}=j,o_{t+1},\dots,o_T|o_1,\dots,o_t,I_t=i)\\
&=\sum_{i=1}^N\sum_{j=1}^N\alpha_t(i)\times P(I_{t+1}=j,o_{t+1},\dots,o_T|I_t=i)\\
&=\sum_{i=1}^N\sum_{j=1}^N\alpha_t(i)\times P(I_{t+1}=j|I_t=i)\times P(o_{t+1},\dots,o_T|I_t=i,I_{t+1}=j)\\
&=\sum_{i=1}^N\sum_{j=1}^N\alpha_t(i)\times a_{ij}\times P(o_{t+1},o_{t+2},\dots,o_T|I_{t+1}=j)\\
&=\sum_{i=1}^N\sum_{j=1}^N\alpha_t(i)\times a_{ij}\times P(o_{t+1}|I_{t+1}=j)\times P(o_{t+2},\dots,o_T|I_{t+1}=j,o_{t+1})\\
&=\sum_{i=1}^N\sum_{j=1}^N\alpha_t(i)\times a_{ij}\times b_j(o_{t+1})\times\beta_{t+1}(j),\ t=1,2,\dots,T-1\\
&=\sum_{i=1}^N\sum_{j=1}^N\alpha_t(i)\times a_{ij}\times b_j(o_{t+1})\times\beta_{t+1}(j)\\
&=\sum_{j=1}^N\left(\sum_{i=1}^N\alpha_t(i)\times a_{ij} \times b_j(o_{t+1})\right)\times \beta_{t+1}(j)\\
&=\sum_{j=1}^N \alpha_{t+1}(j)\times\beta_{t+1}(j)=\sum_{i=1}^N\alpha_t(i)\times \beta_t(i)
\end{align*}</script><ul>
<li><p>当 $t=T-1$ 时，</p>
<script type="math/tex; mode=display">
P(O|\lambda)=\sum_{j=1}^N\alpha_{t+1}(j)\times\beta_{t+1}(j)=\sum_{j=1}^N \alpha_T(j)\times \beta_T(j)=\sum_{i=1}^N \alpha_T(i)</script></li>
<li><p>当 $t=1$ 时，</p>
<script type="math/tex; mode=display">
P(O|\lambda)=\sum_{i=1}^N\alpha_t(i)\times\beta_t(i)=\sum_{i=1}^N\alpha_1(i)\times\beta_1(i)=\sum_{i=1}^N\pi_ib_1(o_1)\times\beta_1(i)</script></li>
</ul>
<p><strong>另外几个重要的量</strong></p>
<ul>
<li>$\gamma_t(i)=P(i_t=i|O,\lambda)=\frac{P(i_t=i,O|\lambda)}{P(O|\lambda)}=\frac{\alpha_t(i)\beta_t(i)}{\sum_{j=1}^N\alpha_t(j)\times\beta_t(j)}$</li>
<li>$\xi_t(i,j)=P(i_t=i,i_{t+1}=j|O,\lambda)=\frac{P(i_t=i,i_{t+1}=j,O|\lambda)}{P(O|\lambda)}=\frac{\alpha_t(i)a_{ij}b_j(o_{t+1})\beta_{t+1}(j)}{\sum_{i=1}^N\sum_{j=1}^N\alpha_t(i)a_{ij}b_j(o_{t+1})\beta_{t+1}(j)}$</li>
<li>$\gamma_t(i)=P(i_t=i|O,\lambda)=\sum_jP(i_t=i,i_{t+1}=j|O,\lambda)=\sum_j\xi_t(i,j)$</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li><p>在观测 $O$ 下，状态 $i$ 出现的期望值</p>
<script type="math/tex; mode=display">
\sum_{t=1}^T\gamma_t(i)</script></li>
<li><p>在观测 $O$ 下，由状态 $i$ 转移的期望值</p>
<script type="math/tex; mode=display">
\sum_{t=1}^{T-1}\gamma_t(i)</script></li>
<li><p>在观测 $O$ 下，由状态 $i$ 转移到状态 $j$ 的期望值</p>
<script type="math/tex; mode=display">
\sum_{t=1}^{T-1}\xi_t(i,j)</script></li>
</ul>
<h3 id="预测（解码）问题"><a href="#预测（解码）问题" class="headerlink" title="预测（解码）问题"></a>预测（解码）问题</h3><p>已知：模型 $\lambda=(A,B,\Pi)$ 和观测序列 $O=(o_1,o_2,\dots,o_T)$，求：$I^\ast=\text{arg max}_IP(I|O,\lambda)$。</p>
<script type="math/tex; mode=display">
I^\ast=\text{arg max}_I P(I|O,\lambda)=\text{arg max}_I \frac{P(I|\lambda)P(O|I,\lambda)}{P(O|\lambda)}=\text{arg max}_IP(I|\lambda)P(O|I,\lambda)</script><h4 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h4><script type="math/tex; mode=display">
\gamma_t(i)=P(i_t=i|O,\lambda)=\frac{\alpha_t(i)\beta_t(i)}{\sum_{j=1}^N\alpha_t(j)\times\beta_t(j)}\\
i_t^\ast=\text{arg max}_{1\le i\le N}[\gamma_t(i)],\ t=1,2,\dots,T</script><p>这存在两个问题：</p>
<ol>
<li><p>不能保证整体最优；</p>
</li>
<li><p>存在 $a_{ij}=0$ 的状态。</p>
</li>
</ol>
<h4 id="Viterbi算法"><a href="#Viterbi算法" class="headerlink" title="Viterbi算法"></a>Viterbi算法</h4><ul>
<li>假设现在只有一个观测：</li>
</ul>
<p><img src="http://image.rexking6.top/img/clip1554796776.png" alt=""></p>
<script type="math/tex; mode=display">
\begin{align*}
&\text{max}_{i\in\{1,2,\dots,N\}}P(I_1=i)\times P(O_1|I_1=i)\\
=&\text{max}_{i\in\{1,2,\dots,N\}}\delta_1(i)\\
=&\text{max}_{i\in\{1,2,\dots,N\}}\pi_ib_i(o_1)
\end{align*}</script><ul>
<li><p>两个观测：</p>
<p><img src="http://image.rexking6.top/img/clip1554796930.png" alt=""></p>
<script type="math/tex; mode=display">
\begin{align*}
&\text{max}_{I_2}\text{max}_{I_1}P(I_1)\times P(O_1|I_1)\times P(I_2|I_1)\times P(O_2|I_2)\\
=&\text{max}_{I_2}\left\{\text{max}_{I_1}\{P(I_1)\times P(O_1|I_1)\}\times P(I_2|I_1)\times P(O_2|I_2)\right\}\\
=&\text{max}_{I_2}\left\{\left[\text{max}_{I_1}\delta_1(i)\times P(I_2|I_1=i)\right]\times P(O_2|I_2)\right\}\\
=&\text{max}_{j\in\{1,2,\dots,N\}}\left\{\left[\text{max}_{I_1}\delta_1(i)\times P(I_2=j|I_1=i)\right]\times P(O_2=o_2|I_2=j)\right\}\\
=&\text{max}_{j\in\{1,2,\dots,N\}}\delta_2(j)
\end{align*}</script><script type="math/tex; mode=display">
\delta_2(j)=\text{max}_{i\in\{1,2,\dots,N\}}[\delta_1(i)a_{ij}]\times b_j(o_2)</script></li>
<li><p>三个观测：</p>
<p><img src="http://image.rexking6.top/img/clip1554798645.png" alt=""></p>
</li>
</ul>
<script type="math/tex; mode=display">
  \delta_3(j)=\text{max}_{i\in\{1,2,\dots,N\}}[\delta_2(i)a_{ij}]\times b_j(o_3)</script><p>总的算法流程如下：</p>
<p><img src="http://image.rexking6.top/img/clip1559629894.png" alt=""></p>
<h3 id="参数学习问题"><a href="#参数学习问题" class="headerlink" title="参数学习问题"></a>参数学习问题</h3><p>已知：观测序列 $O=(o_1,o_2,\dots,o_T)$，求：模型 $\lambda=(A,B,\Pi)$。</p>
<p>根据一系列状态变量和观测变量的样本，求解HMM三要素。该问题可分为有监督学习和无监督学习。无监督学习需要使用EM算法求解，在之后的贝叶斯学习会涉及。下面是有监督学习问题的求解。</p>
<p>有监督学习，即观测序列和对应的状态序列已知。求解有监督学习问题常使用极大似然估计，该方法认为出现的观测往往对应着较高的概率，通过解析地表示出概率（似然函数），优化似然函数就可求得我们想要的某些概率。$D=\{(O^s, I^s\}_{s=1}^S,\lambda=(A,B,\pi)$，推导如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
L(D;\lambda)&=\text{ln}\prod_{s=1}^Sp(O^s,I^s)=\sum_{s=1}^S\text{ln}p(O^s,I^s)\\
&=\sum_{s=1}^S \text{ln}\left(\left(\prod_{t=1}^{T_s}p(O_t^s|I_t^s)\right)\times\left(\prod_{t=1}^{T_s-1}p(I_{t+1}^s|I_t^s)\right)\times p(I_1^s)\right)\\
&=\sum_{s=1}^S\sum_{t=1}^{T_s}\text{ln}p(O_t^s|I_t^s)+\sum_{s=1}^S\sum_{t=1}^{T_s-1}\text{ln}p(I_{t+1}^s|I_t^s)+\sum_{s=1}^S\text{ln}(p(I_1^s))\\
&=\sum_{s=1}^S\sum_{t=1}^{T_s}\sum_{j=1}^N\sum_{k=1}^M1\{I_t^s=j\wedge O_t^s=k\}\text{ln}b_{jk}+\sum_{s=1}^S\sum_{t=1}^{T_s-1}\sum_{i=1}^N\sum_{j=1}^N1\{I_t^s=i\wedge I_{t+1}^s=j\}\text{ln}a_{ij}\\&+\sum_{s=1}^S\sum_{i=1}^N1\{I_1^s=i\}\text{ln}(\pi_i)
\end{align*}</script><p>上式为学习问题对应地似然函数，分为三部分，分别对应HMM中的三个参数。</p>
<p>对初始概率，可求得使似然函数最大的概率值（由上式第三项加上初始概率和为1的约束形成的拉格朗日函数）：</p>
<script type="math/tex; mode=display">
L(\pi,\alpha)=\sum_{s=1}^S\sum_{i=1}^N1\{I_t^s=i\}\text{ln}(\pi_i)+\alpha\left(1-\sum_{i=1}^N\pi_i\right)</script><p>对 $\pi_i$ 求偏导得：</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial \pi_i}=\frac{1}{\pi_i}\sum_{s=1}^S1\{I_t^s=i\}-\alpha=0\Rightarrow\pi_i=\frac{\sum_{s=1}^S1\{I_t^s=i\}}{\alpha}</script><p>约束为：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^N\pi_i=1 \Rightarrow\sum_{i=1}^N\left(\frac{\sum_{s=1}^S1\{I_t^s=i\}}{\alpha}\right)=\frac{\sum_{i=1}^N\sum_{s=1}^S1\{I_t^s=i\}}{\alpha}=1\Rightarrow\alpha=\sum_{i=1}^N\sum_{s=1}^S1\{I_t^s=i\}=S</script><p>所以，</p>
<script type="math/tex; mode=display">
\pi_i=\frac{\sum_{s=1}^S1\{I_1^s=i\}}{S}</script><p>直观来看，初始概率及统计初始状态中各个状态出现的频率。</p>
<p>同理，可推导转移概率矩阵得学习公式：</p>
<script type="math/tex; mode=display">
L(A,\beta)=\sum_{s=1}^S\sum_{t=1}^{T_s}\sum_{i=1}^N\sum_{i=1}^N1\{I_t^s=i\wedge I_{t+1}^s=j\}\text{ln}a_{ij}+\beta\left(1-\sum_{j=1}^Na_{ij}\right)</script><p>对 $a_{ij}$ 求偏导得：</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial a_{ij}}=\sum_{s=1}^S\sum_{t=1}^{T_s}\frac{1\{I_t^s=1\wedge I_{t+1}^s=j\}}{a_{ij}}-\beta=0\Rightarrow a_{ij}=\frac{\sum_{s=1}^S\sum_{t=1}^{T_s-1}1\{I_t^s=1\wedge I_{t+1}^s=j\}}{\beta}</script><p>约束为：</p>
<script type="math/tex; mode=display">
\sum_{j=1}^Na_{ij}=1\Rightarrow\frac{\sum_{j=1}^N\sum_{s=1}^S\sum_{t=1}^{T_s-1}1\{I_t^s=i\wedge I_{t+1}^s=j\}}{\beta}=1</script><p>则，</p>
<script type="math/tex; mode=display">
\beta=\sum_{j=1}^N\sum_{s=1}^S\sum_{t=1}^{T_s-1}1\{I_t^s=i\wedge I_{t+1}^s=j\}=\sum_{s=1}^S\sum_{t=1}^{T_s-1}1\{I_t^s=i\}</script><p>代入，</p>
<script type="math/tex; mode=display">
a_{ij}=\frac{\sum_{s=1}^S\sum_{t=1}^{T_s-1}1\{I_t^s=i\wedge I_{t+1}^s=j\}}{\sum_{s=1}^S\sum_{t=1}^{T_s-1}1\{I_t^s=i\}}</script><p>直观解释就是，根据样本中不同状态之间的转移数目，计算某两个状态转移的频率，将其作为概率。</p>
<p>观测概率的学习公式为：</p>
<script type="math/tex; mode=display">
L(B,\gamma)=\sum_{s=1}^S\sum_{t=1}^{T_s}\sum_{i=1}^N\sum_{k=1}^M1\{I_t^s=j\wedge O_t^s=k\}\text{ln}b_{jk}+\gamma(1-\sum_{k=1}^Mb_{jk})</script><p>对 $b_{jk}$ 求偏导得：</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial b_{jk}}=\sum_{s=1}^S\sum_{t=1}^{T_s}\frac{1\{I_t^s=j\wedge O_t^s=k\}}{b_{jk}}-\gamma=0\Rightarrow b_{jk}=\frac{\sum_{s=1}^S\sum_{t=1}^{T_s}1\{I_t^s=j\wedge O_t^s=k\}}{\gamma}</script><p>约束为：</p>
<script type="math/tex; mode=display">
\sum_{k=1}^Mb_{jk}=1\Rightarrow\frac{\sum_{k=1}^M\sum_{s=1}^S\sum_{t=1}^{T_s}1\{I_t^s=j\wedge O_t^s=k\}}{\gamma}=1</script><p>则，</p>
<script type="math/tex; mode=display">
\gamma=\sum_{k=1}^M\sum_{s=1}^S\sum_{t=1}^{T_s}1\{I_t^s=j\wedge O_t^s=k\}=\sum_{s=1}^S\sum_{t=1}^{T_s}1\{I_t^s=j\}</script><p>代入，</p>
<script type="math/tex; mode=display">
b_{jk}=\frac{\sum_{s=1}^S\sum_{t=1}^{T_s}1\{I_t^s=j\wedge O_t^s=k\}}{\sum_{s=1}^S\sum_{t=1}^{T_s}1\{I_t^s=j\}}</script><p>相似地，这可以被简单地归纳为统计频率的问题。这也比较符合通过频率逼近概率的思想。</p>
<h1 id="贝叶斯学习"><a href="#贝叶斯学习" class="headerlink" title="贝叶斯学习"></a>贝叶斯学习</h1><p>最大似然估计将待估计的参数看作是确定性的量，只是其值我们暂时还不知道；而贝叶斯估计则将待估计的参数看成是符合某种先验概率分布的随机变量。对样本进行观测的过程，就是把先验概率密度转化为后验概率密度，这样就利用样本的信息修正了对参数的初始估计值。这个过程也可以看成是贝叶斯学习的过程。</p>
<h2 id="MLE"><a href="#MLE" class="headerlink" title="MLE"></a>MLE</h2><p>最大似然估计，用于估计模型参数。似然函数取最大时的参数值作为估计值。估计过程如下：</p>
<ol>
<li><p>假设有一批数据 $X$，且 $x$ 均服从某种参数为 $\theta$ 的分布：</p>
<script type="math/tex; mode=display">
X=\{x_1,x_2,\dots,x_n\},\ x\sim P_\theta, p_\theta(x)=p(x|\theta)</script></li>
<li><p>因为 $x$ 服从独立同分布，参数向量 $\theta$ 的MLE就是使 $P(X|\theta)$ 达到最大值的那个参数向量：</p>
<script type="math/tex; mode=display">
p(X|\theta)=\prod_{x\in X}p(X=x|\theta)=\prod_{i=1}^n p(x_{i}|\theta)</script></li>
<li><p>取对数：</p>
<script type="math/tex; mode=display">
L(\theta|X)\equiv\text{log}p(X|\theta)=\sum_{t=1}^n\text{log}p(x_i|\theta)</script><script type="math/tex; mode=display">
\hat \theta=\text{arg max}_\theta L(\theta|X)=\text{arg max}_\theta \sum_{t=1}^n \text{log}p(x_i|\theta)</script></li>
</ol>
<h3 id="举例：伯努利分布"><a href="#举例：伯努利分布" class="headerlink" title="举例：伯努利分布"></a>举例：伯努利分布</h3><p>以抛硬币为例，正面朝上概率为 $p$，反面为 $1-p$。</p>
<p><img src="http://image.rexking6.top/img/clip1555211920.png" alt=""></p>
<p>参数估计：</p>
<script type="math/tex; mode=display">
\begin{align*}
\theta^\ast&=\text{arg max}_\theta\sum_{t=1}^n \log p(x_i|\theta)\\
&=\text{arg max}_\theta\sum_{i=1}^n x_i\log p+(1-x_i)\log (1-p)
\end{align*}</script><p>求导：</p>
<script type="math/tex; mode=display">
L(p)=\left(\sum_{i=1}^nx_i\right)\log p+\left(\sum_{i=1}^n(1-x_i)\right)\log (1-p)\\
\frac{dL(p)}{dp}=0 \Rightarrow p=\frac{\sum_{i=1}^nx_i}{n}=\frac{\sharp head}{n}</script><p>假设抛一枚硬币 $n$ 次，其中正面朝上的次数用 $\sharp head$ 表示，求正面朝上的概率为多少？很多人都会计算：$\sharp head/n$。</p>
<p>从上面的推导也可以看到正面朝上的概率 $p$ 通过MLE方法得到的值与我们日常中估计的方法一致。</p>
<h3 id="举例：多项式分布"><a href="#举例：多项式分布" class="headerlink" title="举例：多项式分布"></a>举例：多项式分布</h3><p>以抛骰子为例，</p>
<script type="math/tex; mode=display">
x\in\{1,2,\dots,K\},\ p(x=i)=q_i,\ \sum_{i=1}^Kq_i=1</script><p>则有：</p>
<script type="math/tex; mode=display">
p(x_i)=\prod_{j=1}^K(q_j)^{1\{x_i=j\}}\\
\textbf x_i=\{0,0,0,1,0,0\}\\
p(\textbf x_i)=\prod_{j=1}^K q_j^{x_{ij}}</script><p>取对数：</p>
<script type="math/tex; mode=display">
D=\{\textbf x_1, \textbf x_2,\dots, \textbf x_n\},\\ p(D)=\prod_{i=1}^n\prod_{j=1}^K=q_j^{x_{ij}}=\prod_{j=1}^Kq_j^{\sum_i x_{ij}}=\prod_{j=1}^Kq_j^{n_j},\\
\ln p(D)=\sum_{j=1}^Kn_j\ln q_j</script><p>拉格朗日函数为：</p>
<script type="math/tex; mode=display">
L(q,\lambda)=\sum_{j=1}^Kn_j\ln q_j+\lambda(1-\sum_{j=1}^Kq_j)</script><p>求导：</p>
<script type="math/tex; mode=display">
\frac{\partial L(q,\lambda)}{\partial q_j}=\frac{n_j}{q_j}-\lambda=0\Rightarrow q_j=\frac{n_j}{\lambda},\\
\sum_{j=1}^Kq_j=1\Rightarrow \sum_{j=1}^K\frac{n_j}{\lambda}=1\Rightarrow \lambda=\sum_{j=1}^Kn_j=n,\\
q_j=\frac{n_j}{n}</script><h3 id="举例：高斯分布"><a href="#举例：高斯分布" class="headerlink" title="举例：高斯分布"></a>举例：高斯分布</h3><p>已知：$D=\{x_1,x_2,\dots,x_n\}, x\sim N(\mu,\sigma^2)$，求 $\mu$。</p>
<p>假设有一批数据 $D$，且 $x$ 服从均值为 $\mu$，方差为 $\sigma^2$ 的高斯分布。数据 $D$ 是如下图 $x$ 轴坐标所示，那么哪一个模型比较好的刻画数据 $D$ 的分布呢？</p>
<p><img src="http://image.rexking6.top/img/clip1555216724.png" alt=""></p>
<p>很显然，中间的红色的曲线比较能够豪地刻画 $D$ 的分布，下面从MLE的角度分析一下。</p>
<p>取对数：</p>
<script type="math/tex; mode=display">
\begin{align*}
\text{ln}L(D;\mu)&=\ln\prod_{i=1}^n\frac{1}{\sqrt{2\pi}\sigma}\text{exp}\left[-\frac{1}{2\sigma^2}(x_i-\mu)^2\right]\\
&=\sum_{i=1}^n\left[\ln\left(\frac{1}{\sqrt{2\pi}\sigma}\right)-\frac{1}{2\sigma^2}(x_i-\mu)^2\right]
\end{align*}</script><p>求导：</p>
<script type="math/tex; mode=display">
\frac{d}{d\mu}\ln L(D;\mu)=\frac{1}{\sigma^2}\sum_{i=1}^n(x_i-\mu)=0 \Rightarrow \mu=\frac{1}{n}\sum_{i=1}^nx_i</script><p>得到的结果为所有样本的均值，对应于上图，即高斯分布的中轴线的位置，差不多红色曲线中轴线的位置与数据均值的位置最为相近。当然，此刻得到的参数只是对于真实值的一个估计，其对于真实值的接近程度是受训练样本数量限制的。如果训练样本数量越多，那么对于参数的估计值也就越接近于真实值。</p>
<h2 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h2><p>最大后验估计。</p>
<script type="math/tex; mode=display">
\begin{align*}
\theta_{MAP}&=\text{arg max}_\theta p(\theta|X)\\
&=\text{arg max}_\theta\frac{p(X|\theta)p(\theta)}{p(X)}\\
&=\text{arg max}_\theta p(X|\theta)p(\theta)
\end{align*}\\
p_{MAP}(x|X)=p(x|\theta_{MAP})</script><p>其中 $p(\theta)$ 为参数 $\theta$ 的先验概率。即上述贝叶斯过程可以这样描述：</p>
<script type="math/tex; mode=display">
后验=\frac{样本似然\times先验}{证据}</script><p>所以，MLE可以说是当先验概率 $p(\theta)$ 为均匀分布时的MAP。</p>
<h3 id="举例：单变量高斯分布的均值"><a href="#举例：单变量高斯分布的均值" class="headerlink" title="举例：单变量高斯分布的均值"></a>举例：单变量高斯分布的均值</h3><p>简单起见，只考虑只有均值 $\mu$ 未知的情况，且参数 $\mu$ 也服从高斯分布（均值、方差已知）。</p>
<script type="math/tex; mode=display">
D=\{x_1,\dots,x_n\},\ x_i\in R,\ X\sim N(\mu,\sigma^2),\ \mu\sim N(\mu_0, 1)</script><p>采用MAP：</p>
<script type="math/tex; mode=display">
\begin{align*}
\mu_{MAP}&=\text{arg max}_\mu \text{ln}[p(D|\mu)p(\mu)]\\
&=\text{arg max}_\mu \text{ln}\left[\prod_{i=1}^n\frac{1}{\sqrt{2\pi}\sigma}\text{exp}\left(-\frac{1}{2\sigma^2}(x_i-\mu)^2\right)\right]+\text{ln}\frac{1}{\sqrt{2\pi}}\text{exp}\left(-\frac{1}{2}(\mu-\mu_0)^2\right)\\
&=\text{arg max}_\mu \left\{-\frac{1}{2\sigma^2}\sum_{i=1}^n(x_i-\mu)^2-\frac{1}{2}(\mu-\mu_0)^2\right\}\\
&=L(\mu)
\end{align*}</script><p>求导：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\frac{\partial}{\partial \mu}L(\mu)=0\Rightarrow \frac{1}{\sigma^2}\left(\sum_{i=1}^nx_i-n\mu\right)-(\mu-\mu_0)=0\\
\Rightarrow&\mu=\frac{\frac{1}{\sigma^2}\sum_{i=1}^nx_i+\mu_0}{\frac{n}{\sigma^2}+1}=\frac{n\mu_{MLE}+\sigma^2\mu_0}{n+\sigma^2}=\frac{n}{n+\sigma^2}\mu_{MLE}+\frac{\sigma^2}{n+\sigma^2}\mu_0
\end{align*}</script><p>可以看到求得的 $\mu$ 为MLE得到的 $\mu$ 以及 $\mu_0$ 的加权和，且权值之和为1。这种组合称为凸组合，当 $n$ 很大的时候，即训练样本充足，$\mu$ 的取值与 $\mu_{MLE}$ 接近，这说明此时采用极大似然估计比较可靠；反之，当 $n$ 很小时，参数原始的分布更可靠一些。</p>
<h3 id="举例：回归模型"><a href="#举例：回归模型" class="headerlink" title="举例：回归模型"></a>举例：回归模型</h3><script type="math/tex; mode=display">
D=\{\langle x_i,y_i\rangle\}_{i=1}^n,\ x_i\in\mathbb R^d,\ y_i\in \mathbb R,\ y_i=w^Tx_i+\varepsilon, \varepsilon\sim N(0,1)\\
p(y_i)\sim N(w^Tx,1),\ w\sim N(0, \lambda^{-1}I)</script><p>其中，$\varepsilon$ 服从均值为0，方差为1的高斯分布，则 $p(y)$ 服从均值为 $w^Tx_i$，方差为1的高斯分布，且参数 $w$ 也服从一个高斯分布。</p>
<p>取对数：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\text{ln}p(D|w)=\text{ln}\prod_{i=1}^np(y_i)=\sum_{i=1}^n\left[\left(\text{ln}\frac{1}{\sqrt{2\pi}}\right)-\frac{1}{2}(y_i-w^Tx_i)^2\right]\\
&\text{ln}p(w)=-\frac{d}{2}\text{ln}(2\pi)+\frac{1}{2}\text{ln}\lambda-\frac{\lambda}{2}w^Tw\end{align*}</script><p>求导：</p>
<script type="math/tex; mode=display">
W_{MAP}=\text{arg max}_w[\text{ln}p(D|w)+\text{ln}p(w)]\propto w^TX^TXw-2w^TX^Ty+\lambda w^Tw\\
\Rightarrow X^TXw-X^Ty+\lambda w=0\Rightarrow w=(X^TX+\lambda I)^{-1}X^Ty</script><p>可以看到整个优化过程，从贝叶斯的角度来看是一种贝叶斯最大后验估计，正则化项变成了一种先验信息。</p>
<h2 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h2><p>在贝叶斯学习方法中，我们把参数向量 $\theta$ 本身看成时一个随机变量，已有的训练样本使我们能够对于 $\theta$ 的初始的密度估计转化为后验概率密度。</p>
<script type="math/tex; mode=display">
p(\theta|X)=\frac{p(X|\theta)p(\theta)}{p(X)}=\frac{p(X|\theta)p(\theta)}{\int p(X|\theta')p(\theta')d\theta'}</script><ul>
<li>先验信息：看到样本前关于参数的信息；</li>
<li>样本似然：当分布的参数确定下来后，看到这些样本的可能性。</li>
</ul>
<p>用概率图模型表示：</p>
<p><img src="http://image.rexking6.top/img/clip1555223520.png" alt=""></p>
<p>已知一组训练数据 $X$，这些样本都是从固定但未知的概率密度函数 $p(\theta)$ 中独立抽取的，要求根据这些样本估计 $p(x,X,\theta)$ ，这就是贝叶斯学习的核心问题。</p>
<p>问题也可以看成，用已知的训练集来预测未知的测试集，模型参数只是一个中间变量，即</p>
<script type="math/tex; mode=display">
\begin{align*}
p(x|X)&=\frac{p(x,X)}{p(X)}=\frac{\int_\theta p(x,X,\theta)d\theta}{p(X)}\\
&=\frac{\int_\theta p(\theta)p(X|\theta)p(x|\theta)d\theta}{p(X)}\\
&=\int_\theta p(\theta|X)p(x|\theta)d\theta
\end{align*}</script><p>其中，$p(\theta|X)=\frac{p(\theta)p(X|\theta)}{p(X)}$，而贝叶斯估计的方法是：</p>
<script type="math/tex; mode=display">
\theta_{Bayes}=E[\theta|X]=\int\theta p(\theta|X)d\theta.</script><p>由此也可以看出贝叶斯估计的优点：</p>
<ul>
<li>贝叶斯推理需要一个先验假设；</li>
<li>最小化期望损失：多参数求平均；</li>
<li>方便进行模型选择；</li>
<li>避免过度拟合。</li>
</ul>
<p>和缺点：</p>
<ul>
<li>必须有一个先验假设；</li>
<li>准确计算非常困难。</li>
</ul>
<p>三者的关系如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">MLE</th>
<th style="text-align:center">MAP</th>
<th style="text-align:center">Bayesian</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\theta_{MLE}=\text{arg max}_{\theta}p(X</td>
<td style="text-align:center">\theta)$</td>
<td style="text-align:center">$\theta_{MAP}=\text{arg max}_\theta p(X</td>
<td>\theta)p(\theta)$</td>
<td>$\theta_{Bayes}=E[\theta</td>
<td>X]=\int \theta p(\theta</td>
<td>X)d\theta$</td>
</tr>
</tbody>
</table>
</div>
<p>由MLE可以计算MAP，由MAP可以进行贝叶斯估计，MAP可以看成是贝叶斯估计中参数最大值时的一个特例，贝叶斯估计则考虑了参数取值的所有情况，换句话说，在进行贝叶斯估计的时候就进行了模型选择。</p>
<h3 id="举例：估计分布的参数：离散变量（多值）"><a href="#举例：估计分布的参数：离散变量（多值）" class="headerlink" title="举例：估计分布的参数：离散变量（多值）"></a>举例：估计分布的参数：离散变量（多值）</h3><script type="math/tex; mode=display">
x_{ij}=\left\{\begin{align}&1, &&\text{if }x_i \text{ is in state }j\\&0,&&\forall j\neq i\end{align}\right.,\ \sum_{j=1}^K q_j=1, \ q=[q_1,q_2,\dots,q_K]^T</script><p>写出似然函数：</p>
<script type="math/tex; mode=display">
p(X|q)=\prod_{i=1}^n\prod_{j=1}^K(q_j)^{x_{ij}}=\sum_{j=1}^K(q_j)^{\sum_i x_{ij}}</script><p>而贝叶斯估计需要一个关于参数的先验假设。这个先验假设成什么分布好呢？</p>
<p>一些人，应该说一大堆人，到了这个地方，老是跟你说“刚好啊”，“凑巧啊”，“不妨啊”，“这个分布具有某些良好的性质啊”。就是没说最根本的原因，坑了另外一大堆人，在这里搞得半懂不懂的。</p>
<p><strong>这里，涉及到一个重要的概念，共轭分布，定义为：$p(w)$ 与 $p(w|D)$ 同分布。就是说，它使得后验概率分布的函数形式与先验概率相同，因此使得贝叶斯分析得到了极大的简化。</strong></p>
<p>简单来说，按照共轭分布去找，这样找下来有几个对应的：</p>
<ul>
<li>伯努利分布的先验为Beta分布；</li>
<li>多项分布的先验为Dirichlet分布；</li>
<li>高斯分布的先验为高斯分布。</li>
</ul>
<blockquote>
<p>插一句：推荐<a href="知乎上找">马春鹏同学翻译的PRML</a>。</p>
</blockquote>
<h4 id="Dirichlet分布"><a href="#Dirichlet分布" class="headerlink" title="Dirichlet分布"></a>Dirichlet分布</h4><p>事先说明一下，这个分布实在是，老母猪戴胸罩——一套又一套。</p>
<p>Dirichlet分布如下：</p>
<script type="math/tex; mode=display">
\theta\sim Dirichlet(\theta|\alpha)=\frac{1}{B(\alpha)}\prod_{j=1}^n\theta_j^{\alpha_j-1}</script><p>其中：</p>
<script type="math/tex; mode=display">
\theta=(\theta_1,\dots,\theta_n), \ \alpha=(\alpha_1,\dots,\alpha_n)</script><p>$B(\alpha)$ 为Beta函数，其定义为：</p>
<script type="math/tex; mode=display">
\frac{1}{B(\alpha)}=\frac{\Gamma(\alpha_0)}{\Gamma(\alpha_1)\dots\Gamma(\alpha_n)},\ \alpha_0=\sum_{j=1}^n\alpha_j</script><p>Gamma函数定义如下：</p>
<script type="math/tex; mode=display">
\Gamma(x)=\int_{0}^\infty u^{x-1}e^{-u}du</script><p>如果参数 $\theta$ 满足Dirichlet分布，考虑所有的参数 $\theta$ 的分布情况，将其代入公式（可以看作将所有的 $\theta$，根据其概率密度函数，给予其相应权重，得到的全局期望值）：</p>
<script type="math/tex; mode=display">
E[\theta_i]=\int \theta_i p(\theta)d\theta=\frac{\alpha_i}{\alpha_0}</script><p>公式推导过程如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
E[\theta_1]&=\int \theta_1p(\theta)d\theta\\
&=\int\theta_1\frac{\Gamma(\alpha_0)}{\Gamma(\alpha_1)\dots\Gamma(\alpha_n)}\prod_{j=1}^n\theta_j^{\alpha_j-1}d\theta\\
&=\int\frac{\alpha_1}{\alpha_0}\frac{\Gamma(\alpha_0+1)}{\Gamma(\alpha_1+1)\dots\Gamma(\alpha_n)}\theta_1^{1+(\alpha_1-1)}\prod_{j=2}^n\theta_j^{\alpha_j-1}d\theta\\
&=\frac{\alpha_1}{\alpha_0}
\end{align*}</script><p>PPT上这里讲得太粗糙了，关于最后一步，需要一些性质。</p>
<p>首先是Gamma函数的性质：</p>
<script type="math/tex; mode=display">
\Gamma(x+1)=x\Gamma(x)</script><p>所以有：</p>
<script type="math/tex; mode=display">
\frac{\Gamma(\alpha_0+1)}{\Gamma(\alpha_1+1)\dots\Gamma(\alpha_n)}=\frac{\alpha_0\Gamma(\alpha_0)}{\alpha_1\Gamma(\alpha_1)\dots\Gamma(\alpha_n)}</script><p>然后是概率密度函数的性质。概率密度函数的积分为1，所以Dirichlet分布有：</p>
<script type="math/tex; mode=display">
\int \frac{\Gamma(\alpha_0)}{\Gamma(\alpha_1)\dots\Gamma(\alpha_n)}\prod_{j=1}^n\theta_j^{\alpha_j-1}d\theta=1</script><p>把公式中的右半部分看成一个新的Dirichlet分布，即按以下对应：</p>
<script type="math/tex; mode=display">
\alpha_1'=\alpha_1+1\\
\alpha_0'=\alpha_0+1</script><p>所以有：</p>
<script type="math/tex; mode=display">
\int\frac{\Gamma(\alpha_0+1)}{\Gamma(\alpha_1+1)\dots\Gamma(\alpha_n)}\theta_1^{1+(\alpha_1-1)}\prod_{j=2}^n\theta_j^{\alpha_j-1}d\theta=1</script><p>这样就ok了。</p>
<hr>
<p>现在将已知的满足Dirichlet分布的 $\theta$ 信息代入到贝叶斯公式中，得到后验概率公式：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(\theta|X)&\propto p(X|\theta)p(\theta|\alpha)\propto \prod_{j=1}^K\theta_j^{\sum_ix_{ij}}\times\frac{\Gamma(\alpha_0)}{\Gamma(\alpha_1)\dots\Gamma(\alpha_K)}\prod_{j=1}^K\theta_j^{\alpha_j-1}\\
&=\frac{\Gamma(\alpha_0)}{\Gamma(\alpha_1)\dots\Gamma(\alpha_K)}\prod_{j=1}^K\theta_j^{\alpha_j+N_j-1}\propto \frac{\Gamma(\alpha_0+N)}{\Gamma(\alpha_1+N_1)\dots\Gamma(\alpha_K+N_K)}\prod_{j=1}^K\theta_j^{\alpha_j+N_j-1}\\
&=Dirichlet(\theta|\alpha+\textbf n)
\end{align*}</script><p>其中，$\textbf n=[N_1,N_2,\dots,N_K]^T, N=\sum_i N_i, N_i$ 为 $x_i$ 出现的次数。这里能够看出结果是一个新的Dirichlet分布。这也是我们使用Dirichlet分布作为多项式分布的先验的原因，强大的聚合性。</p>
<p>之后根据Dirichlet分布的性质，有：</p>
<script type="math/tex; mode=display">
p(x|X)=\int_\theta p(x|\theta)p(\theta|X)d\theta=\int_\theta\theta_xp(\theta|X)d\theta=E[\theta_x|X]=\frac{n_x+a_x}{n+a_0}</script><p>通过上式可以很明显地看出，随着已知信息（先验概率）的不断更新，其对后验概率造成的直接影响。</p>
<h3 id="举例：估计分布的参数：离散变量（二值）"><a href="#举例：估计分布的参数：离散变量（二值）" class="headerlink" title="举例：估计分布的参数：离散变量（二值）"></a>举例：估计分布的参数：离散变量（二值）</h3><p>$X=\{x_i\}_{i=1}^n, x_i\in\{0,1\},  X\sim Bern(\theta)$，其样本似然为：</p>
<script type="math/tex; mode=display">
p(X|\theta)=\prod_{i=1}^n\theta^{x_i}(1-\theta)^{1-x_i}=\theta^{n_1}(1-\theta)^{n_0},\ n_1=\sum_ix_i,\ n_0=n-n_1.</script><p>当参数 $\theta$ 服从Beta分布，Beta分布为：</p>
<script type="math/tex; mode=display">
Beta(\theta|a,b)=\frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}\theta^{a-1}(1-\theta)^{b-1}</script><p>Beta分布 $\theta \sim Beta(\theta|a,b)$ 有以下性质：</p>
<ul>
<li>$E[\theta]=\frac{a}{a+b}$；</li>
<li>$\sigma^2(\theta)=\frac{ab}{(a+b)^2(a+b+1)}$；</li>
<li>$\textbf{mode}=\frac{a-1}{a+b-2}$。<strong>这里的mode是指最大值，概念来源于聚类，一个高峰即一个类别即一个mode</strong></li>
</ul>
<p>同样的，先计算其后验概率：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(\theta|X)&\propto p(\theta)p(X|\theta)=\frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}\theta^{a-1}(1-\theta)^{b-1}\times\theta^{n_1}(1-\theta)^{n_0}\\
&=\frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}\theta^{n_1+a-1}(1-\theta)^{n_0+b-1}\\
&=Beta(\theta|n_1+a,n_0+b)
\end{align*}</script><p>代入概率图模型得到：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(x=1|X)&=\int p(x=1|\theta)p(\theta|X)d\theta\\
&=\int \theta Beta(\theta|a+n_1,b+n_0)d\theta\\
&=E[\theta]=\frac{a+n_1}{a+b+n}
\end{align*}</script><h3 id="二项分布的MLE-MAP-贝叶斯估计三者比较"><a href="#二项分布的MLE-MAP-贝叶斯估计三者比较" class="headerlink" title="二项分布的MLE/MAP/贝叶斯估计三者比较"></a>二项分布的MLE/MAP/贝叶斯估计三者比较</h3><script type="math/tex; mode=display">
\begin{align*}
&\theta_{MLE}=\text{arg max }p(X|\theta)\Rightarrow\theta_{MLE}=\frac{n_1}{n}\\
&\theta_{MAP}=\text{arg max }p(\theta|X)\Rightarrow\theta_{MAP}=\frac{a+n_1-1}{a+b+n-2}\\
&\theta_{Bayes}=\int p(x=1|\theta)p(\theta|X)d\theta\Rightarrow\theta_{Bayes}=\frac{a+n_1}{a+b+n}
\end{align*}</script><p>通过比较我们可以看出在MLE中，对于概率的计算偏向于频率学派的观点，而MAP和Bayes中，充分吸收了Bayes学派的观点，考虑了先验信息。当已知信息有限时，MAP和Bayes的方法更加科学和有效。</p>
<p>其中Bayes的结果还可以写成：</p>
<script type="math/tex; mode=display">
\frac{a+n_1}{a+b+n}=\frac{a+b}{a+b+n}\times\frac{a}{a+b}+\frac{n}{a+b+n}\times\frac{n_1}{n}</script><p>通过上式可以更好地说明，当 $n$ （试验次数）充分大时，Bayes的结果与MLE相等。当 $n$ 有限时，则充分考虑先验信息。</p>
<h3 id="估计分布的参数：单变量高斯，方差已知"><a href="#估计分布的参数：单变量高斯，方差已知" class="headerlink" title="估计分布的参数：单变量高斯，方差已知"></a>估计分布的参数：单变量高斯，方差已知</h3><p>$X=\{x_1,\dots,x_n\}, x_i\in \mathbb R, X\sim N(\mu, \sigma^2), \mu\sim N(\mu_0,\sigma_0^2)$，这里的似然为：</p>
<script type="math/tex; mode=display">
p(X|\mu)=\prod_{i=1}^n\frac{1}{\sqrt{2\pi}\sigma}\text{exp}\left[-\frac{(x_i-\mu)^2}{2\sigma^2}\right]=\left(\frac{1}{\sqrt{2\pi\sigma}}\right)^n\text{exp}\left[-\frac{1}{2\sigma^2}\sum_{i=1}^n(x_i-\mu)^2\right]</script><p>$\mu$ 的先验为：</p>
<script type="math/tex; mode=display">
p(\mu)\sim N(\mu_0,\sigma_0^2)=\frac{1}{\sqrt{2\pi}\sigma_0}\text{exp}\left[-\frac{1}{2\sigma_0^2}(\mu-\mu_0)^2\right]</script><p>根据后验概率公式：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(\mu|X)&\propto p(\mu)p(X|\mu)\\
&=\left\{\left(\frac{1}{\sqrt{2\pi}\sigma}\right)^n\text{exp}\left[-\frac{1}{2\sigma^2}\sum_{i=1}^n(x_i-\mu)^2\right]\right\}\times\left\{\frac{1}{\sqrt{2\pi}\sigma_0}\text{exp}\left[-\frac{(\mu-\mu_0)^2}{2\sigma_0^2}\right]\right\}
\end{align*}</script><p>考虑概率密度函数的等比例性质：</p>
<script type="math/tex; mode=display">
f=\frac{g(x)}{\int g(x)dx}</script><p>其中等式左边为概率密度函数，证明如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
&f\propto g\Rightarrow g(x)=cf(x)\\
&\frac{g(x)}{\int g(x)dx}=\frac{cf(x)}{\int cf(x)dx}=f(x)
\end{align*}</script><p><strong>这里将概率密度函数的等比例性质用于从先验分布×似然分布=后验分布的过程中，多余的系数可以作为积分项省略，包括前面的Dirichlet分布和Beta分布。</strong></p>
<p>即后验概率函数又可写成：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(\mu|X)&\propto p(\mu)p(X|\mu)\\
&=\left\{\left(\frac{1}{\sqrt{2\pi}\sigma}\right)^n\text{exp}\left[-\frac{1}{2\sigma^2}\sum_{i=1}^n(x_i-\mu)^2\right]\right\}\times\left\{\frac{1}{\sqrt{2\pi}\sigma_0}\text{exp}\left[-\frac{(\mu-\mu_0)^2}{2\sigma_0^2}\right]\right\}\\
&\propto \text{exp}\left[-\frac{1}{2\sigma^2}\sum_{i=1}^n(x_i-\mu)^2-\frac{1}{2\sigma_0^2}(\mu-\mu_0)^2\right]\\
&=\text{exp}\left[(\dots)\mu^2+(\dots)\mu+c\right]\\
&=\text{exp}\left[\left(-\frac{n}{2\sigma^2}-\frac{1}{2\sigma_0^2}\right)\mu^2+\left(\frac{\sum_i x_i}{\sigma^2}+\frac{\mu_0}{\sigma_0^2}\right)\mu+c\right]\\
&=\text{exp}\left[-\frac{1}{2}\left(\frac{n}{\sigma^2}+\frac{1}{\sigma_0^2}\right)\left(\mu-\frac{\frac{\sum_ix_i}{\sigma^2}+\frac{\mu_0}{\sigma_0^2}}{\frac{n}{\sigma^2}+\frac{1}{\sigma_0^2}}\right)^2+c'\right]\Leftarrow ax^2+bx+c=a\left(x+\frac{b}{2a}\right)^2+\frac{-V}{4ac}\\
&\propto \text{exp}\left[-\frac{1}{2\sigma_n^2}(\mu-\mu_n)^2\right],\ \frac{1}{\sigma_n^2}=\frac{1}{\sigma_0^2}+\frac{n}{\sigma^2},\ \mu_n=\frac{\sigma^2}{n\sigma_0^2+\sigma^2}\mu_0+\frac{n\sigma_0^2}{n\sigma_0^2+\sigma^2}\mu_{MLE}
\end{align*}</script><p>从上式可知，先验信息（高斯分布的均值）会随着试验次数 $n$ 的增大，对后验信息的影响逐渐减小。</p>
<p>即后验的分布为：</p>
<script type="math/tex; mode=display">
p(\mu|X)=N(\mu_n,\sigma_n^2)</script><p>代入概率图为：</p>
<script type="math/tex; mode=display">
p(x|X)=\int p(x|\mu)p(\mu|X)d\mu=E_{\mu|X}[p(x|\mu)]</script><p>随着试验次数的增多，预测结果的方差会减小，即预测结果更加准确。</p>
<h3 id="估计分布的参数：单变量高斯，方差未知"><a href="#估计分布的参数：单变量高斯，方差未知" class="headerlink" title="估计分布的参数：单变量高斯，方差未知"></a>估计分布的参数：单变量高斯，方差未知</h3><p>已知：</p>
<script type="math/tex; mode=display">
X=\{x_1,\dots,x_n\},\ x_i\in \mathbb R,\ X\sim N(\mu,\sigma^2),\ \textbf{precision:}\lambda=\frac{1}{\sigma^2}</script><p>且其中 $\lambda$ 满足 $\Gamma$ 函数分布：</p>
<script type="math/tex; mode=display">
p(\lambda)\sim Gamma(\lambda|a_0,b_0)=\frac{b_0^{a_0}\lambda^{a_0-1}\text{exp}(-b_0\lambda)}{\Gamma(a_0)}</script><p>似然函数为：</p>
<script type="math/tex; mode=display">
p(X|\lambda)=\prod_{i=1}^n\frac{\lambda^{1/2}}{\sqrt{2\pi}}\text{exp}\left[-\frac{\lambda(x_i-\mu)^2}{2}\right]=\lambda^{n/2}(2\pi)^{-n/2}\text{exp}\left[-\frac{\lambda}{2}\sum_{i=1}^n(x_i-\mu)^2\right]</script><p>计算后验概率：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(\lambda|X)&\propto p(\lambda)p(X|\lambda)\\
&\propto(\lambda^{a_0-1}\text{exp}(-b_0\lambda))\times\left(\lambda^{n/2}\text{exp}\left[-\frac{\lambda}{2}\sum_{i=1}^n(x_i-\mu)^2\right]\right)\\
&=\lambda^{a_0+n/2-1}\text{exp}\left\{-\left[b_0+\frac{1}{2}\sum_{i=1}^n(x_i-\mu)^2\right]\lambda\right\}\\
&\sim Gamma(a_n,b_n),\ a_n=a_0+\frac{n}{2},\ b_n=b_0+\frac{n}{2}s^2,\ s^2=\frac{1}{n}\sum_{i=1}^n(x_i-\mu)^2
\end{align*}</script><p>显然后验概率满足Gamma函数，其参数 $(a_n,b_n)$ 与试验次数相关。</p>
<p>同理，有：</p>
<script type="math/tex; mode=display">
\begin{align*}
&p(\lambda|X)=Gamma(a_n,b_n)\\
&p(x|X)=\int p(x|\lambda)p(\lambda|X)d\lambda=E_{\lambda|X}[p(x|\lambda)]
\end{align*}</script><h3 id="估计模型的参数：回归"><a href="#估计模型的参数：回归" class="headerlink" title="估计模型的参数：回归"></a>估计模型的参数：回归</h3><p>贝叶斯学习方法同样可以用在回归模型中，问题描述为：</p>
<script type="math/tex; mode=display">
D=\{\langle x_i,y_i\rangle\}_{i=1}^n,\ y=w^Tx+\varepsilon,\ \varepsilon\sim N(0,\beta^{-1})</script><p>则：</p>
<script type="math/tex; mode=display">
p(y|x,w)\sim N(w^Tx,\beta^{-1})</script><p>回顾最大似然估计，其目标函数为：</p>
<script type="math/tex; mode=display">
\begin{align*}
L(X|w)&=\text{log}p(X|w)=\text{log}p(X,y|w)=\text{log}p(y|X,w)+\text{log}p(X)
\end{align*}</script><p>其中：</p>
<script type="math/tex; mode=display">
\begin{align*}
\text{log}p(y|X,w)&=\text{log}\prod_{i=1}^np(y_i|x_i,w)\\
&=\text{log}\prod_{i=1}^n\sqrt\frac{\beta}{ {2\pi} }\text{exp}\left[-\frac{\beta}{2}(y_i-w^Tx_i)^2\right]\\
&=-n\text{log}\sqrt{2\pi}+n\text{log}\sqrt \beta -\frac{\beta}{2}\sum_{i=1}^n(y_i-w^Tx_i)^2
\end{align*}</script><p>对参数的估计可转化为最小二乘法：</p>
<script type="math/tex; mode=display">
w^\ast=\text{arg max}_w\text{log}p(y|X,w)\Leftrightarrow\text{arg min}_w\frac{1}{2}\sum_{i=1}^n(y_i-w^Tx_i)^2</script><p>结果为：</p>
<script type="math/tex; mode=display">
w_{MLE}=(X^TX)^{-1}X^Ty</script><p>利用贝叶斯的逻辑，将充分考虑先验信息（结构风险最小化）：</p>
<script type="math/tex; mode=display">
p(w|X)\propto p(w)p(X|w)\propto \text{exp}\left[-\frac{1}{2}\left(\beta(y-Xw)^T(y-Xw)+\alpha w^Tw\right)\right]</script><p>接下来的公式推导目的是，后验分布为高斯分布：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\beta(y-Xw)^T(y-Xw)+\alpha w^Tw\\
=&w^T(\beta X^TX+\alpha I)w-2\beta w^TX^T y+\beta y^Ty
\end{align*}</script><p>设 $\Sigma_n^{-1}=(\beta X^TX+\alpha I), \Sigma_n^{-1}\mu_n=\beta X^Ty$，则：</p>
<script type="math/tex; mode=display">
\begin{align*}
&w^T(\beta X^TX+\alpha I)w-2\beta w^TX^T y+\beta y^Ty\\
=&(w-\mu_n)^T\Sigma_n^{-1}(w-\mu_n)+常数\sim N(\mu_n,\Sigma_n)
\end{align*}</script><p>其中，$\mu_n=\beta\Sigma_nX^Ty, \Sigma_n=(\beta X^TX+\alpha I)^{-1}$。</p>
<p>以上推导需要 $\beta X^TX+\alpha I$ 可逆，证明：</p>
<p>因为 $X^TX$ 可逆，所以有：</p>
<script type="math/tex; mode=display">
\begin{align*}
&(X^TX)u=\lambda u\Rightarrow(\beta X^TX+\alpha I)u=(\lambda \beta+\alpha)u,\\
&\lambda \ge 0, \beta \ge 0, \alpha \ge 0 \Rightarrow \lambda \beta+\alpha >0\Rightarrow \beta X^TX+\alpha I可逆.
\end{align*}</script><p>考虑参数的所有取值情况，即代入概率图进行预测，有：</p>
<script type="math/tex; mode=display">
\begin{align*}
y&=\int(w^Tx)p(w|X)dw\\
&=\left[\int wp(w|X)dw\right]^Tx\\
&=\left(E_{w|X}[w]\right)^Tx\\
&=\mu_n^Tx
\end{align*}</script><p>同样先考虑参数的所有取值情况，由于参数符合高斯分布，且概率之和等于一，有：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(y|x,X)&=\int_w p(y,w|x,X)dw\\
&=\int_w p(y|x,w,X)p(w|x,X)dw\\
&=\int_w p(y|x,w)p(w|X)dw\\
&=\int_w p(y|w^Tx,\beta^{-1})N(w|\mu_n,\Sigma_n)dw\\
&=\int_w g(y)N(w|\mu,\Sigma)dw\Leftarrow我们的目标\\
&=g(y)
\end{align*}</script><p>将两个高斯分布展开：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(y|x,X)&=\int_w N(y|w^Tx,\beta^{-1})N(w|\mu_n,\Sigma_n)dw\\
&\propto_y\int_w\text{exp}\left[-\frac{\beta}{2}(y-w^Tx)^2\right]\text{exp}\left[-\frac{1}{2}(w-\mu_n)^T\Sigma_n^{-1}(w-\mu_n)\right]dw\\
&\propto_y\int_w\text{exp}\left[-\frac{\beta}{2}(y^2-2w^Txy+w^Txx^Tw)-\frac{1}{2}(w^T\Sigma_n^{-1}w-2w^T\Sigma_n^{-1}\mu_n+\mu_n^T\Sigma_n^{-1}\mu_n)\right]dw
\end{align*}</script><p>其中指数项：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\beta(y^2-2w^Txy+w^Txx^Tw)+w^T\Sigma_n^{-1}w-2w^T\Sigma_n^{-1}\mu_n\\
=&w^T(\beta xx^T+\Sigma_n^{-1})w-2w^T(\beta xy+\Sigma_n^{-1}\mu_n)+\beta y^2\\
=&(w-m)^TL(w-m)+\dots+\beta y^2\Leftarrow 目标\\
=&w^TLw-2w^TLm+m^TLm+\beta y^2-m^TLm
\end{align*}</script><p>其中：</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}&L=\beta xx^T+\Sigma_n^{-1}\\&Lm=\beta xy+\Sigma_n^{-1}\mu_n\end{aligned}\right.\Rightarrow\left\{\begin{aligned}&L=\beta xx^T+\Sigma_n^{-1}\\&m=L^{-1}(\beta xy+\Sigma_n^{-1}\mu_n)\end{aligned}\right.</script><p>综上：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(y|x,X)&\propto_y\int_w\text{exp}\left[-\frac{1}{2}(w-m)^TL(w-m)\right]\text{exp}\left[\frac{1}{2}m^TLm-\frac{1}{2}\beta y^2\right]dw\\
&\propto_y\text{exp}\left[\frac{1}{2}m^TLm-\frac{1}{2}\beta y^2\right]\\
&=\text{exp}\left[-\frac{1}{2}\left(\beta y^2-(\beta xy+\Sigma_n^{-1}\mu_n)^TL^{-1}(\beta xy+\Sigma_n^{-1}\mu_n\right)\right]\\
&=\text{exp}\left[-\frac{1}{2}\left((\beta-\beta^2x^TL^{-1}x)y^2-2\beta yx^TL^{-1}\Sigma_n^{-1}\mu_n-(\Sigma_n^{-1}\mu_n)^TL^{-1}(\Sigma_n^{-1}\mu_n)\right)\right]\\
&\propto \text{exp}\left[-\frac{1}{2}\left(\lambda(y-u)^2\right)\right]\\
&=\text{exp}\left[-\frac{1}{2}(\lambda y^2-2\lambda uy+\lambda u^2)\right]\Leftarrow 我们的目标
\end{align*}</script><p>其中：</p>
<script type="math/tex; mode=display">
\left\{\begin{align}&L=\beta xx^T+\Sigma_n^{-1}\\&\lambda = \beta(1-\beta x^TL^{-1}x)\\&u=\frac{1}{\lambda} \beta x^T L^{-1} \Sigma_n^{-1}\mu_n\end{align}\right.</script><p>最后得到结果为：</p>
<script type="math/tex; mode=display">
p(y|x,X)=N\left(y\left|u,\frac{1}{\lambda}\right.\right)</script><p>根据S-M公式（舍曼和莫里森于1949年提出）有：</p>
<script type="math/tex; mode=display">
\begin{align*}
&(A+uv^T)^{-1}=A^{-1}-\frac{A^{-1}uv^TA^{-1}}{1+v^TA^{-1}u}\\
\Rightarrow&L^{-1}=\left(\Sigma_n^{-1}+\beta xx^T\right)^{-1}=\Sigma_n-\frac{\beta \Sigma_nxx^T\Sigma_n}{1+\beta x^T\Sigma_n x}
\end{align*}</script><p>代入 $L$，有：</p>
<script type="math/tex; mode=display">
\begin{align*}
&x^TL^{-1}x=x^T\Sigma_n x-\frac{\beta x^T\Sigma_nxx^T\Sigma_nx}{1+\beta x^T\Sigma_nx}=\frac{x^T\Sigma_nx}{1+\beta x^T\Sigma_nx}\\
\Rightarrow&\lambda=\beta(1-\beta x^TL^{-1}x)=\frac{\beta}{1+\beta x^T\Sigma_nx}\Rightarrow\text{var}(y)=\frac{1}{\lambda}=\beta^{-1}+x^T\Sigma_nx\\
\Rightarrow&u=\frac{1}{\lambda}\beta x^TL^{-1}\Sigma_{n}^{-1}\mu_n=(\beta^{-1}+x^T\Sigma_nx)\beta x^T\left(\Sigma_n-\frac{\beta \Sigma_nxx^T\Sigma_n}{1+\beta x^T\Sigma_nx}\right)\Sigma_n^{-1}\mu_n=x^T\mu_n
\end{align*}</script><h3 id="估计模型的参数：分类"><a href="#估计模型的参数：分类" class="headerlink" title="估计模型的参数：分类"></a>估计模型的参数：分类</h3><p>问题描述：</p>
<script type="math/tex; mode=display">
X=\{\langle x_i,y_i\rangle\}_{i=1}^n,\ \sigma_i=p(C_1|x_i)=sigmoid(w^Tx_i)</script><p>似然函数：</p>
<script type="math/tex; mode=display">
p(X|w)=\prod_{i=1}^n\sigma_i^{y_i}(1-\sigma_i)^{1-y_i}</script><p>先验信息：</p>
<script type="math/tex; mode=display">
p(w)=N(\textbf{m}_0,\textbf{S}_0)</script><p>参数的后验概率函数为：</p>
<script type="math/tex; mode=display">
\begin{align*}
&p(w|X)\propto p(w)p(X|w)\\
\propto &\text{exp}\left[-\frac{1}{2}(w-\textbf m_0)^T\textbf S_0^{-1}(w-\textbf{m}_0)\right]\times \left[\prod_{i=1}^n\sigma_i^{y_i}(1-\sigma_i)^{1-y_i}\right]
\end{align*}</script><p>解决方案：拉普拉斯近似，当要对某个分布进行近似的时候，可以考虑在它的一阶导数为0的点（mode）进行高斯函数的拟合。</p>
<script type="math/tex; mode=display">
\begin{align*}
&\text{log}f(x)=\text{log}f(x_0)-\frac{1}{2}a(x-x_0)^2+\dots,\ a=-\frac{d}{dx^2}\text{log}f(x)|x=x_0\\
\Rightarrow &f(x)=f(x_0)\text{exp}\left[-\frac{1}{2}a(x-x_0)^2\right]\\
\Rightarrow &f(x)\propto \text{exp}\left[-\frac{1}{2}a(x-x_0)^2\right]
\end{align*}</script><p>上式为泰勒展开式，其中一阶导项因为 $f’(x_0)=0$ ，为0。因为：</p>
<script type="math/tex; mode=display">
q(x)=\sqrt{\frac{a}{2\pi}}\text{exp}\left[-\frac{1}{2}a(x-x_0)^2\right]\sim N(x_0,\frac{1}{a})</script><p>多维情况为：</p>
<script type="math/tex; mode=display">
q(x)=\frac{|\textbf{A}|^{1/2}}{(2\pi)^{d/2}}\text{exp}\left[-\frac{1}{2}(\textbf{x}-\textbf x_0)^T\textbf A(\textbf x-\textbf x_0)\right]\sim N_d(\textbf x_0, \textbf A^{-1})</script><p>其中，$\textbf A=-\nabla \nabla\text{log}f(x)|_{x=x_0}$。</p>
<p>则：</p>
<script type="math/tex; mode=display">
p(w|X)\propto \text{exp}\left[-\frac{1}{2}(w-\textbf m_0)^T\textbf S_0^{-1}(w-\textbf m_0)\right]\times \left[\prod_{i=1}^n\sigma_i^{y_i}(1-\sigma_i)^{1-y_i}\right]</script><p>其中：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\textbf A=-\nabla\nabla\text{log}p(w|X)=\textbf S_0^{-1}+\sum_i \sigma_i(1-\sigma_i)x_ix_i^T=\textbf S_0^{-1}+\textbf X^T\pmb {\Lambda}\textbf X\\
\Rightarrow&q(w)\sim N(w_{MAP},\textbf S_n^{-1}), \ \textbf S_n=\textbf A.
\end{align*}</script><h3 id="估计模型的参数：朴素贝叶斯的贝叶斯估计"><a href="#估计模型的参数：朴素贝叶斯的贝叶斯估计" class="headerlink" title="估计模型的参数：朴素贝叶斯的贝叶斯估计"></a>估计模型的参数：朴素贝叶斯的贝叶斯估计</h3><p>问题的形式化描述为：</p>
<script type="math/tex; mode=display">
D=\{\langle x^{(1)},y_1\rangle,\dots,\langle x^{(n)},y_n\rangle\},\ x^{(i)}=(x_1^{(i)},\dots,x_d^{(i)})^T,\ x_j^{(i)}\in A_j,\ y_i\in\{1,2,\dots,m\}\\
\langle x^{(1)},y_1\rangle,\dots,\langle x^{(n)},y_n\rangle\sim p(x,y|\theta)</script><p>贝叶斯规则：</p>
<script type="math/tex; mode=display">
p(x,y|\theta)=p(y|\theta)p(x|y,\theta)=p(y|\theta)\prod_{j=1}^dp(x_j|y,\theta)</script><p>其中：</p>
<script type="math/tex; mode=display">
\begin{align*}
&p(x_j|y,\theta)=P(X_j=x_j|Y=y,\theta)=r_{jy}(x_j)\\
&p(y|\theta)=\pi(y),\ \pi=(\pi(1),\dots,\pi(m))\\
&\sum_{k\in A_j}r_{jy}(k)=1,\ \sum_y \pi(y)=1,\ j=1,2,\dots,d,\ y=1,2,\dots,m,\ x_j\in A_j
\end{align*}</script><p>概率图描述为：</p>
<p><img src="http://image.rexking6.top/img/clip1555485176.png" alt=""></p>
<p>样本似然函数：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(X|\theta)&=\prod_{i=1}^np(x^{(i)},y_i|\theta)\\
&=\prod_{i=1}^np(y_i|\theta)p(x^{(i)}|y_i,\theta)\\
&=\prod_{i=1}^np(y_i|\theta)\prod_{j=1}^dp(x_j^{(i)}|y_i,\theta)\\
&=\prod_{i=1}^np(y_i|\theta)\prod_{j=1}^d\prod_{k=1}^mp(x_j^{(i)}|y_i,\theta)^{I\{y_i=k\}}\\
&=\prod_{i=1}^np(y_i|\theta)\prod_{j=1}^d\prod_{k=1}^mr_{jk}(x_j^{(i)})^{I\{y_i=k\}}\\
&=\prod_{i=1}^nCat(y_i|\pi)\prod_{j=1}^d\prod_{k=1}^mCat(x_j^{(i)}|r_{jk})^{I\{y_i=k\}}
\end{align*}</script><p>同前面一样，对于似然函数是多项式分布的，我们取它的共轭分布——Dirichlet分布作为先验分布：</p>
<script type="math/tex; mode=display">
p(\theta)=Dir(\pi|\alpha)\prod_{jk}Dir(r_{jk}|\beta)</script><p>则后验函数为：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(\theta|X)&\propto p(\theta)p(X|\theta)\\
&=\left[Dir(\pi|\alpha)\prod_{jk}Dir(r_{jk}|\beta)\right]\times\left[\prod_{i=1}^nCat(y_i|\pi)\prod_{j=1}^d\prod_{k=1}^mCat(x_j^{(i)}|r_{jk})^{I\{y_i=k\})}\right]\\
&=\left[Dir(\pi|\alpha)\prod_{i=1}^nCat(y_i|\pi)\right]\times\left[\prod_{i=1}^n\prod_{j=1}^d\prod_{k=1}^mDir(r_{jk}|\beta)Cat(x_j^{(i)}|r_{jk})^{I\{y_i=k\}}\right]\\
&=Dir(\pi|\alpha+c)\prod_{jk}Dir(r_{jk}|\beta+d_{jk})
\end{align*}</script><p>其中，$c_k=\sharp\{i:y_i=k\}, d_{jk}(l)=\sharp\{i:x_j^{(i)}=l,y_i=k\}$。</p>
<p>预测分布：</p>
<script type="math/tex; mode=display">
\begin{align*}
&p(x,y|\theta)=\pi(y)\prod_{j=1}^d\prod_{k=1}^mr_{jk}(x_j)^{I\{y=k\}}\\
&p(\theta|X)=Dir(\pi|\alpha+c)\prod_{jk}Dir(r_{jk}|\beta+d_{jk})\\
\end{align*}</script><p>所以：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(y|x,X)&\propto\int p(x,y|\theta)p(\theta|X)d\theta\\
&\propto \int\left[\pi(y)\prod_{jk}r_{jk}(x_j)^{I\{y=k\}}\right]\times\left[Dir(\pi|\alpha+c)\prod_{jk}Dir(r_{jk}|\beta+d_{jk})\right]d\theta\\
&=\int[\pi(y)Dir(\pi|\alpha+c)]d\pi\times\prod_{jk}\left[\int \left(r_{jk}(x_j)^{I\{y=k\}}Dir(r_{jk}|\beta+d_{jk})\right)dr_{jk}\right]\\
&=\left(\frac{\alpha_y+c_y}{\sum_{y=1}^m(\alpha_y+c_y)}\right)\prod_{j=1}^d\left(\frac{\beta_{x_j}+d_{jy}(x_j)}{\sum_{l=1}^N(\beta_l+d_{jy}(l))}\right)\\
&=\left(\frac{\alpha_y+c_y}{\alpha_0+n}\right)\prod_{j=1}^d\frac{\beta_{x_j}+d_{jy}(x_j)}{\beta_0+c_y}
\end{align*}</script><p>其中，$\sum_{y=1}^m\alpha_y=\alpha_0, \sum_{y=1}^m=n, \sum_{l=1}^N\beta_1=\beta_0, \sum_{l=1}^Nd_{jy}(l)=c_y$。上式从积分推导到期望，其中的 $\pi(y)$和 $r_{jk}(x_j)^{I\{y=k\}}$ 都为概率，各自之和为1，所以积分后化去。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上的各种方法都是假设已知信息有效的情况下，实验数据偏少，充分利用先验信息，先给定一个初步预测，再通过实验的进行（已知信息的增加）不断对先验信息进行校正，使之不断地向精确偏移，很像某种程度上的拉普拉斯近似。在之前的推导中，可以发现随着实验次数的不断增大，贝叶斯学习的结果将无限趋近于MLE的结果。所以事实上当实验数据量足够大时，先验信息的取值误差对结果的影响很小。即当数据量有保障时，先验信息的取值不用过于谨慎。</p>
<h1 id="EM"><a href="#EM" class="headerlink" title="EM"></a>EM</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>当模型中的所有变量均是观测变量时，极大似然估计MLE可以很好地解决问题。但实际中往往会遇到未知地变量存在，称为“隐变量”。这时候，就需要EM（Expectation-Maximization）算法，直译为“期望最大化”算法，其实是一种迭代算法，本质上也是极大似然估计MLE。</p>
<p>极大似然估计为：</p>
<script type="math/tex; mode=display">
\theta = \text{arg max }L(\theta)=\text{arg max }\sum_{i=1}^m \text{log}p_\theta(x_i)</script><p>如果再除以 $m$，则变为期望：</p>
<script type="math/tex; mode=display">
\theta = \text{arg max }\left(\sum_{i=1}^m\text{log}p_\theta(x_i)\right)/m=\text{arg max E[log}p_\theta(x_i)]</script><h2 id="混合高斯模型与EM"><a href="#混合高斯模型与EM" class="headerlink" title="混合高斯模型与EM"></a>混合高斯模型与EM</h2><p>混合高斯模型，就是多个高斯模型混合在一起。假设有下图数据，如果只用一个高斯模型去拟合这堆数据，则拟合出的黑色曲线不能很好地解决问题。此时用两个高斯模型的话，对原始数据便能拟合得比较好。</p>
<p><img src="http://image.rexking6.top/img/clip1555747881.png" alt=""></p>
<p>设有随机变量 $\bf x$，则混合高斯模型可以表示为：</p>
<script type="math/tex; mode=display">
p(\textbf x)=\sum_{k=1}^K\pi_k\mathcal N(\textbf x|\pmb \mu_k,\pmb \Sigma_k)</script><p>其中，$\mathcal{N}(\textbf x|\pmb \mu_k,\Sigma_k)$ 称为混合模型中的第 $k$ 个分量，即第 $k$ 个高斯模型，$\pi_k$ 是每个高斯模型的系数，也称混合系数且满足：</p>
<script type="math/tex; mode=display">
\sum_{k=1}^K\pi_k=1</script><p>应用极大似然估计：</p>
<script type="math/tex; mode=display">
\text{ln}p(\textbf X|\pmb \pi,\pmb \mu, \pmb \Sigma)=\sum_{n=1}^N\text {ln}\left\{\sum_{k=1}^K\pi_k\mathcal{N}(\textbf {x}_n|\pmb \mu_k,\pmb \Sigma_k)\right\}</script><p>其中 $N$ 表示样本总数，需要求解的参数 $\{\pmb \pi_k,\pmb \mu_k,\pmb \Sigma_k\}$。对上式各个变量求偏导并令其等于0：</p>
<ol>
<li><p>对 $\mu_k$ 求导并令其等于0得到：</p>
<script type="math/tex; mode=display">
0=-\sum_{n=1}^N\frac{\pi_k\mathcal{N}(\textbf{x}_n|\pmb \mu_k,\Sigma_k)}{\sum_j\pi_j\mathcal{N}(\textbf x_n|\pmb\mu_j,\pmb\Sigma_j)}\Sigma_k^{-1}(\textbf{x}_n-\pmb\mu_k)</script><p>其中左项比较复杂，用 $\gamma(z_{nk})$ 表示。化简之后得到：</p>
<script type="math/tex; mode=display">
\pmb\mu_k=\frac{1}{N_k}\sum_{n=1}^N\gamma(z_{nk})\textbf x_n\\
N_k=\sum_{n=1}^N\gamma(z_{nk})</script></li>
<li><p>对 $\pmb\pi_k$ 和 $\pmb\Sigma_k$ 分别求偏导并令其等于0得到：</p>
<script type="math/tex; mode=display">
\pmb\pi_k=\frac{N_k}{N}\\
\pmb\Sigma_k=\frac{1}{N_k}\sum_{n=1}^N\gamma(z_{nk})(\textbf x_n-\pmb\mu_k)(\textbf x_n-\pmb\mu_k)^T</script><p>其中 $\pmb \pi_k$ 的求取，需要加入限制条件，$\sum_{k=1}^K\pmb\pi_k=1$，因此需要加入拉格朗日算子：</p>
<script type="math/tex; mode=display">
\text{ln}p(\textbf x|\pmb\pi,\pmb\mu,\pmb\Sigma)+\lambda(\sum_{k=1}^K\pmb\pi_k-1)</script><p>求上式关于 $\pmb\pi_k$ 的最大似然函数，得到：</p>
<script type="math/tex; mode=display">
0=\sum_{n=1}^N\frac{\mathcal{N}(\textbf x_n|\pmb\mu_k,\pmb\Sigma_k)}{\sum_j\pmb\pi_j\mathcal{N}(\textbf x_n|\pmb\mu_j,\pmb\Sigma_j)}+\lambda</script><p>上式两边同乘 $\pmb\pi_k$，可以得到 $\lambda=-N$，进而可以得到 $\pmb\pi_k$ 更简洁的表达式：</p>
<script type="math/tex; mode=display">
\pmb\pi_k=\frac{N_k}{N}</script></li>
</ol>
<p>这时候可以看到，要求的参数 $\{\pmb\pi_k,\pmb\mu_k,\pmb\Sigma_k\}$ 的表达式都包含了 $\gamma(z_{nk})$，而这一项的求解又依赖于 $\{\pmb\pi_k,\pmb\mu_k,\pmb\Sigma_k\}$ 的值，似乎陷入了循环。</p>
<p>所以可以先给 $\{\pmb\pi_k,\pmb\mu_k,\pmb\Sigma_k\}$ 一些初始值，之后计算 $\gamma(z_{nk})$ ，之后再计算 $\{\pmb\pi_k,\pmb\mu_k,\pmb\Sigma_k\}$ 。这就是EM算法求解GMM的流程了，把整个流程以算法的形式表示：</p>
<ul>
<li><p>E-step</p>
<script type="math/tex; mode=display">
\gamma(z_{nk})=\frac{\pi_k\mathcal{N}(\textbf{x}_n|\pmb \mu_k,\Sigma_k)}{\sum_j\pi_j\mathcal{N}(\textbf x_n|\pmb\mu_j,\pmb\Sigma_j)}</script></li>
<li><p>M-step</p>
<script type="math/tex; mode=display">
\begin{align*}
&\pmb\mu_k^{\text{new}}=\frac{1}{N_k}\sum_{n=1}^N\gamma(z_{nk})\textbf x_n\\
&\pmb\Sigma_k^{\text{new}}=\frac{1}{N_k}\sum_{n=1}^N\gamma(z_{nk})(\textbf x_n-\pmb\mu_k^{\text{new}})(\textbf x_n-\pmb\mu_k^{\text{new}})^T\\
&\pmb\pi_k^{\text{new}}=\frac{N_k}{N}
\end{align*}</script></li>
</ul>
<p>效果图如下：</p>
<p><img src="http://image.rexking6.top/img/clip1555749552.png" alt=""></p>
<h3 id="GMM的贝叶斯理解"><a href="#GMM的贝叶斯理解" class="headerlink" title="GMM的贝叶斯理解"></a>GMM的贝叶斯理解</h3><p>GMM模型表示为：</p>
<script type="math/tex; mode=display">
p(\textbf{x})=\sum_{k=1}^K\pmb\pi_k\mathcal N(\textbf x|\pmb\mu_k,\pmb\Sigma_k)</script><p>其中，$\pmb\pi_k$ 表示第 $k$ 个高斯模型的系数（权重），或者第 $k$ 类被选中的概率。我们引入一个 $k$ 维的随机变量 $z$。$z_k$ 表示它的第 $k$ 个维度，只能取1或0两个值。$z_k=1$ 表示第 $k$ 类被选中，$p(z_k=1)=\pmb\pi_k$。用概率图表示如下：</p>
<p><img src="http://image.rexking6.top/img/clip1555749819.png" alt=""></p>
<p>隐变量 $z$ 是独立同分布的，可以写出它的联合概率分布：</p>
<script type="math/tex; mode=display">
p(\textbf z)=p(z_1)p(z_2)\dots p(z_K)=\prod_{k=1}^K\pi_k^{z_k}</script><p>设样本被分为两类，则可以用条件概率来表示：</p>
<script type="math/tex; mode=display">
p(\textbf x|z_k=1)=\mathcal{N}(\textbf x|\pmb\mu_k,\pmb\Sigma_k)</script><p>综合以上两式，可以写成：</p>
<script type="math/tex; mode=display">
p(\textbf x|\textbf z)=\prod_{k=1}^K\mathcal{N}(\textbf x|\pmb\mu_k,\pmb\Sigma_k)^{z_k}</script><p>根据条件概率公式，求出 $p(\textbf x)$ 的形式：</p>
<script type="math/tex; mode=display">
p(\textbf x)=\sum_{\textbf z}p(\textbf z)p(\textbf x|\textbf z)=\sum_{k=1}^K\pmb\pi_k\mathcal N(\textbf x|\pmb\mu_k,\pmb\Sigma_k)</script><p>隐变量中的“隐”的意义是：我们知道数据可以分成两类，但是随机抽取一个数据点，不知道这个数据点属于第一类还是第二类，它的分类我们观察不到，因此引入一个隐含变量 $z$ 来描述这个现象。</p>
<p>注意到在贝叶斯的思想下， $p(\textbf z)$ 是先验概率，$p(\textbf x|\textbf z)$ 是似然概率，很自然我们会想到求出后验概率：</p>
<script type="math/tex; mode=display">
\begin{align*}
\gamma(z_k)&=p(z_k=1|\textbf x)\\
&=\frac{p(z_k=1)p(\textbf{x}|z_k=1)}{p(\textbf x|\textbf z)}\\
&=\frac{p(z_k=1)p(\textbf x|z_k=1)}{\sum_{j=1}^Kp(z_j=1)p(\textbf x|z_j=1)}(全概率公式)\\
&=\frac{\pmb\pi_k\mathcal{N}(\textbf{x}|\pmb\mu_k,\pmb\Sigma_k)}{\sum_{j=1}^K\pmb\pi_j\mathcal{N}(\textbf x|\pmb\mu_j,\pmb\Sigma_j)}
\end{align*}</script><p>上式的 $\gamma(z_k)$ 是对于一个样本而言。</p>
<h3 id="完备数据"><a href="#完备数据" class="headerlink" title="完备数据"></a>完备数据</h3><p><img src="http://image.rexking6.top/img/clip1555752229.png" alt=""></p>
<p>现在假设有 $N$ 个样本，$K$ 个类，则完备数据（有观测数据，即类别标签）的似然表示为：</p>
<script type="math/tex; mode=display">
p(\textbf X,\textbf Z|\pmb\mu, \pmb\Sigma, \pmb\pi)=\prod_{n=1}^N\prod_{k=1}^K\pi_k^{z_{nk}}\mathcal{N}(\textbf x_n|\pmb\mu_k,\pmb\Sigma_k)^{z_{nk}}</script><p>对数似然为：</p>
<script type="math/tex; mode=display">
\text{ln}p(\textbf X,\textbf Z|\pmb\mu, \pmb\Sigma, \pmb\pi)=\sum_{n=1}^N\sum_{k=1}^Kz_{nk}\{\text{ln}\pi_k+\text{ln}\mathcal{N}(\textbf x_n|\pmb\mu_k, \pmb\Sigma_k)\}</script><p>$z_{nk}$ 的期望值为：</p>
<script type="math/tex; mode=display">
\mathbb E[z_{nk}]=\frac{\pi_k\mathcal{N}(\textbf{x}_n|\pmb \mu_k,\Sigma_k)}{\sum_j\pi_j\mathcal{N}(\textbf x_n|\pmb\mu_j,\pmb\Sigma_j)}=\gamma(z_{nk})</script><p>则完备数据下对数似然的期望值为：</p>
<script type="math/tex; mode=display">
\mathbb{E}_{\textbf Z}[\text{ln }p(\textbf X,\textbf Z|\pmb\mu, \pmb\Sigma, \pmb\pi)]=\sum_{n=1}^N\sum_{k=1}^K\gamma(z_{nk})\{\text{ln} \pi_k+\text{ln}\mathcal{N}(\textbf x_n|\pmb\mu_k,\pmb\Sigma_k)\}</script><p>完备数据情况下，最大似然估计即可。</p>
<h3 id="非完备数据"><a href="#非完备数据" class="headerlink" title="非完备数据"></a>非完备数据</h3><p><img src="http://image.rexking6.top/img/clip1555752250.png" alt=""></p>
<ul>
<li><p>不引入隐变量<br>非完备数据的对数似然表示为：</p>
<script type="math/tex; mode=display">
\text{ln}p(\textbf X|\pmb\mu, \pmb\Sigma, \pmb\pi)=\sum_{n=1}^N\text{ln}\left\{\sum_{k=1}^K\pi_k\mathcal{N}(\textbf x_n|\pmb\mu_k,\pmb\Sigma_k)\right\}</script><p>​    之后求偏导。</p>
</li>
<li><p>引入隐变量<br>先给定隐变量 $\textbf Z$，之后按完备数据的最大似然求取。</p>
</li>
</ul>
<p>以上两种方法都能推导出EM。</p>
<h2 id="最大后验估计与EM"><a href="#最大后验估计与EM" class="headerlink" title="最大后验估计与EM"></a>最大后验估计与EM</h2><ol>
<li><p>初始化设置参数 $\pmb\theta^{\text{old}}$；</p>
</li>
<li><p>E-step计算 $p(\textbf Z|\textbf X,\pmb\theta^{\text{old}})$；</p>
</li>
<li><p>M-step计算</p>
<script type="math/tex; mode=display">
\pmb\theta^{\text{new}}=\text{arg max}_{\pmb\theta}\mathcal{Q}(\pmb\theta,\pmb\theta^{\text{old}})</script><p>其中，</p>
<script type="math/tex; mode=display">
\mathcal{Q}(\pmb\theta,\pmb\theta^{\text{old}})=\sum_{\textbf Z}p(\textbf Z|\textbf X,\pmb\theta^{\text{old}})\text{ln}p(\textbf X,\textbf Z|\pmb\theta)+\text{ln}p(\pmb\theta)</script></li>
</ol>
<h2 id="k-means与EM"><a href="#k-means与EM" class="headerlink" title="k-means与EM"></a>k-means与EM</h2><p>下图为生成的样本示意图，可以发现样本属于哪个分布不是hard的0-1，而是soft的[0, 1]概率。</p>
<p><img src="http://image.rexking6.top/img/clip1555751062.png" alt=""></p>
<p>可以发现上图其实与k-means有些相似，区别在于k-means是hard的0-1。所以说，k-means其实属于hard的EM算法。其中：</p>
<script type="math/tex; mode=display">
J=\sum_{n=1}^N\sum_{k=1}^Kr_{nk}||\textbf x_n-\pmb\mu_k||^2</script><p>E-step：</p>
<script type="math/tex; mode=display">
r_{nk}=\left\{\begin{aligned}&1&&\text{if }k=\text{arg min}_j||\textbf x_n-\pmb\mu_j||^2\\&0&&\text{otherwise.}\end{aligned}\right.</script><p>M-step：</p>
<script type="math/tex; mode=display">
\pmb\mu_k=\frac{\sum_nr_{nk}\textbf{x}_n}{\sum_nr_{nk}}</script><p><img src="http://image.rexking6.top/img/clip1555760448.png" alt=""></p>
<p>也可以将k-means从hard改为上述soft的混合高斯模型，即 $r_{nk}\in\{0,1\}$ 改为 $r_{nk}\in(0, 1)$，</p>
<script type="math/tex; mode=display">
p(\textbf x|\pmb\mu_k,\pmb\Sigma_k)=\frac{1}{(2\pi\epsilon)^{1/2}}\exp\left\{-\frac{1}{2\epsilon}||\textbf x-\pmb\mu_k||^2\right\}</script><p>隶属度为：</p>
<script type="math/tex; mode=display">
\gamma_{nk}=\frac{\pi_k\text{exp}\{-||\textbf x_n-\pmb\mu_k||^2/2\epsilon\}}{\sum_j\pi_j\text{exp}\{-||\textbf{x}_n-\pmb\mu_j||^2/2\epsilon\}}</script><p>期望为：</p>
<script type="math/tex; mode=display">
\mathbb{E}_\textbf Z[\text{ln}p(\textbf X,\textbf Z|\pmb\mu,\pmb\Sigma,\pmb\pi)]\rightarrow-\frac{1}{2}\sum_{n=1}^N\sum_{k=1}^Kr_{nk}||\textbf x_n-\pmb\mu_k||^2+\text{const}</script><h2 id="算法推导（收敛性）"><a href="#算法推导（收敛性）" class="headerlink" title="算法推导（收敛性）"></a>算法推导（收敛性）</h2><p>EM算法可以表示为下式：</p>
<p><img src="http://image.rexking6.top/img/clip1555827422.png" alt=""></p>
<p>其中 $\log p(X,Z|\theta)$ 可以看成一个随机变量的函数，而 $p(Z|X,\theta^{(t)})$ 是一个分布，这样积分后，就是期望，也就是E-step所做的；而M-step就是最大化该期望。</p>
<p>EM算法推导如下：</p>
<p>首先对于概率分布为 $p_\theta(x_i)$ 的 $n$ 次观测，我们将它添上隐变量 $z$，</p>
<script type="math/tex; mode=display">
p_\theta(x_i)\Rightarrow p_\theta(x_i,z)</script><p>之后取对数似然函数，</p>
<script type="math/tex; mode=display">
L(\theta)=\sum_{i=1}^n\ln p_\theta(x_i)</script><p>为了将隐变量 $z$ 强制暴露出来，将 $p_\theta(x_i)$ 化为 $p_\theta(x_i,z)$ 接着对 $z$ 求积分，可以得到：</p>
<script type="math/tex; mode=display">
L(\theta)=\sum_{i=1}^n\ln \sum_zp_\theta(x_i,z)</script><p>接下来要做的是求使 $L(\theta)$ 最大的 $\theta$ 值，</p>
<script type="math/tex; mode=display">
\theta^\ast=\text{arg max}_\theta\left\{\sum_{i=1}^n\text{ln}\sum_zp_\theta(x_i,z)\right\}</script><p>但由于此时 $L(\theta)$ 含有隐随机变量 $z$ ，直接找参数估计是困难的。我们的策略是建立 $L(\theta)$ 的下界，并求该下界的最大值，重复这个过程，直到收敛到局部最大值。</p>
<p>由上一步，已知不能直接最大化 $L(\theta)$，采用不断建立 $L(\theta)$ 的下界（E步），然后优化下界（M步）的方法。</p>
<p>具体如下：假定对于每一个 $x_i$ 样本，都有 $m$ 类的隐变量分布 $z_j$ ，并把隐变量 $z_j$ 的概率分布记为 $Q_i(z_j)$。已知，</p>
<script type="math/tex; mode=display">
L(\theta)=\sum_{i=1}^n\text{ln}\sum_{j=1}^mp_\theta(x_i,z_j)</script><p>为了将 $Q_i(z_j)$ 引入，就在求和公式里面乘以 $Q_i(z_j)$，再除以 $Q_i(z_j)$，</p>
<script type="math/tex; mode=display">
L(\theta)=\sum_{i=1}^n\text{ln}\sum_{j=1}^mQ_i(z_j)\frac{p_\theta(x_i,z_j)}{Q_i(z_j)}</script><p>为什么要这么做呢？根据Lazy Statistician规则：</p>
<blockquote>
<p><strong>Lazy Statistician规则：</strong></p>
<p>设 $Y$ 是随机变量 $X$ 的函数，$Y=g(X)$（$g$ 是连续函数），$X$ 是离散型随机变量，它的分布为 $p(X=x_k)=p_k$，其中 $k=1,2,\dots$。</p>
<p>若 $\sum_{k=1}^\infty g(x_k)p_k$ 的值绝对收敛，则有，</p>
<script type="math/tex; mode=display">
E(Y)=E(g(X))=\sum_{k=1}^\infty g(x_k)p_k</script></blockquote>
<p>所以，在引入 $Q_i(z_j)$ 以后，就得到了所要求的期望：</p>
<script type="math/tex; mode=display">
E\left[\frac{p_\theta(x_i,z_j)}{Q_i(z_j)}\right]=\sum_z Q_i(z_j)\frac{p_\theta(x_i,z_j)}{Q_i(z_j)}</script><p>接着，还需用到Jensen不等式：</p>
<blockquote>
<p><strong>Jensen不等式：</strong></p>
<p>若 $f$ 是凹函数， $X$ 是随机变量，那么</p>
<script type="math/tex; mode=display">
E(f(X))\ge f(E(X))</script><p>特别地，如果 $f$ 是严格凹函数，那么当且仅当 $P(x=E(X))=1$ 时取等号，此时 $X$ 为常量，有：</p>
<script type="math/tex; mode=display">
E(f(X))=f(E(X))</script><p>另：Jensen不等式应用于凸函数时，不等号方向反向，</p>
<script type="math/tex; mode=display">
E(f(X))\le f(E(X))</script></blockquote>
<p>根据Jensen不等式，分析如下，</p>
<script type="math/tex; mode=display">
\begin{align*}
\text{ln}\frac{p_\theta(x_i,z_j)}{Q_i(z_j)}&\Rightarrow f(X)\\
\sum_{j=1}^mQ_i(z_j)\text{ln}\frac{p_\theta(x_i,z_j)}{Q_i(z_j)}&\Rightarrow E[f(X)]\\
\sum_{j=1}^mQ_i(z_j)\frac{p_\theta(x_i,z_j)}{Q_i(z_j)}=E\left[\frac{p_\theta(x_i,z_j)}{Q_i(z_j)}\right]&\Rightarrow E[X]\\
\text{ln}\sum_{j=1}^mQ_i(z_j)\frac{p_\theta(x_i,z_j)}{Q_i(z_j)}=\ln E\left[\frac{p_\theta(x_i,z_j)}{Q_i(z_j)}\right]&\Rightarrow f(E[X])
\end{align*}</script><p>由于对数函数 $\text{ln}$ 是凸函数，根据Jensen不等式，</p>
<script type="math/tex; mode=display">
\text{ln}\sum_zQ_i(z_j)\frac{p_\theta(x_i,z_j)}{Q_i(z_j)}\ge\sum_zQ_i(z_j)\ln \frac{p_\theta(x_i,z_j)}{Q_i(z_j)}</script><p>添上求和符号：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\text{ln}\sum_{j=1}^mQ_i(z_j)\frac{p_\theta(x_i,z_j)}{Q_i(z_j)}\ge\sum_{i=1}^n\sum_{j=1}^mQ_i(z_j)\text{ln}\frac{p_\theta(x_i,z_j)}{Q_i(z_j)}</script><p>所以之前的最大似然为：</p>
<script type="math/tex; mode=display">
\theta^\ast=\text{arg max}_\theta\sum_{i=1}^n\sum_{j=1}^mQ_i(z_j)\text{ln}\frac{p(x_i,z_j)}{Q_i(z_j)}=\text{arg max}_\theta Q_i(z_j)\text{ln}p(x_i,z_j)</script><p>知道最大似然可以通过最大化其下界来求取，但是其中的 $Q_i(z_j)$ 具体是多少呢？</p>
<p>根据Jensen不等式，取等号的条件为：</p>
<script type="math/tex; mode=display">
\frac{p_\theta(x_i,z_j)}{Q_i(z_j)}=c</script><p>其中 $c$ 为常数，即</p>
<script type="math/tex; mode=display">
Q_i(z_j)=\frac{p(x_i,z_j)}{c}</script><p>对于每一个样本 $x_i$，$Q_i(z_j)$ 表示该样本隐含变量 $z$ 的某种分布，根据概率分布的性质可知，</p>
<script type="math/tex; mode=display">
\sum_{j=1}^mQ_i(z_j)=1</script><p>所以，</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{j=1}^m\frac{p(x_i,z_j)}{c}&=1\\
\frac{1}{c}\sum_{j=1}^mp(x_i,z_j)&=1\\
\sum_{j=1}^mp(x_i,z_j)&=c
\end{align*}</script><p>则，</p>
<script type="math/tex; mode=display">
Q_i(z_j)=\frac{p(x_i,z_j)}{c}=\frac{p(x_i,z_j)}{\sum_{j=1}^mp(x_i,z_j)}=\frac{p(x_i,z_j)}{p(x_i)}=p(z_j|x_i)</script><p>又，</p>
<script type="math/tex; mode=display">
Q_i(z_j)=p(z_j|x_i)=\frac{p(x_i,z_j)}{\sum_{j=1}^mp(x_i,z_j)}=\frac{p(z_j)p(x_i|z_j)}{\sum_{j=1}^mp(z_j)p(x_i|z_j)}</script><p>$Q_i(z_j)$ 的值我们已经知道了，代回最大似然推导：</p>
<script type="math/tex; mode=display">
\begin{align*}
\theta^\ast&=\text{arg max}_\theta\sum_{i=1}^n\sum_{j=1}^mQ_i(z_j)\ln p(x_i,z_j)\\
&=\text{arg max}_\theta\sum_{i=1}^nE_{Q_i(z)}[\ln p(x_i,z)]
\end{align*}</script><p>之后才是这一节的正题，收敛性。因为，</p>
<script type="math/tex; mode=display">
p(x)=\frac{p(x,z)}{p(z|x)}</script><p>所以，</p>
<script type="math/tex; mode=display">
\ln p(x|\theta)=\ln p(x,z|\theta)-\ln p(z|x,\theta)</script><p>所以，</p>
<script type="math/tex; mode=display">
E_{p(z|x,\theta^{(t)})}[\ln p(x|\theta)]=E_{p(z|x,\theta^{(t)})}[\ln p(x,z|\theta)-\ln p(z|x,\theta)]</script><p>所以，</p>
<script type="math/tex; mode=display">
\begin{align*}
\ln p(x|\theta)&=E_{p(z|x,\theta^{(t)})}[\ln p(x,z|\theta)-\ln p(z|x,\theta)]\\
&=\int_z[\ln p(x,z|\theta)]p(z|x,\theta^{(t)})dz-\int_z[\ln p(z|x,\theta)]p(z|x,\theta^{(t)})dz\\
&=Q(\theta,\theta^{(t)})-H(\theta,\theta^{(t)})
\end{align*}</script><p>因为，</p>
<script type="math/tex; mode=display">
\ln p(x|\theta^{(t+1)})\ge \ln p(x|\theta^{(t)})</script><p>所以，</p>
<script type="math/tex; mode=display">
Q(\theta^{(t+1)},\theta^{(t)})-H(\theta^{(t+1)},\theta^{(t)})\ge Q(\theta^{(t)},\theta^{(t)})-H(\theta^{(t)},\theta^{(t)})</script><p>所以我们要确定的是</p>
<script type="math/tex; mode=display">
\left\{\begin{align}&Q(\theta^{(t+1)},\theta^{(t)})\ge Q(\theta^{(t)},\theta^{(t)})\\&H(\theta^{(t+1)},\theta^{(t)})\le H(\theta^{(t)},\theta^{(t)})\end{align}\right.</script><p>由EM的迭代式，</p>
<script type="math/tex; mode=display">
\theta^{(t+1)}=\text{arg max}_\theta\int\ln p(X,Z|\theta)p(Z|X,\theta^{(t)})dZ=\text{arg max}_\theta Q(\theta,\theta^{(t)})</script><p>得，</p>
<script type="math/tex; mode=display">
Q(\theta^{(t+1)},\theta^{(t)})\ge Q(\theta,\theta^{(t)})</script><p>接下来证明 $H(\theta^{(t+1)},\theta^{(t)})\le H(\theta^{(t)},\theta^{(t)})$，</p>
<script type="math/tex; mode=display">
\text{If }H(\theta,\theta^{(t)})\le H(\theta^{(t)},\theta^{(t)})\ \forall\theta \text{, Then } H(\theta^{(t+1)},\theta^{(t)})\le H(\theta^{(t)},\theta^{(t)})</script><p>则，</p>
<script type="math/tex; mode=display">
\begin{align*}
&H(\theta^{(t)},\theta^{(t)})-H(\theta,\theta^{(t)})\\
=&\int_z[\ln p(z|x,\theta^{(t)})]p(z|x,\theta^{(t)})
dz-\int_z[\ln p(z|x,\theta)]p(z|x,\theta^{(t)})dz\\
=&\int_z\left[\ln \frac{p(z|x,\theta^{(t)})}{p(z|x,\theta)}\right]p(z|x,\theta^{(t)})dz\\
=&\int_z-\left[\ln \left(\frac{p(z|x,\theta)}{p(z|x,\theta^{(t)})}\right)\right]p(z|x,\theta^{(t)})dz\\
\ge&-\ln \int_z\left(\frac{p(z|x,\theta)}{p(z|x,\theta^{(t)})}\right)p(z|x,\theta^{(t)})dz \Leftarrow \text{Jensen不等式}\\
=&-\ln 1\\
=&0
\end{align*}</script><p>所以，</p>
<script type="math/tex; mode=display">
\left\{\begin{align}&Q(\theta^{(t+1)},\theta^{(t)})\ge Q(\theta^{(t)},\theta^{(t)})\\&H(\theta^{(t+1)},\theta^{(t)})\le H(\theta^{(t)},\theta^{(t)})\end{align}\right.\Rightarrow\ln p(x|\theta^{(t+1)})\ge\ln p(x|\theta^{(t)})</script><h2 id="硬币模型"><a href="#硬币模型" class="headerlink" title="硬币模型"></a>硬币模型</h2><p>有两个不均匀硬币A、B，每次实验抛10次，记录正面和反面次数。本例中记为 $H(head)$ 和 $T(tail)$，多次这样的实验后，预测硬币A和B各自的正面概率。</p>
<p><img src="http://image.rexking6.top/img/clip1555834385.png" alt=""></p>
<p>第一种情况是实验员记录了每次丢的是哪个硬币，没有隐变量，直接最大似然就可以算出A和B的正面概率 $\hat\theta_A,\hat\theta_B$。</p>
<p>A硬币丢了24+6=30次，其中24次正面 $\hat\theta_A=0.8$，$\hat\theta_B$  同理可计算。</p>
<p><img src="http://image.rexking6.top/img/clip1555834408.png" alt=""></p>
<p>第二种情况就是忘记记录每次丢的是A硬币还是B硬币了。我们将观测到的结果记录成以下的表格，并使用EM算法的公式计算。</p>
<p><img src="http://image.rexking6.top/img/clip1555834694.png" alt=""></p>
<p>上表中给出的是不同样本中出现”正面朝上“和“反面朝上”的次数，EM算法在本例中的计算公式为：</p>
<ul>
<li><p>E-step</p>
<script type="math/tex; mode=display">
Q_i(z_j)=\frac{p(z_j)p(x_i|z_j)}{\sum_{j=1}^mp(z_j)p(x_i|z_j)}</script></li>
<li><p>M-step</p>
<script type="math/tex; mode=display">
\theta^\ast=\text{arg max}_\theta\sum_{i=1}^n\sum_{j=1}^mQ_i(z_j)\text{ln}p(x_i,z_j)</script></li>
</ul>
<p><strong>计算过程为：</strong></p>
<p>首先随机给定两个 $\hat\theta_A,\hat\theta_B$，假设为0.6和0.5，硬币个数 $m=2$，使用A硬币和B硬币的概率分别为0.5，进行E-step计算。</p>
<ul>
<li>E-step</li>
</ul>
<script type="math/tex; mode=display">
\begin{align*}
&Q_i(z_j)=\frac{p(z_j)p(x_i|z_j)}{\sum_{j=1}^mp(z_j)p(x_i|z_j)},\ \theta_A=0.6,\ \theta_B=0.5,\ m=2,\ z_1=A, z_2=B, p(z_1)=p(z_2)=0.5\\
&Q_1(z_1)=\frac{p(z_1)p(x_1|z_1)}{p(z_1)p(x_1|z_1)+p(z_2)p(x_1|z_2)}=\frac{0.5\times0.6^5\times(1-0.6)^5}{0.5\times0.6^5\times(1-0.6)^5+0.5\times0.5^5\times(1-0.5)^5}=0.45\\
&Q_2(z_1)=\frac{p(z_1)p(x_2|z_1)}{p(z_1)p(x_2|z_1)+p(z_2)p(x_2|z_2)}=\frac{0.5\times0.6^9\times(1-0.6)^1}{0.5\times0.6^9\times(1-0.6)^1+0.5\times0.5^9\times(1-0.5)^1}=0.8\\
&Q_3(z_1)=\frac{p(z_1)p(x_3|z_1)}{p(z_1)p(x_3|z_1)+p(z_2)p(x_3|z_2)}=\frac{0.5\times0.6^8\times(1-0.6)^2}{0.5\times0.6^8\times(1-0.6)^2+0.5\times0.5^8\times(1-0.5)^2}=0.73\\
&Q_4(z_1)=\frac{p(z_1)p(x_4|z_1)}{p(z_1)p(x_4|z_1)+p(z_2)p(x_4|z_2)}=\frac{0.5\times0.6^4\times(1-0.6)^6}{0.5\times0.6^4\times(1-0.6)^6+0.5\times0.5^4\times(1-0.5)^6}=0.35\\
&Q_5(z_1)=\frac{p(z_1)p(x_5|z_1)}{p(z_1)p(x_5|z_1)+p(z_2)p(x_5|z_2)}=\frac{0.5\times0.6^7\times(1-0.6)^3}{0.5\times0.6^7\times(1-0.6)^3+0.5\times0.5^7\times(1-0.5)^3}=0.65\\
\end{align*}</script><p>得：</p>
<p><img src="http://image.rexking6.top/img/clip1555835488.png" alt=""></p>
<ul>
<li>M-step</li>
</ul>
<script type="math/tex; mode=display">
\begin{align*}
\theta^\ast&=\text{arg max}_\theta\sum_{i=1}^n\sum_{j=1}^mQ_i(z_j)\text{ln}p(x_i,z_j)\\
&=\text{arg max}_\theta\sum_{i=1}^n\left[Q_i(z_1)\text{ln}p(x_i,z_1)+Q_i(z_2)\text{ln}p(x_i,z_2)\right]\\
&=0.45\text{ln}\left[p(z_1)\theta_A^5(1-\theta_A)^5\right]+0.55\text{ln}\left[p(z_2)\theta_B^5(1-\theta_B)^5\right]\\
&+0.8\text{ln}\left[p(z_1)\theta_A^9(1-\theta_A)^1\right]+0.2\text{ln}\left[p(z_2)\theta_B^9(1-\theta_B)^1\right]\\
&+0.73\text{ln}\left[p(z_1)\theta_A^8(1-\theta_A)^2\right]+0.27\text{ln}\left[p(z_2)\theta_B^8(1-\theta_B)^2\right]\\
&+0.35\text{ln}\left[p(z_1)\theta_A^4(1-\theta_A)^6\right]+0.65\text{ln}\left[p(z_2)\theta_B^4(1-\theta_B)^6\right]\\
&+0.65\text{ln}\left[p(z_1)\theta_A^7(1-\theta_A)^3\right]+0.35\text{ln}\left[p(z_2)\theta_B^7(1-\theta_B)^3\right]\\
\end{align*}</script><p>算完一轮得到下表，例如 $Q_1(z_1)=0.45$ 实际抛掷中有5次正面朝上，所以期望为 $0.45\times 5=2.25$，</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">coin A</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1=2.2H, 2.2T</td>
</tr>
<tr>
<td style="text-align:center">2=7.2H, 0.8T</td>
</tr>
<tr>
<td style="text-align:center">3=5.9H, 1.5T</td>
</tr>
<tr>
<td style="text-align:center">4=1.4H, 2.1T</td>
</tr>
<tr>
<td style="text-align:center">5=4.5H, 1.9T</td>
</tr>
<tr>
<td style="text-align:center"><strong>all=21.3H, 8.6T</strong></td>
</tr>
</tbody>
</table>
</div>
<p>所有的计算出来以后，求 $\hat\theta_A, \hat\theta_B$：<strong>0.596</strong>是怎么计算的？</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}\hat\theta_A^{(1)}=\frac{21.3}{21.3+8.6}=0.71\\\hat\theta_B^{(1)}=\frac{11.7}{11.7+8.4}=0.58\end{aligned}\right.\Rightarrow p(z_1)=0.596</script><p>迭代多次后正面向上概率收敛，即为预测结果：</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}\hat\theta_A^{(10)}=0.80\\\hat\theta_B^{(10)}=0.52\end{aligned}\right.</script><h2 id="隐马尔可夫HMM与EM"><a href="#隐马尔可夫HMM与EM" class="headerlink" title="隐马尔可夫HMM与EM"></a>隐马尔可夫HMM与EM</h2><p><img src="http://image.rexking6.top/img/clip1555838040.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1555838055.png" alt=""></p>
<p>在参数学习问题中，依题意，我们写出未知参数的一些性质：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\theta = (A,B,\Pi),\ A=(a_{ij})_{n\times n},\ B=(b_{jk})_{n\times m},\ \Pi=(\pi_i)_{1\times n}\\
&\sum_{j=1}^na_{ij}=1,\ \sum_{k=1}^mb_{jk}=1,\ \sum_{i=1}^n\pi_i=1
\end{align*}</script><p>还有几个重要计算公式：</p>
<script type="math/tex; mode=display">
\gamma_t(i)=p(i_t=i|O,\lambda)=\frac{P(i_t=i,O|\lambda)}{P(O|\lambda)}=\frac{\alpha_t(i)\beta_t(i)}{\sum_{j=1}^N\left[\alpha_t(j)\beta_t(j)\right]}</script><script type="math/tex; mode=display">
\begin{align*}
\xi_t(i,j)&=P(i_t=i,i_{t+1}=j|O,\lambda)\\
&=\frac{P(i_t=i,i_{t+1}=j,O|\lambda)}{P(O|\lambda)}\\
&=\frac{\alpha_t(i)a_{ij}b_j(o_{t+1})\beta_{t+1}(j)}{\sum_{i=1}^N\sum_{j=1}^N\alpha_t(i)a_{ij}b_j(o_{t+1})\beta_{t+1}(j)}
\end{align*}</script><script type="math/tex; mode=display">
\gamma_t(i)=P(i_t=i|O,\lambda)=\sum_jP(i_t=i,i_{t+1}=j|O,\lambda)=\sum_j\xi_t(i,j)</script><p><strong>E-step：</strong></p>
<p>已知：</p>
<script type="math/tex; mode=display">
P(X,Z)=P(Z_1)\prod_{t=1}^{T-1}P(Z_{t+1}|Z_t)\prod_{t=1}^TP(X_t|Z_t)</script><p>其中，$Z_t\in\{1,2,\dots,n\}$，$X_t\in\{1,2,\dots,m\}$。求状态序列的分布为：</p>
<script type="math/tex; mode=display">
Q(Z)=P(Z|X,\theta^{(t)})=\frac{P(X,Z)}{\sum_ZP(X,Z)}</script><p><strong>M-step：</strong></p>
<p>最大似然如下：</p>
<script type="math/tex; mode=display">
\theta^{(t+1)}=\text{arg max}_\theta L</script><p>其中，</p>
<script type="math/tex; mode=display">
\begin{align*}
L&=\sum_ZQ(Z|\theta^{(t)})\text{ln}P(X,Z|\theta)\\
&=\sum_ZQ(Z|\theta^{(t)})\left(\text{ln}P(Z_1)+\sum_{t=1}^{T-1}\text{ln}P(Z_{t+1}|Z_t)+\sum_{t=1}^T\text{ln}P(X_t|Z_t)\right)
\end{align*}</script><p>$L$ 分别对 $\Pi, A, B$ 分别求偏导，并令偏导等于零，则可求出 $\theta^{(t+1)}$。</p>
<ul>
<li>$\Pi$</li>
</ul>
<script type="math/tex; mode=display">
\begin{align*}
L(\pi,\lambda)&=\sum_{Z_{1,\dots,T}}Q(Z|\theta^{(t)})\text{ln}P(Z_1)+\lambda\left(1-\sum_{i=1}^n\pi_i\right)\\
&=\sum_{Z_1}Q(Z_1|\theta^{(t)})\text{ln}P(Z_1)+\lambda\left(1-\sum_{i=1}^n\pi_i\right)\\
&=\sum_{i=1}^nQ(Z_1=i|\theta^{(t)})\text{ln}P(Z_1=i)+\lambda\left(1-\sum_{i=1}^n\pi_i\right)\\
&=\sum_{i=1}^n\gamma_1(i)\text{ln}\pi_i+\lambda\left(1-\sum_{i=1}^n\pi_i\right)
\end{align*}</script><p>求偏导：</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial \pi_i}L(\pi, \lambda)=\frac{\gamma_1(i)}{\pi_i}-\lambda=0\Rightarrow\pi_i=\frac{\gamma_1(i)}{\lambda}</script><p>因为，</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\pi_i=1\Rightarrow\lambda=\sum_{i=1}^n\gamma_1(i)\Rightarrow\pi_i=\frac{\gamma_1(i)}{\sum_{i=1}^n\gamma_1(i)},\ i=1,2,\dots,n</script><ul>
<li>$A$</li>
</ul>
<script type="math/tex; mode=display">
\begin{align*}
L(A,\lambda)&=\sum_{Z_{1,\dots,T}}Q(Z|\theta^{(t)})\sum_{t=1}^{T-1}\text{ln}P(Z_{t+1}|Z_t)+\lambda\left(1-\sum_{j=1}^na_{ij}\right)\\
&=\sum_{t=1}^{T-1}\sum_{i=1}^n\sum_{j=1}^nQ(Z_t=i,Z_{t+1}=j|\theta^{(t)})\text{ln}P(Z_{t+1}=j|Z_t=j)+\lambda\left(1-\sum_{j=1}^na_{ij}\right)\\
&=\sum_{t=1}^{T-1}\sum_{i=1}^n\sum_{j=1}^n\xi_t(i,j)\text{ln}a_{ij}+\lambda\left(1-\sum_{j=1}^na_{ij}\right)
\end{align*}</script><p>求偏导：</p>
<script type="math/tex; mode=display">
\frac{\partial }{\partial a_{ij}}L(A,\lambda)=\frac{\sum_{t=1}^{T-1}\xi_t(i,j)}{a_{ij}}-\lambda=0\Rightarrow a_{ij}=\frac{\sum_{t=1}^{T-1}\xi_t(i,j)}{\lambda}</script><p>因为，</p>
<script type="math/tex; mode=display">
\sum_{j=1}^na_{ij}=1\Rightarrow\lambda=\sum_{t=1}^{T-1}\gamma_t(i)\Rightarrow a_{ij}=\frac{\sum_{t=1}^{T-1}\xi_t(i,j)}{\sum_{t=1}^{T-1}\gamma_t(i)},\ i,j=1,2,\dots,n</script><ul>
<li>$B$</li>
</ul>
<script type="math/tex; mode=display">
\begin{align*}
L(B,\lambda)&=\sum_{Z_{1,\dots,T}}Q(Z|\theta^{(y)})\sum_{t=1}^T\text{ln}P(X_t|Z_t)+\lambda\left(1-\sum_{k=1}^mb_{jk}\right)\\
&=\sum_{t=1}^T\sum_{j=1}^n\sum_{k=1}^mQ(Z_t=j,X_t=k|\theta^{(t)})\text{ln}P(X_t|Z_t=j)+\lambda\left(1-\sum_{k=1}^mb_{jk}\right)\\
&=\sum_{t=1}^T\sum_{j=1}^n\sum_{k=1}^mQ(Z_t=j,X_t=k|\theta^{(t)})\text{ln}b_{jk}+\lambda\left(1-\sum_{k=1}^mb_{jk}\right)
\end{align*}</script><p>求偏导：</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial b_{jk}}L(B,\lambda)=\frac{\sum_{t=1}^TQ(Z_t=j,X_t=k|\theta^{(t)})}{b_{jk}}-\lambda=0\Rightarrow b_{jk}=\frac{\sum_{t=1}^TQ(Z_t=j,X_t=k|\theta^t)}{\lambda}</script><p>因为，</p>
<script type="math/tex; mode=display">
\sum_{k=1}^mb_{jk}=1\Rightarrow\lambda=\sum_{t=1}^TQ(Z_t=j|\theta^{(t)})=\sum_{t=1}^T\gamma_t(j)\Rightarrow b_{jk}=\frac{\sum_{t=1,X_t=k}^T\gamma_t(j)}{\sum_{t=1}^{T-1}\gamma_t(j)}</script><h2 id="混合伯努利模型与EM"><a href="#混合伯努利模型与EM" class="headerlink" title="混合伯努利模型与EM"></a>混合伯努利模型与EM</h2><p>列出伯努利模型概率分布以及均值和协方差：</p>
<ul>
<li><p>单个模型：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(\textbf x|\pmb\mu)&=\prod_{i=1}^D\mu_i^{x_i}(1-\mu_i)^{(1-x_i)}\\
\mathbb{E}[\textbf x]&=\pmb\mu\\
\text{cov}[\textbf x]&=\text{diag}\{\mu_i(1-\mu_i)\}
\end{align*}</script></li>
<li><p>混合模型：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(\textbf x|\pmb\mu,\pmb\pi)&=\sum_{k=1}^K\pi_kp(\textbf x|\pmb\mu_k)\\
p(\textbf x|\pmb\mu_k)&=\prod_{i=1}^D\mu_{ki}^{x_i}(1-\mu_{ki})^{(1-x_i)}\\
\mathbb E[\textbf x]&=\sum_{k=1}^K\pi_k\pmb\mu_k\\
\text{cov}[\textbf x]&=\sum_{k=1}^K\pi_k\{\pmb\Sigma_k+\pmb\mu_k\pmb\mu_k^T\}-\mathbb E[\textbf x]E[\textbf x]^T
\end{align*}</script></li>
</ul>
<p>则对数似然函数为：</p>
<script type="math/tex; mode=display">
\text{ln}p(\textbf X|\pmb\mu,\pmb\pi)=\sum_{n=1}^N\text{ln}\left\{\sum_{k=1}^K\pi_kp(\textbf x_n|\pmb\mu_k)\right\}</script><p>引入隐变量：</p>
<script type="math/tex; mode=display">
p(\textbf x|\textbf z,\pmb\mu)=\prod_{k=1}^Kp(\textbf x|\pmb\mu_k)^{z_k}\\
p(\textbf z|\pmb\pi)=\prod_{k=1}^K\pi_k^{z_k}</script><p>完备数据下的对数似然为：</p>
<script type="math/tex; mode=display">
\text{ln}p(\textbf X, \textbf Z|\pmb\mu,\pmb\pi)=\sum_{n=1}^N\sum_{k=1}^Kz_{nk}\left\{\text{ln}\pi_k+\sum_{i=1}^D[x_{ni}\text{ln}\mu_{ki}+(1-x_{ni})\text{ln}(1-\mu_{ki})]\right\}</script><p>上式的期望：</p>
<script type="math/tex; mode=display">
\mathbb{E}[\text{ln}p(\textbf X, \textbf Z|\pmb\mu,\pmb\pi)]=\sum_{n=1}^N\sum_{k=1}^K\gamma(z_{nk})\left\{\text{ln}\pi_k+\sum_{i=1}^D[x_{ni}\text{ln}\mu_{ki}+(1-x_{ni})\text{ln}(1-\mu_{ki})]\right\}</script><p><strong>E-step：</strong></p>
<script type="math/tex; mode=display">
\gamma(z_{nk})=\mathbb E[z_{nk}]=\frac{\sum_{z_{nk}}z_{nk}[\pi_kp(\textbf x_n|\pmb\mu_n)]^{z_{nk}}}{\sum_{z_{nj}}[\pi_jp(\textbf x_n|\pmb\mu_j)]^{z_{nj}}}=\frac{\pi_kp(\textbf x_n|\pmb\mu_k)}{\sum_{j=1}^K\pi_jp(\textbf x_n|\pmb\mu_j)}</script><p><strong>M-step：</strong></p>
<script type="math/tex; mode=display">
\pmb\mu_k=\overline{\textbf{x}},\ \pi_k=\frac{N_k}{N},\ N_k=\sum_{n=1}^N\gamma(z_{nk}),\ \overline{\textbf{x}}_k=\frac{1}{N_k}\sum_{n=1}^N\gamma(z_{nk})\textbf{x}_n</script><h2 id="广义EM算法（GEM）"><a href="#广义EM算法（GEM）" class="headerlink" title="广义EM算法（GEM）"></a>广义EM算法（GEM）</h2><p>广义期望最大算法（Generalized Expectation Maximization）是EM算法的推广。</p>
<p>EM算法中引入的是隐变量，如果将隐变量理解为隐分布，就得到了广义EM算法，它是在数据不完全或者存在缺失变量的情况下参数估计的迭代算法。</p>
<p>由EM算法中我们可以知道含有隐变量 $z$ 后事件分布规律可以写为：</p>
<script type="math/tex; mode=display">
p(\textbf X|\pmb\theta)=\frac{p(\textbf X,\textbf Z|\pmb\theta)}{p(\textbf Z|\textbf X,\pmb\theta)}</script><p>所以，</p>
<script type="math/tex; mode=display">
\begin{align*}
&\text{ln}p(\textbf X|\pmb\theta)\\
=&\int q(\textbf Z)\text{ln}p(\textbf X|\pmb\theta)d\textbf Z\\
=&\int q(\textbf Z)\text{ln}\frac{p(\textbf X,\textbf Z|\pmb\theta)q(\textbf Z)}{p(\textbf Z|\textbf X,\pmb\theta)q(\textbf Z)}d\textbf Z\\
=&\int q(\textbf Z)\text{ln}\frac{p(\textbf X,\textbf Z|\pmb\theta)}{q(\textbf Z)}d\textbf Z-\int q(\textbf Z)\text{ln}\frac{p(\textbf Z|\textbf X,\pmb\theta)}{q(\textbf Z)}d\textbf Z\\
=&\mathcal L(q,\pmb\theta)+\text{KL}(q||p)
\end{align*}</script><blockquote>
<p>KL距离（Kullback-Leiblier Divergence）也叫相对熵（Relative Entropy）。它衡量的是相同事件空间里的两个概率分布的差异情况。其物理意义是：在相同事件空间里，概率分布 $P(x)$ 对应的每个事件，若用概率分布 $Q(x)$ 编码时，平均每个基本事件（符号）编码长度增加了多少比特。我们用 $D(P||Q)$ 表示KL距离，计算公式：</p>
<script type="math/tex; mode=display">
D(P||Q)=\sum_{x\in X}P(x)\text{ln}\frac{P(x)}{Q(x)}</script></blockquote>
<p>可以看到对数似然被分解成了两部分，一个是下界 $\mathcal L(q,\pmb\theta)$，另一个是KL距离。如下图所示：</p>
<p><img src="http://image.rexking6.top/img/clip1555896714.png" alt=""></p>
<p>也就是说，只要令KL距离为0，那么 $\mathcal L(q,\pmb\theta)$ 就等于似然度的值了，此时再找到 $\pmb\theta$ 使得 $\mathcal L(q,\pmb\theta)$ 最大就好。</p>
<p><img src="http://image.rexking6.top/img/clip1555897139.png" alt=""></p>
<p>而最大化这个 $\mathcal L(q,\pmb\theta)$ 比较简单，首先，</p>
<script type="math/tex; mode=display">
q(\textbf Z)=p(\textbf Z|\textbf X,\pmb\theta^{\text{old}})</script><p>将其代入到 $\mathcal L(q,\theta)$，</p>
<script type="math/tex; mode=display">
\begin{align*}
&\mathcal L(q,\pmb\theta)\\
=&\sum_{\textbf Z}p(\textbf Z|\textbf X,\pmb\theta^{\text{old}})\text{ln}p(\textbf X,\textbf Z|\pmb\theta)-\sum_{\textbf Z}p(\textbf Z|\textbf X,\pmb\theta^{\text{old}})\text{ln}p(\textbf Z|\textbf X,\pmb\theta^{\text{old}})\\
=&\mathcal Q(\pmb\theta,\pmb\theta^{\text{old}})+\text{const}
\end{align*}</script><p>所以只要对 $\mathcal Q(\pmb\theta,\pmb\theta^{\text{old}})$ 最大化就可以了。</p>
<p>总体流程如下：</p>
<ul>
<li><p>E-step：</p>
<p><img src="http://image.rexking6.top/img/clip1555898311.png" alt=""></p>
<p>初始化参数为 $\pmb\theta^{\text{old}}$，计算 $q(\textbf Z)$，</p>
<script type="math/tex; mode=display">
q(\textbf Z)=p(\textbf Z|\textbf X,\pmb\theta^{\text{old}})</script><p>把KL设为0，蓝色的线往上移使得 $\mathcal L(q,\theta)=$似然度。</p>
</li>
</ul>
<ul>
<li><p>M-step：</p>
<p><img src="http://image.rexking6.top/img/clip1555898435.png" alt=""></p>
<p>最大化 $\mathcal L(q,\theta)$ ，将参数更新成 $\pmb\theta^{\text{new}}$，</p>
<script type="math/tex; mode=display">
\pmb\theta^{\text{new}}=\text{arg max}\mathcal Q(\pmb\theta,\pmb\theta^{\text{old}})\\
\mathcal Q(\pmb\theta,\pmb\theta^{\text{old}})=\sum_\textbf Zp(\textbf Z|\textbf X,\pmb\theta^{\text{old}})\text{ln}p(\textbf X,\textbf Z|\pmb\theta)</script><p>此时对数似然函数的值也得到了上升，这样重复进行下去，可以收敛到一个局部极值。</p>
</li>
</ul>
<p>总的效果图如下图所示：</p>
<p><img src="http://image.rexking6.top/img/clip1555898162.png" alt=""></p>
<h2 id="VBEM"><a href="#VBEM" class="headerlink" title="VBEM"></a>VBEM</h2><p>变分EM算法。当遇到比较复杂的、高维的概率图模型时，有可能是树状的、环状的，这时候求其后验分布就比较困难了。这时候有下面两种方法：</p>
<ol>
<li>采样，采样需要知道模型，之后可以通过积分求出；</li>
<li>变分EM，基于独立性简化计算的假设，将复杂的高维空间分解成低维空间，将其变成一个最优化问题。</li>
</ol>
<h1 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h1><p>集成学习是指通过训练多个分类器，然后将这些分类器组合起来，来获得比单个分类器更有的性能（比最好的那个分类器还要好）。如果每个分类器都是同种类型的（比如都是决策树或都是SVM等等），那么这些单个的分类器称为基学习器；如果继承中包含不同类型的分类器，这样的集成是异质的。需要注意的是，这些单个的分类器不一定要很好，只需要比随机猜测好就可以。在我们一般的经验中，如果把好的东西与坏的东西掺杂在一起，那么结果通常是比最坏的要好但比最好的要差一些，但是集成学习可以获得比最好的单一学习器更好的性能。</p>
<p>集成学习的发展历史：</p>
<p><img src="http://image.rexking6.top/img/clip1556155681.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1556160271.png" alt=""></p>
<h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><h3 id="CART框架"><a href="#CART框架" class="headerlink" title="CART框架"></a>CART框架</h3><p>CART使用基尼指数来选择划分。基尼指数反映的是从数据集 $D$ 中随机抽取两个样本，其类别标签不一致的概率。因此基尼指数越少，数据集 $D$ 包含的信息量越少。CART在候选特征集中选取一个特征，使得划分后基尼指数最小。</p>
<ul>
<li><p>分类举例：</p>
<p><img src="http://image.rexking6.top/img/clip1556155844.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1556155832.png" alt=""></p>
<p>根据决策树，将下面的区域分成四块，分别是 $X_2\le0.7,X_1\le-1.4;X_2\le0.7,X_1&gt;-1.4;X_2&gt;0.7,X_1\le-0.6;X_2&gt;0.7,X_1&gt;0.6$。</p>
</li>
<li><p>回归举例：</p>
<p><img src="http://image.rexking6.top/img/clip1556155969.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1556155982.png" alt=""></p>
<script type="math/tex; mode=display">
s^\ast=\text{arg min}_s\left\{\text{min}_{c_1}\sum_{x_i\le s}(y_i-c_1)^2+\text{min}_{c_2}\sum_{x_i>s}(y_i-c_2)^2\right\}</script></li>
</ul>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>分类决策树模型是一种描述对实例进行分类的树形结构，决策树由结点和有向边组成。结点有两种类型：内部结点和叶结点。内部结点表示一个特征或属性，叶节点表示一个类。用决策树分类，从根节点开始，对实例的某一特征进行测试，根据测试结果，将实例分配到其子结点；这时，每一个子结点对应着该特征的一个取值。如果递归地对实例进行测试并分配，直至达到叶结点。最后将实例分到叶结点的类中。</p>
<p>我们可以将决策树看成一个if-then规则的集合，转换成if-then规则的过程：由决策树的根结点到叶结点的每一条路径构建一条规则；路径上内部结点的特征对应着规则的条件，而叶结点的类对应着规则的结论。决策树的路径或其对应的if-then规则集合具有一个重要的性质：互斥并且完备，每一个实例都被一条路径或一条规则所覆盖，而且只被一条路径或一条规则所覆盖。</p>
<p><img src="http://image.rexking6.top/img/clip1556157498.png" alt=""></p>
<p>而分类决策树与回归决策树的区别是：分类构建的决策树的叶结点是一个类别，叶结点中哪个类别的训练样本数量最多，叶结点的类别就取这个类别（由于剪枝早停等优化，叶结点不一定纯，该方法即最大后验概率MAP）。而回归的叶结点是一个值，与目标取值集合是类别的分类问题不同的是，回归的目标取值集合是一个数值集合，对于一个叶结点有一个相对训练样本固定的输出值，这个值通常取叶结点中包含的所有训练样本的均值。特别的，回归在树划分的时候选取的准则是特有的方差度量。这里所谓覆盖是指实例的特征与路径上的特征一致或实例满足规则的条件。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>高精度、稳定</li>
<li>可解释性高</li>
<li>非线性</li>
<li>适用于解决分类或回归问题</li>
<li>既适用于分类的离散变量，也适用于连续的输入和输出变量</li>
</ul>
<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>特征选择，即每一步划分时选择哪个属性进行划分，选择的依据是什么正是解决这个问题的关键。定义每个阶段的划分纯不纯，从上个阶段到以某个属性划分后的下个阶段纯度增加得多还是少，这里列举三种常用准则（另外还有卡方检验等）：信息增益/信息增益率（分类）、基尼增益（分类）、方差度量（回归）。</p>
<h4 id="信息增益-信息增益率（ID3-C4-5）"><a href="#信息增益-信息增益率（ID3-C4-5）" class="headerlink" title="信息增益/信息增益率（ID3/C4.5）"></a>信息增益/信息增益率（ID3/C4.5）</h4><p><strong>补充：熵、交叉熵、联合熵、条件熵、相对熵、互信息</strong></p>
<ul>
<li>设 $X$ 是一个取有限个值的离散随机变量，其概率分布为：</li>
</ul>
<script type="math/tex; mode=display">
p(X=x_i)=p_i,\ i=1,2,\dots,n</script><p>则随机变量 $X$ 的熵定义为：</p>
<script type="math/tex; mode=display">
H(X)=-\sum_{i=1}^Np_i\text{log}p_i</script><p>又记，</p>
<script type="math/tex; mode=display">
H(p)=-\sum_{i=1}^Np_i\text{log}p_i=\sum_{i=1}^Np_i\text{log}\frac{1}{p_i}=E\left[\text{log}\frac{1}{p_i}\right]</script><ul>
<li>对于 $p, q$ 两个分布，交叉熵的定义为：</li>
</ul>
<script type="math/tex; mode=display">
H(p,q)=-\sum_{i=1}^Np_i\text{log}q_i</script><ul>
<li>联合熵的定义为：</li>
</ul>
<script type="math/tex; mode=display">
\begin{align*}
&H(X,Y)\\
=&-\sum_{x\in X}\sum_{y\in Y}p(x,y)\text{log}p(x,y)\\
=&-E_{(X,Y)-p(x,y)}[\text{log}p(X,Y)]
\end{align*}</script><p>条件熵 $H(Y|X)$ 表示在已知随机变量 $X$ 的条件下随机变量 $Y$ 的不确定性。随机变量 $X$ 给定的条件下随机变量 $Y$ 的条件熵（conditional entropy）$H(Y|X)$，定义为 $X$ 给定条件下 $Y$ 的条件概率分布的熵对 $X$ 的数学期望：</p>
<script type="math/tex; mode=display">
\begin{align*}
&H(Y|X)\\
=&-\sum_{x\in X}p(X=x)H(Y|X=x)\\
=&-\sum_{x\in X}p(x)H(Y|X=x)\\
=&-\sum_{x\in X}p(x)\sum_{y\in Y}p(Y=y|X=x)\text{log}p(Y=y|X=x)\\
=&-\sum_{x\in X}p(x)\sum_{y\in Y}p(y|x)\text{log}p(y|x)\\
=&-\sum_{x\in X}\sum_{y\in Y}p(x,y)\text{log}p(y|x)\\
=&-E_{(X,Y)-p(x,y)}[\text{log}p(Y|X)]\\
=&-E_{p(x,y)}[\text{log}p(Y|X)]
\end{align*}</script><p>当熵和条件熵中的概率由数据估计（特别是极大似然估计）得到时，所对应的熵与条件熵分别称为经验熵和经验条件熵。</p>
<ul>
<li><strong>联合熵与条件熵之间的关系</strong></li>
</ul>
<script type="math/tex; mode=display">
H(X,Y)=H(X)+H(Y|X)</script><p>证明：</p>
<script type="math/tex; mode=display">
\begin{align*}
H(X,Y)&=-\sum_{x\in X}\sum_{y\in Y}p(x,y)\text{log}p(x,y)\\
&=-\sum_{x\in X}\sum_{y\in Y}p(x,y)\text{log}p(x)p(y|x)\\
&=-\sum_{x\in X}\sum_{y \in Y}p(x,y)\text{log}p(x)-\sum_{x\in X}\sum_{y\in Y}p(x,y)\text{log}p(y|x)\\
&=-\sum_{x\in X}p(x)\text{log}p(x)-\sum_{x\in X}\sum_{y\in Y}p(x,y)\text{log}p(y|x)\\
&=H(X)+H(Y|X)
\end{align*}</script><ul>
<li>相对熵（Kullack-Leibler距离）：度量两个分布之间的距离、</li>
</ul>
<script type="math/tex; mode=display">
D(p||q)=\sum_{x\in X}p(x)\text{log}\frac{p(x)}{q(x)}=E_{p(x)}\left[\text{log}\frac{p(X)}{q(X)}\right]</script><ul>
<li>互信息（Mutual Information）</li>
</ul>
<script type="math/tex; mode=display">
\begin{align*}
I(X;Y)&=\sum_{x\in X}\sum_{y\in Y}p(x,y)\text{log}\frac{p(x,y)}{p(x)p(y)}\\
&=E_{p(x,y)}\left[\text{log}\frac{p(X,Y)}{p(X)p(Y)}\right]\\
&=D(p(x,y)||p(x)p(y))
\end{align*}</script><ul>
<li><strong>互信息与熵</strong><script type="math/tex; mode=display">
\begin{align*}
I(X;Y)&=\sum_{x\in X}\sum_{y\in Y}p(x,y)\text{log}\frac{p(x,y)}{p(x)p(y)}\\
&=\sum_{x\in X}\sum_{y\in Y}p(x,y)\text{log}\frac{p(x|y)}{p(x)}\\
&=-\sum_{x\in X}\sum_{y\in Y}p(x,y)\text{log}p(x)+\sum_{x\in X}\sum_{y\in Y}p(x,y)\text{log}p(x|y)\\
&=H(X)-H(X|Y)
\end{align*}</script></li>
</ul>
<ul>
<li>$I(X;Y)=H(X)-H(X|Y)$</li>
<li>$I(X;Y)=H(Y)-H(Y|X)$</li>
<li>$I(X;Y)=H(X)+H(Y)-H(X,Y)$</li>
</ul>
<hr>
<p>对于一个样本数量为 $D$，类别数量为 $N$ 的集合 $D$，该集合的熵定义为：</p>
<script type="math/tex; mode=display">
H(D)=-\sum_{i=1}^Np_i\text{log}p_i</script><p>将该集合以某个属性 $A$ 划分一次，划分后的总熵为：</p>
<script type="math/tex; mode=display">
H(D|A)=\sum_{i\in\{L,R\}}\frac{|D^i|}{|D|}H(D^i)</script><p>假设将该集合以某个属性 $A$ 划分一次，得到两个样本数量分别为 $C_1$ 和 $C_2$ 的集合，则划分后的总熵为</p>
<script type="math/tex; mode=display">
H(D|A)=-\frac{C_1}{D}\sum_{i=1}^{N_1}p_i\text{log}p_i-\frac{C_2}{D}\sum_{i=1}^{N_2}p_i\text{log}p_i</script><p>即两个集合各自求本集合的熵，再计算加权平均和作为整个的熵，对于多分类，也是同理进行加权平均。那么，信息增益定义如下：</p>
<script type="math/tex; mode=display">
g(D;A)=H(D)-H(D|A)</script><ul>
<li>决策树中的信息增益等价于训练数据集中类与特征的互信息。</li>
<li>熵随着分支的进行应该越来越小，因此以某个特征进行划分，不同的特征往往具有不同的信息增益，信息增益大的特征具有更强的分类能力。</li>
</ul>
<p><img src="http://image.rexking6.top/img/clip1556199922.png" alt=""></p>
<p>假设某个属性 $X$，分裂前熵=10.0，分裂后=6.0，I=10.0-6.0=4.0；某个属性 $Y$，分裂前熵=4.0，分裂后=0.2，I=4.0-0.2=3.8。由上面这个例子可以看出，用信息增益的方式选择，存在偏向于选择取值比较多的特征的问题，因此便出现了信息增益率来作为一种补偿方案。</p>
<p>信息增益率的定义为：</p>
<script type="math/tex; mode=display">
IGR=\frac{H(D)-\sum_{i\in\{L,R\}}\frac{|D^i|}{|D|}H(D^i)}{-\sum_{i\in\{L,R\}}\frac{|D^i|}{|D|}H(D^i)}</script><h4 id="Gini基尼指数（CART）"><a href="#Gini基尼指数（CART）" class="headerlink" title="Gini基尼指数（CART）"></a>Gini基尼指数（CART）</h4><p>基尼指数的定义：</p>
<script type="math/tex; mode=display">
Gini(p)=\sum_{k=1}^Kp_k(1-p_k)=1-\sum_{k=1}^kp_k^2</script><p>类似于信息增益，将该集合以某个属性 $A$ 划分一次，划分后的Gini指数为：</p>
<script type="math/tex; mode=display">
Gini(D|A)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)</script><p><strong>Gini指数 vs 熵</strong></p>
<ul>
<li>Gini 指数的计算不需要对数运算，更加高效；</li>
<li>Gini 指数更偏向于连续属性，熵更偏向于离散属性。</li>
</ul>
<h4 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h4><p>利用方差定义数据之间的关系时显然有：方差越小，数据之间的关系越紧密，即这些数据之间相似度高。</p>
<p>假设现在按 $s$ 为间隔划分成两类：</p>
<script type="math/tex; mode=display">
\begin{align*}
&R_1(j,s)=\{x|x_j\le s\},\\
&R_2(j,s)=\{x|x_j>s\}.
\end{align*}</script><p>方差度量准则表达式为：</p>
<script type="math/tex; mode=display">
\text{min}_{j,s}\left[ \underbrace{\text{min}_{c_1}\sum_{x_i\in R_1(j,s)}(y_i-c_1)^2}_{\hat c_1=ave(y_i|x_i\in R_1(j,s))}+\underbrace{\text{min}_{c_2}\sum_{x_i\in R_2(j,s)}(y_i-c_2)^2}_{\hat c_2=ave(y_i|x_i\in R_2(j,s))}\right]</script><p>即每次划分要使划分的两类的均方差各自达到最小且两者的和也要最小。</p>
<h3 id="树的生成"><a href="#树的生成" class="headerlink" title="树的生成"></a>树的生成</h3><h4 id="结点的取值情况？"><a href="#结点的取值情况？" class="headerlink" title="结点的取值情况？"></a>结点的取值情况？</h4><p>最常见的决策树模型ID3是多叉树，即属性由几类取值就分为几叉，但二叉树更简单，CART模型就是采用的二叉树，实际上任何多叉树都可以转化为二叉树，即对于多于两个取值的属性，通过yes/no询问，一次只划分出某类和非某类两类，然后继续对非某类进行更细致的划分。</p>
<p><img src="http://image.rexking6.top/img/clip1556242972.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1556242990.png" alt=""></p>
<h4 id="采用哪个属性进行测试？"><a href="#采用哪个属性进行测试？" class="headerlink" title="采用哪个属性进行测试？"></a>采用哪个属性进行测试？</h4><ul>
<li>不纯度准则</li>
</ul>
<p>不纯度准则选择上，分类和回归各有特有准则，由于回归通常就用方差度量，这里对比一下分类问题使用的熵、基尼指数和基本的误分类不纯度（分类误差率）之间的关系。</p>
<p><img src="http://image.rexking6.top/img/clip1556243341.png" alt=""></p>
<p>其中，误分类的不纯度定义为：</p>
<script type="math/tex; mode=display">
i(N)=1-\text{max}_jp(C_j|N)</script><p>熵定义为：</p>
<script type="math/tex; mode=display">
i(N)=-\sum_jp(C_j|N)\text{log}_2p(C_j|N)</script><p>Gini不纯度定义为：</p>
<script type="math/tex; mode=display">
i(N)=\frac{1}{2}\left(1-\sum_jp^2(C_j|N)\right)</script><h4 id="属性值类型"><a href="#属性值类型" class="headerlink" title="属性值类型"></a>属性值类型</h4><p>当属性值为标称值时，即固定的几个类别，则只需要遍历所有属性值，就知道该属性的所有类别。示例中年龄由三个类别，一目了然。</p>
<p><img src="http://image.rexking6.top/img/clip1556243702.png" alt=""></p>
<p>属性值为实数值时，对于该属性的类别，并不明显，此时一种解决方法是，先对该属性已经出现的值进行排序，然后在标签发生变化的地方进行切分。示例中体重是实数值，将训练样本中的体重值排序，注意该示例中目标分类（标签）为蓝色和红色两类，因此对排序序列从左向右看，在目标分类发生变化处切分，使同类的直接切到一个判断区间，这样在针对该属性进行划分时能尽可能地减少分支。</p>
<p><img src="http://image.rexking6.top/img/clip1556243892.png" alt=""></p>
<h4 id="单属性vs多属性"><a href="#单属性vs多属性" class="headerlink" title="单属性vs多属性"></a>单属性vs多属性</h4><p>即每次划分时判断是只考虑一个属性，还是同时考虑多个属性。对于如下图所示地训练数据分布，左边为单属性划分，右边为双属性划分，显然，双属性更加自然合理。但是多属性同时考虑效率并不高，现在换个角度看数据分布，有这样的分布，说明其 $x,y$ 两个维度直接存在纠缠关系，一次仅仅用一个属性（直线 $y=k$ 或者 $x=k$）根本分不开，此时如果旋转坐标系（斜着看）去相关性，又可以通过单属性进行划分了。也就说，需要用多属性同时进行划分地，可以对数据进行一定地映射变换去相关性，再用单属性进行划分，但是不管是去相关性还是直接多属性划分，没有绝对的谁更容易。</p>
<p><img src="http://image.rexking6.top/img/clip1556244243.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1556244250.png" alt=""></p>
<h4 id="何时为叶结点"><a href="#何时为叶结点" class="headerlink" title="何时为叶结点"></a>何时为叶结点</h4><p>由于噪声地影响，把所有的数据都分类正确的树不一定是一棵好树，如下图所示，随着决策树越来越复杂，对训练集是越来越准确，但是泛化能力又变差了。</p>
<p><img src="http://image.rexking6.top/img/clip1556244641.png" alt=""></p>
<p>解决这样地问题，可以加入树分裂停止准则和剪枝进行优化。前者即预剪枝，后者即后剪枝。</p>
<p><strong>预剪枝：</strong>树分裂时就实施措施。</p>
<ol>
<li>当树的深度达到预先设定的阈值停止当前分支的分裂；</li>
<li>当分完之后，支持的数据变少，即事先划分验证集测试正确率。</li>
</ol>
<p><strong>后剪枝：</strong>树建好以后，删除掉一些无用的分支，即删除该分支有或无对测试结果没太大的影响的分支。</p>
<ol>
<li><p>降低错误剪枝 REP（Reduced Error Pruning）</p>
<p>划分一个测试数据集来纠正它。该剪枝方法考虑将书上的每个节点作为修剪的候选对象，决定是否修剪这个结点有如下步骤组成：</p>
<ol>
<li>删除以此结点为根的子树；</li>
<li>使其成为叶子结点；</li>
<li>赋予该结点关联的训练数据的最常见分类；</li>
<li>当修剪后的树对于验证集合的性能不会比原来的树差时，才真正删除该结点。</li>
</ol>
</li>
</ol>
<p>   优点：</p>
<ol>
<li>最简单的后剪枝方法之一；</li>
<li>计算复杂度是线性的；</li>
<li><p>和原始决策树相比，修剪后的决策树对未来新事例的预测偏差较小。</p>
<p>缺点：</p>
</li>
<li><p>在数据量较少的情况下很少应用。REP方法趋于过拟合（overfitting），这是因为训练数据集中存在的特性在剪枝过程中都被忽略了，当剪枝数据集比训练数据集小得多时，这个问题特别值得注意。</p>
</li>
</ol>
<ol>
<li><p>悲观错误剪枝 PEP（Pessimistic Error Pruning）</p>
<p>该方法克服了REP需要独立剪枝集的缺点，基于训练数据的误差评估，因此不用单独找剪枝数据集。但训练数据也带来错分误差偏向于训练集，所以引入了统计学上连续修正的概念弥补REP中的缺陷，在评价子树的训练错误公式中添加了一个常数，假定每个叶子结点都自动对实例的某个部分进行错误的分类。</p>
</li>
</ol>
<p>   设原始决策树 $T$，叶结点 $z$，$z$ 结点训练实例个数为 $n_z$，其中错分个数为 $e_z$。</p>
<p>   定义误差率且增加连续性校正：$pe_z=(e_z+0.5)/n_z$，</p>
<p>   相应的误差率：$E(T)=\sum_{t\in T}\frac{e(t)+0.5}{N(t)}$，</p>
<p>   剪枝后的误差率：$E(T’)=\sum_{t\in T,\text{except }K}\frac{e(t)+0.5}{N(t)}$</p>
<p>   标准差错误：$SE(E(T’))=\sqrt{\frac{E(T’)\ast(N_t-E(T’))}{N_t}}$，其中，$N_t$ 是当前训练数据量。</p>
<p>   剪枝条件：$SE(E(T’))\le E(T’)-E(T)$，符合此条件，剪掉 $t$ 。</p>
<p>   优点：</p>
<ol>
<li>PEP方法被认为是当前决策树后剪枝方法中精度较高的算法之一；</li>
<li>PEP 方法不需要分离的剪枝数据集, 这对于事例较少的问题非常有利；</li>
<li>它的计算时间复杂性也只和未剪枝树的非叶节点数目成线性关系。</li>
</ol>
<p>   缺点：PEP是唯一使用自顶向下剪枝策略的事后剪枝方法, 这种策略会带来与事前剪枝方法出 现的同样问题, 那就是树的某个节点会在该节点的子孙根据同样准则不需要剪裁时也会被剪裁。</p>
<ol>
<li><p>基于错误剪枝 EBP（Error-based Pruning）</p>
<ol>
<li>计算叶结点的错分样本率估计的置信区间上限 $U$；</li>
<li><p>计算叶结点的预测错分样本数</p>
<ul>
<li>叶结点的预测错分样本数=到达该叶结点的样本数$\times$该叶结点的预测错分样本率 $U$ </li>
</ul>
</li>
<li><p>判断是否剪枝及如何剪枝</p>
<ul>
<li><p>分别计算三种预测错分样本数：</p>
<ul>
<li>计算子树 $t$ 的所有叶结点预测错分样本数之和，记为 $E_1$</li>
<li>计算子树 $t$ 被剪枝以叶结点代替时的预测错分样本数，记为 $E_2$</li>
<li>计算子树 $t$ 的最大分支的预测错分样本数，记为 $E_3$</li>
</ul>
</li>
<li><p>比较 $E_1,E_2,E_3$，如下：</p>
<ul>
<li>$E_1$ 最小时，不剪枝</li>
<li>$E_2$ 最小时，进行剪枝，以一个叶结点代替 $t$ </li>
<li>$E_3$ 最小时，采用“嫁接”（grafting）策略，即用这个最大分支代替 $t$ </li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>代价-复杂度剪枝 CCP（Cost-complexity Pruning）</p>
<p>CART剪枝法，该算法为子树 $T_t$ 定义了代价（cost）和复杂度（complexity），以及一个可由用户设置的衡量代价与复杂度之间关系的参数 $α$，其中，代价指在剪枝过程中因子树 $T_t$ 被叶结点替代而增加的错分样本，复杂度表示剪枝后子树 $T_t$ 减少的叶结点数，$α$ 则表示剪枝后树的复杂度降低程度与代价间的关系，定义为：</p>
<script type="math/tex; mode=display">
\alpha=\frac{R(t)-R(T_t)}{|N_1|-1}</script><p>其中，$|N_1|$ 为子树 $T_t$ 中的叶结点数，$R(t)$ 为结点 $t$ 的错误代价，计算公式为 $R(t)=r(t)\times p(t)$，$r(t)$ 为结点 $t$ 的错分样本率，$p(t)$ 为落入结点 $t$ 的样本占所有样本的比例，$R(T_t)$ 子树 $T_t$ 错误代价，计算公式为 $R(T_t)=\sum R(i)$ ，$i$ 为子树 $T_t$ 的叶结点。</p>
</li>
</ol>
<p>   算法分为两个步骤：</p>
<ol>
<li><p>对于完全决策树 $T$ 的每个非叶结点计算 $α$ 值，循环剪掉具有最小 $α$ 值的子树，直到剩下根节点。在该步可得到一系列的剪枝树 $\{T_0,T_1,T_2,\dots,T_m\}$，其中 $T_0$ 为原有的完全决策树，$T_m$ 为根结点，$T_{i+1}$ 为对 $T_i$ 进行剪枝的结果；</p>
</li>
<li><p>从子树序列中，根据真实的误差估计选择最佳决策树。</p>
</li>
</ol>
<p>   缺点：生成子树序列 $T(α)$ 所需要的时间和原决策树非叶节点的关系是二次的，这就意味着如果非叶节点的数目随着训练样本数线性增加，则CCP方法的运行时间和训练样本数的关系也是二次的。这就比其它剪枝方法所需要的时间长得多，因为其它剪枝方法的运行时间和非叶节点的关系是线性的。</p>
<ol>
<li><p>最小错误剪枝 MEP（Minimum Error Pruning）</p>
<p>基本思路：采用自底向上的方式，对于树中每个非叶结点，</p>
<ol>
<li><p>计算该结点的误差 $E(t)$；</p>
<script type="math/tex; mode=display">
E_r(t)=\frac{n(t)-n_e(t)+k-1}{n(t)+k}</script><p>其中，$n(t)$ 为结点 $t$ 中的样本总数，$n_e(t)$ 为 $t$ 中主类的样本数目，$k$ 为类数目。</p>
</li>
<li><p>计算该结点的各个分支的加权累计误差 $E’(t)$；</p>
</li>
<li><p>若 $E(t)&gt;E’(t)$，保留；否则，剪枝。</p>
</li>
</ol>
</li>
</ol>
<p>   优点：</p>
<ol>
<li>MEP方法不需要独立的剪枝数据集，无论是初始版本，还是改进版本，在剪枝过程中，使用的信息都来自于训练样本集；</li>
<li>它的计算时间复杂性也只和未剪枝树的非叶节点数目成线性关系。</li>
</ol>
<p>   缺点：</p>
<ol>
<li>类别平均分配的前提假设现实几率不大；</li>
<li>对 $K$ 太过敏感。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>比较项\剪枝方法</th>
<th>REP</th>
<th>PEP</th>
<th>CCP</th>
<th>MEP</th>
</tr>
</thead>
<tbody>
<tr>
<td>独立剪枝集</td>
<td>需要</td>
<td>不需要</td>
<td>不需要（交叉验证）</td>
<td>不需要</td>
</tr>
<tr>
<td>剪枝方式</td>
<td>自底向上</td>
<td>自顶向下</td>
<td>自底向上</td>
<td>自底向上</td>
</tr>
<tr>
<td>误差估计</td>
<td>利用剪枝集</td>
<td>使用连续性校正</td>
<td>使用交叉验证或标准误差</td>
<td>基于概率估计</td>
</tr>
<tr>
<td>计算复杂性（$n$ 为非叶结点个数）</td>
<td>$O(n)$</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
</tr>
</tbody>
</table>
</div>
<h4 id="处理属性值丢失结点"><a href="#处理属性值丢失结点" class="headerlink" title="处理属性值丢失结点"></a>处理属性值丢失结点</h4><ul>
<li>丢弃这些样本；</li>
<li>赋给它结点 $t$ 所对应的训练实例中该属性的最常见值；</li>
<li>代理结点法：缺失的属性在测试阶段用其他的属性代替。</li>
</ul>
<p><img src="http://image.rexking6.top/img/clip1556245233.png" alt=""></p>
<p><strong>C4.5—缺失值</strong></p>
<p>例如 $(X,y)$ 是样本集 $S$ 中的一个训练实例，$X=(F_1,F_2,\dots,F_n)$。但是其属性 $F_i$ 的值未知。</p>
<p>处理策略：为 $F_i$ 的每个可能值赋予一个概率。例如，给定一个布尔属性 $F_i$，如果结点 $t$ 包含6个已知 $F_i=1$ 和4个 $F_i=0$ 的实例，那么 $F_i=1$ 的概率是0.6，而 $F_i=0$ 的概率是0.4。于是，实例 $x$ 的60%被分配到 $F_i=1$ 的分支，40%被分配到另一个分支。这些片段样例（fractional examples）的目的是计算信息增益，</p>
<h4 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h4><ol>
<li>CART：支持分类和回归，分类采用基尼指数，回归使用方差度量，二叉树，支持连续值处理，支持缺失值处理，利用独立的验证数据集进行剪枝。</li>
<li>ID3：仅分类，采用信息增益准则，多叉树，其他不支持。</li>
<li>C4.5：在ID3的基础上，仅分类，采用信息增益率准则，多叉树，支持连续值处理，利用基于错误剪枝方法进行剪枝。</li>
<li>C5.0：在C4.5基础上加入了Boosting技术，速度更快，内存使用更加有效，能生成更小的决策树，但算法细节并没有给公开太多，属于商业机密。</li>
</ol>
<h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><p>随机森林最基本的思想为，在训练阶段树的生成过程中，制定随机部分，随机地生成一颗决策树，通过重复这样的过程，随机生成若干决策树组成森林，然后在预测的时候，综合所有决策树的判断结果得到最终预测结果。随机度越高，树的相关性越低，综合考虑结果的效果就越好。综合结果有加法模型和乘法模型，其中乘法模型有一个痛点就是如果其中某棵树预测值为0，那么整个结果就变为了0。</p>
<h3 id="Randomized-Decision-Trees"><a href="#Randomized-Decision-Trees" class="headerlink" title="Randomized Decision Trees"></a>Randomized Decision Trees</h3><p>随机进行属性选择。</p>
<p>特点：</p>
<ul>
<li>不再寻找全局最优的分裂结点，随机分裂结点，训练更快，使用更简单的二值特征测试；</li>
<li>选择一个包含 $k$ 个属性的集合，从中依据某个准则函数来挑选最优的分裂结点，比如，最大化信息增益；</li>
<li>随机树的效果不如决策树，通过构建多棵树来弥补；</li>
<li>各棵树的投票结果求平均。</li>
</ul>
<p>应用：</p>
<ol>
<li><p>OCR；</p>
</li>
<li><p>手写体识别；</p>
</li>
<li><p>人脸识别；</p>
</li>
<li><p>特定物体检测；</p>
<p><img src="http://image.rexking6.top/img/clip1556259650.png" alt=""></p>
</li>
</ol>
<h3 id="Random-Forest"><a href="#Random-Forest" class="headerlink" title="Random Forest"></a>Random Forest</h3><p>算法过程：</p>
<ol>
<li>有放回地随机选择 $N$ 个样本；</li>
<li>随机从 $M$ 个属性中选取出 $m$ 个属性（$m&lt;&lt;M,m=\sqrt M$），依据某种策略（比如说信息增益）来选择一个属性作为分裂结点；</li>
<li>按照步骤2，构建一棵决策树；</li>
<li>按照步骤1~3建立大量的决策树，组成随机森林。</li>
</ol>
<p>简单地说，行随机、列随机。</p>
<p><img src="http://image.rexking6.top/img/clip1556259945.png" alt=""></p>
<p>优点：</p>
<ol>
<li>比较适合做多分类问题；</li>
<li>训练和预测速度快，能够有效地处理大的数据集；容易并行化；</li>
<li>数据集中有大比例的数据缺失时，仍然可以保持精度不变；</li>
<li>能够检测到特征之间的相互影响以及重要性程度；</li>
<li>不易出现过度拟合。</li>
</ol>
<p>分类森林：</p>
<p><img src="http://image.rexking6.top/img/clip1556260124.png" alt=""></p>
<p>回归森林：</p>
<p><img src="http://image.rexking6.top/img/clip1556260154.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1556260169.png" alt=""></p>
<p>随机度：</p>
<ul>
<li>随机度高，树的相关性低；</li>
<li>随机度低，树的相关性高。</li>
</ul>
<p><img src="http://image.rexking6.top/img/clip1556260228.png" alt=""></p>
<p>树的集成：</p>
<ul>
<li>加法模型</li>
<li>乘法模型</li>
</ul>
<p><img src="http://image.rexking6.top/img/clip1556260286.png" alt=""></p>
<p>应用：</p>
<ol>
<li><p>Kinect上的姿态估计；</p>
<p><img src="http://image.rexking6.top/img/clip1556260338.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1556260348.png" alt=""></p>
</li>
</ol>
<ol>
<li><p>Hough Forest for object detection</p>
<p><img src="http://image.rexking6.top/img/clip1556260385.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1556260406.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1556260427.png" alt=""></p>
</li>
<li><p>人脸关键点标定</p>
<p><img src="http://image.rexking6.top/img/clip1556260463.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1556260471.png" alt=""></p>
</li>
</ol>
<h3 id="Extremely-Randomized-trees"><a href="#Extremely-Randomized-trees" class="headerlink" title="Extremely Randomized trees"></a>Extremely Randomized trees</h3><p>动机：随机森林中，每个维度上的最优切割点的方差较大。</p>
<p><img src="http://image.rexking6.top/img/clip1556260590.png" alt=""></p>
<p>算法过程：</p>
<ol>
<li>随机选择 $k$ 个属性值，计算出属性值的最小值和最大值；</li>
<li>在 $[\text{min,max}]$ 区间上随机生成 $k$ 个切分点；</li>
<li>选择 score 最好的切分点。</li>
</ol>
<p>与随机森林的不同点：</p>
<ol>
<li>无bootstrap，使用全部的训练样本；</li>
<li>在选择结点的分裂位置时，随机。</li>
</ol>
<h3 id="Ferns"><a href="#Ferns" class="headerlink" title="Ferns"></a>Ferns</h3><p>算法：ET上各层上的结点都一样。</p>
<p><img src="http://image.rexking6.top/img/clip1556260883.png" alt=""></p>
<ul>
<li>每个结点想象成一个特征；</li>
<li>其输出值为0或者1，表示该特征有无出现；</li>
<li>在图像块中，可以比较像素点值的大小</li>
</ul>
<script type="math/tex; mode=display">
f_j=\left\{\begin{aligned}&1,&&\text{if }I(d_{j,1})<I(d_{j,2})\\&0,&&\text{otherwise}\end{aligned}\right.</script><p><img src="http://image.rexking6.top/img/clip1556261043.png" alt=""></p>
<p>应用：</p>
<ol>
<li>3D object detection</li>
<li>SLAM</li>
</ol>
<p><img src="http://image.rexking6.top/img/clip1556261168.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1556261177.png" alt=""></p>
<h2 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h2><p>提升（Boosting）是一种常用得统计学习方法，在分类问题中，它通过改变训练样本的权重，学习多个分类器（一般是弱分类器），并将这些分类器线性组合，最终提高分类器的性能。而针对于这种提升方法而言，需要回答两个问题，一是在每一轮如何改变训练样本的权值或概率分布；二十如何将弱分类器组合成一个强分类器。</p>
<h3 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h3><p>Adaboost属于Boosting一种，针对第一个问题，Adaboost的做法是提高哪些被前一轮弱分类器错误分类样本的权值，而降低那些被正确分类的样本的权重。从而使得那些被错误分类的样本由于其权值被加大而受到后一轮弱分类器的更多的关注。针对第二个问题，Adaboost采取加权多数表决的方法，加大分类误差率小的弱分类器的权重，使其在最终的分类器表决中起较大作用，减小分类误差率大的弱分类器的权重，使其在表决中其较小的作用。</p>
<p><img src="http://image.rexking6.top/img/clip1556262092.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1556262108.png" alt=""></p>
<h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>算法流程如下：</p>
<p><img src="http://image.rexking6.top/img/clip1556262939.png" alt=""></p>
<ol>
<li>首先初始化各个样本的权重，为 $\frac{1}{m}$，$m$ 为样本数量，有些书本可能会这样初始化：每个正样本权重为 $\frac{1}{2u}$，每个负样本权重为 $\frac{1}{2v}$，$u+v$ 等于样本总数。这对于得到最终的强分类器并没有影响。</li>
<li><p>开始进行迭代，在每一轮的迭代中：</p>
<ol>
<li>寻找到一个弱分类器使得在当前样本权重分布下的错误率最小；</li>
<li>当确定了这样一个弱分类器后，计算错误率 $\varepsilon_j$ ；</li>
<li>根据误差率计算此弱分类器在最终的强分类器中所占的权重 $\alpha_t$；</li>
<li>根据公式更新训练样本的权值分布；</li>
<li>将此弱分类器加入到当前迭代次数下的强分类器中。</li>
</ol>
</li>
<li><p>直到迭代次数达到指定数值或者强分类器在训练集上的误差达到指定范围停止迭代。</p>
</li>
</ol>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="http://image.rexking6.top/img/clip1556263573.png" alt=""></p>
<ol>
<li>第一次迭代我们给所有样本相同的权重，找到当前权重分布下，分类误差率最小的一个弱分类器；</li>
<li>第二次迭代，经过上一轮弱分类器之后，有三个样本被分错，加大其权重，找到在当前权重分布下，误差率最小的一个弱分类器；</li>
<li>以此类推；</li>
<li>最终，将得到的一系列弱分类器加权组合起来就得到了一个强分类器（实黑线）。</li>
</ol>
<h4 id="应用于目标检测"><a href="#应用于目标检测" class="headerlink" title="应用于目标检测"></a>应用于目标检测</h4><p><img src="http://image.rexking6.top/img/clip1556263784.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1556263813.png" alt=""></p>
<h4 id="软件资源"><a href="#软件资源" class="headerlink" title="软件资源"></a>软件资源</h4><ul>
<li><a target="_blank" rel="noopener" href="http://elf-project.sourceforge.net/">Ensemble Learning Framework</a></li>
<li><a target="_blank" rel="noopener" href="http://graphics.cs.msu.ru/en/science/research/machinelearning/adaboosttoolbox">AdaBoost Matlab Toolbox</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dmlc/xgboost">Xgboost，陈天奇</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Microsoft/LightGBM/wiki/Features">LightGBM</a></li>
</ul>
<h4 id="策略-1"><a href="#策略-1" class="headerlink" title="策略"></a>策略</h4><p>AdaBoost算法是前向分步加法算法的特例，模型是由基本分类器组成的加法模型，损失函数是指数函数。</p>
<p>模型：</p>
<script type="math/tex; mode=display">
f(x)=\sum_{m=1}^M\alpha_mG_m(x)</script><p>策略：</p>
<script type="math/tex; mode=display">
L(y,f(x))=\text{exp}[-yf(x)]</script><p>$G_m(x)$ 在训练集上的分类误差率 $e_m$ 为：</p>
<script type="math/tex; mode=display">
e_m=\sum_{i=1}^Nw_{mi}I(G_m(x_i)\neq y_i)</script><p>$G_m(x)$的系数 $\alpha_m$ 为：</p>
<script type="math/tex; mode=display">
\alpha_m=\frac{1}{2}\text{log}\frac{1-e_m}{e_m}</script><p>在证明前，先介绍<strong>前向分布算法</strong>。给定一个加法模型：</p>
<script type="math/tex; mode=display">
f(x)=\sum_{m=1}^M\beta_mb(x;\gamma_m)</script><p>其中，$b$ 为基函数，$\gamma_m$ 为基函数的参数，$\beta_m$ 为基函数的系数。在给定训练数据基损失函数 $L(y,f(x))$ 的条件下，学习加法模型 $f(x)$ 成为经验风险最小化即损失函数最小化问题：</p>
<script type="math/tex; mode=display">
\text{min}_{\beta_m,\gamma_m}\sum_{i=1}^NL(y_i,\sum_{m=1}^M\beta_Mb(x_i,\gamma_m))</script><p>通常这是一个复杂的优化问题，一次性求解所有基函数的参数以及其系数比较困难。前向分布算法（forward stagewise algorithm）求解这一优化问题的思路是：因为学习的是加法模型，如果能够从后向前，每一步只学习一个基函数及其系数，逐步逼近其目标函数式，那么就可以简化优化的复杂度。具体地，每步只需优化如下损失函数：</p>
<script type="math/tex; mode=display">
\text{min}_{\beta,\gamma}\sum_{i=1}^NL(y_i,\beta b(x_i,\gamma))</script><p>了解了前向分布算法，下面就要证明上述结论了。从我们的模型入手：</p>
<script type="math/tex; mode=display">
f(x)=\sum_{m=1}^M\alpha_mG_m(x)</script><p>假设 $f_0(x)$ 表示第0此迭代后的模型，$f_m(x)$ 表示第 $m$ 次迭代后的模型，有：</p>
<script type="math/tex; mode=display">
\begin{align*}
&f_0(x)=0\\
&f_1(x)=f_0(x)+\alpha_1G_1(x)=\sum_{m=1}^1\alpha_mG_m(x)\\
&f_2(x)=f_1(x)+\alpha_2G_2(x)=\alpha_1G_1(x)+\alpha_2G_2(x)=\sum_{i=1}^2\alpha_iG_i(x)\\
&\dots\\
&f_{m-1}(x)=f_{m-2}(x)+\alpha_{m-1}G_{m-1}(x)=\alpha_1G_1(x)+\dots+\alpha_{m-1}G_{m-1}(x)=\sum_{i=1}^{m-1}\alpha_iG_i(x)\\
&f_m(x)=f_{m-1}(x)+\alpha_mG_m(x)=\sum_{i=1}^m\alpha_iG_i(x)
\end{align*}</script><p>那么经过 $m$ 次迭代所产生的最终模型 $f_m(x)$，表示为前 $m-1$ 次迭代产生的模型 $f_{m-1}(x)$ 加上第 $m$ 次迭代产生的加权基函数 $\alpha_mG_m(x)$。代入损失函数：</p>
<script type="math/tex; mode=display">
L(y,f(x))=\text{exp}(-yf(x))</script><p>即第 $m$ 轮迭代的基函数以及其系数必然满足下述极小化式：</p>
<script type="math/tex; mode=display">
(\alpha_m,G_m(x))=\text{arg min}_{\alpha,G}\sum_{i=1}^N\text{exp}[-y_i(f_{m-1}(x_i))+\alpha G(x_i)]</script><p>对上式变形：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\sum_{i=1}^N\text{exp}[-y_i(f_{m-1}(x_i)+\alpha G(x_i))]\\
=&\sum_{i=1}^N\text{exp}[-y_if_{m-1}(x_i)]\times\text{exp}[-y_i\alpha G(x_i)]\\
=&\sum_{i=1}^N\overline w_{mi}\times \text{exp}[-y_i\alpha G(x_i)]
\end{align*}</script><p>其中，$\overline w_{mi}=\text{exp}[-y_if_{m-1}(x_i)]$，注意到这一项是与 $\alpha_m$ 以及 $G_m(x)$ 无关的。</p>
<p>即：</p>
<script type="math/tex; mode=display">
(\alpha_m,G_m(x))=\text{arg min}_{\alpha, G}\sum_{i=1}^N\overline w_{mi}\times \text{exp}[-y_i\alpha G(x_i)]</script><p>进一步展开，</p>
<script type="math/tex; mode=display">
\begin{align*}
&\sum_{i=1}^N\overline w_{mi}\times\text{exp}[-y_i\alpha G(x_i)]\\
=&\sum_{i=1}^N\overline w_{mi}\times e^{-\alpha}\times I\{y_i=G(x_i)\}+\sum_{i=1}^N\overline w_{mi}\times e^\alpha \times I\{y_i\neq G(x_i)\}\\
=&e^{-\alpha}\sum_{i=1}^N\overline w_{mi}\times I\{y_i=G(x_i)\}+e^\alpha \sum_{i=1}^N\overline w_{mi}\times I\{y_i\neq G(x_i)\}\\
=&e^{-\alpha}\sum_{i=1}^N\overline w_{mi}\times I\{y_i=G(x_i)\}+e^\alpha \sum_{i=1}^N\overline w_{mi}\times I\{y_i\neq G(x_i)\}\\
+&e^{-\alpha}\sum_{i=1}^N\overline w_{mi}\times I\{y_i\neq G(x_i)\}-e^{-\alpha}\sum_{i=1}^N\overline w_{mi}\times I\{y_i\neq G(x_i)\}\\
=&e^{-\alpha}\sum_{i=1}^N\overline w_{mi}+(e^\alpha-e^{-\alpha})\sum_{i=1}^N\overline w_{mi}\times I\{y_i\neq G(x_i)\}
\end{align*}</script><p>因为 $\overline w_{mi}$ 与 $\alpha_m$ 以及 $G_m(x)$ 无关，可以看到所求的 $G_m^\ast(x)$ 满足下列极小化式，</p>
<script type="math/tex; mode=display">
G_m^\ast(x)=\text{arg min}_G\sum_{i=1}^N\overline w_{mi}I(y_i\neq G(x_i))</script><p>假设我们已经求得了 $G_m^\ast(x)$，那接下来求它的系数 $\alpha_m^\ast$，对 $\alpha$ 求偏导，令其等于0：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\frac{\partial}{\partial \alpha}\left(e^{-\alpha}\sum_{i=1}^N\overline w_{mi}+(e^\alpha-e^{-\alpha})\sum_{i=1}^N\overline w_{mi}\times I\{y_i\neq G(x_i)\}\right)\\
=&-e^{-\alpha}\sum_{i=1}^N\overline w_{mi}+(e^\alpha+e^{-\alpha})\sum_{i=1}^N\overline w_{mi}\times I\{y_i\neq G(x_i)\}=0
\end{align*}</script><p>即得：</p>
<script type="math/tex; mode=display">
\frac{e^\alpha+e^{-\alpha}}{e^{-\alpha}}=\frac{\sum_{i=1}^N\overline w_{mi}}{\sum_{i=1}^N\overline w_{mi}\times I\{y_i\neq G(x_i)\}}\Rightarrow\alpha_m^\ast=\frac{1}{2}\text{log}\frac{1-e_m}{e_m}</script><p>其中，</p>
<script type="math/tex; mode=display">
e_m=\frac{\sum_{i=1}^N\overline w_{mi}\times I\{y_i\neq G(x_i)\}}{\sum_{i=1}^N\overline w_{mi}}</script><p>对 $e_m$ 进一步化简：</p>
<script type="math/tex; mode=display">
\begin{align*}
e_m=&\frac{\sum_{i=1}^N\overline w_{mi}\times I\{y_i\neq G(x_i)\}}{\sum_{i=1}^N\overline w_{mi}}\\=&\sum_{i=1}^N\left(\frac{\overline w_{mi}}{\sum_{i=1}^N\overline w_{mi}}\right)I(y_i\neq G_m(x_i))\\=&\sum_{i=1}^Nw_{mi}I(y_i\neq G_m(x_i))
\end{align*}</script><p>最后推导出训练集样本权值的更新公式，由模型：</p>
<script type="math/tex; mode=display">
f_m(x)=f_{m-1}(x)+\alpha_mG_m(x)</script><p>以及权值：</p>
<script type="math/tex; mode=display">
\overline w_{mi}=\text{exp}(-y_if_{m-1}(x_i))</script><p>可以得到：</p>
<script type="math/tex; mode=display">
\overline w_{m+1,i}=\overline w_{m,i}\text{exp}(-y_i\alpha_mG_m(x))</script><p><strong>决策规则为：</strong></p>
<script type="math/tex; mode=display">
G(x)=\text{sgn}(f(x))=\text{sgn}\left(\sum_{m=1}^M\alpha_mG_m(x)\right)</script><p><strong>损失函数与类概率的对数几率之间的关系</strong></p>
<p>上述的损失函数可以写为：</p>
<script type="math/tex; mode=display">
f^\ast(x)=\text{arg min}_{f(x)}E_{Y|x\sim D}[e^{-Yf(x)}]</script><p>其中期望为：</p>
<script type="math/tex; mode=display">
E_{Y|x\sim D}[e^{-Yf(x)}]=p(Y=1|x)e^{-f(x)}+p(Y=-1|x)e^{f(x)}</script><p>对其求偏导，</p>
<script type="math/tex; mode=display">
\begin{align*}
&\frac{\partial E_{Y|x\sim D}[e^{-Yf(x)}]}{\partial f(x)}=-p(Y=1|x)e^{-f(x)}+p(Y=-1|x)e^{f(x)}=0\\
\Rightarrow&f^\ast(x)=\frac{1}{2}\text{ln}\frac{p(Y=1|x)}{p(Y=-1|x)}\\
\end{align*}</script><p>所以，</p>
<script type="math/tex; mode=display">
\begin{align*}
G(x)&=\text{sgn}(f(x))\\
&=\text{sgn}\left(\frac{1}{2}\text{ln}\frac{p(Y=1|x)}{p(Y=-1|x)}\right)\\
&=\left\{\begin{aligned}&1,&&p(Y=1|x)>p(Y=-1|x)\\&-1,&&p(Y=1|x)\le p(Y=-1|x)\end{aligned}\right.\\
&=\text{arg max}_{y\in\{-1,1\}}p(y|x)
\end{align*}</script><p>可以看出其达到了贝叶斯最优错误率。</p>
<h4 id="损失函数回顾"><a href="#损失函数回顾" class="headerlink" title="损失函数回顾"></a>损失函数回顾</h4><h5 id="理想的0-1损失函数"><a href="#理想的0-1损失函数" class="headerlink" title="理想的0-1损失函数"></a>理想的0-1损失函数</h5><p><img src="http://image.rexking6.top/img/clip1556276679.png" alt=""></p>
<script type="math/tex; mode=display">
L(y,f_\theta(x))=\left\{\begin{aligned}&0,&&y=f_\theta(x)\\&1,&&y\neq f_\theta(x)\end{aligned}\right.=I\{y\neq f_\theta(x)\}</script><p>这类损失函数并不常用，因为其有间断点，不可导。</p>
<h5 id="基于最小二乘法的分类"><a href="#基于最小二乘法的分类" class="headerlink" title="基于最小二乘法的分类"></a>基于最小二乘法的分类</h5><p><img src="http://image.rexking6.top/img/clip1556277247.png" alt=""></p>
<script type="math/tex; mode=display">
\begin{align*}
L(y,f_\theta(x))&=(y-f_\theta(x))^2\\
&=y^2\left(1-\frac{f_\theta(x)}{y}\right)^2\\
&=\left(1-\frac{f_\theta(x)}{y}\right)^2\\
&=(1-yf_\theta(x))^2\\
&=(1-m)^2
\end{align*}</script><p>这类损失函数的优点是有解析解，但它的缺点也很明显，就是对”坏点”非常敏感，并且当 $f(x)$ 的值很大时损失也很大，“妒忌心”很重。</p>
<h5 id="SVM的Hinge损失函数"><a href="#SVM的Hinge损失函数" class="headerlink" title="SVM的Hinge损失函数"></a>SVM的Hinge损失函数</h5><p><img src="http://image.rexking6.top/img/clip1556277393.png" alt=""></p>
<p>损失函数为：</p>
<script type="math/tex; mode=display">
\text{min}_{w,b}\sum_i^N[1-y_i(wx_i+b)]_++\lambda||w||^2</script><p>变形，令</p>
<script type="math/tex; mode=display">
[1-y_i(wx_i+b)]_+=\xi_i</script><p>于是，原式就变成了，</p>
<script type="math/tex; mode=display">
\text{min}_{w,b}\sum_i^N\xi_i+\lambda||w||^2</script><p>若进一步表示成，</p>
<script type="math/tex; mode=display">
\text{min}_{w,b}\frac{1}{C}\left(\frac{1}{2}||w||^2+C\sum_i^N\xi_i\right)</script><p>类似于下式：</p>
<script type="math/tex; mode=display">
\frac{1}{m}\sum_{i=1}^ml(wx_i+b,y_i)+||w||^2</script><p>前半部分中的就是Hinge损失函数，而后面相当于L2正则项，说明SVM损失函数是正则化了的Hinge损失函数。这类损失函数线性惩罚误分类的点，鲁棒性较强。</p>
<h5 id="AdaBoost的指数损失函数"><a href="#AdaBoost的指数损失函数" class="headerlink" title="AdaBoost的指数损失函数"></a>AdaBoost的指数损失函数</h5><p><img src="http://image.rexking6.top/img/clip1556277942.png" alt=""></p>
<p>这类损失函数连续，可导，接近理想的0-1损失，对太正确的点惩罚低，收敛快，误分类点的损失指数增长，鲁棒性较差。</p>
<h5 id="Logistic回归的指数损失函数"><a href="#Logistic回归的指数损失函数" class="headerlink" title="Logistic回归的指数损失函数"></a>Logistic回归的指数损失函数</h5><p><img src="http://image.rexking6.top/img/clip1556278219.png" alt=""></p>
<p>Logistic回归的指数损失，m&gt;0时，类似指数损失；m&lt;0时，损失是线性增长的。</p>
<p>AdaBoost的损失函数可以改成Logistic Regression的损失函数，从而更加鲁棒，这样的算法称作 GentleBoost。在每次迭代时，基于最小二乘去做一个加权回归，最后所有回归函数的和作为最终的分类器。</p>
<h3 id="提升树（Boosting-Trees）"><a href="#提升树（Boosting-Trees）" class="headerlink" title="提升树（Boosting Trees）"></a>提升树（Boosting Trees）</h3><p>提升树是以分类树或回归树为基本分类器的提升方法。提升树被认为是统计学习中性能最好的方法之一。</p>
<h4 id="模型-1"><a href="#模型-1" class="headerlink" title="模型"></a>模型</h4><p>提升方法实际采用加法模型（即基函数的线性组合）与前向分步算法。以决策树为基函数的提升方法成为提升树。对分类问题决策树是二叉分类树，对回归问题决策树是二叉回归树。只有一个条件的基本分类器可以看做是由一个根结点直接连接两个叶结点简单决策树，即所谓的决策树桩（decision stump）。提升树模型可以表示为决策树的加法模型：</p>
<script type="math/tex; mode=display">
f_M(x)=\sum_{m=1}^MT(x;\Theta_m)</script><p>其中，$T(x; \Theta_m)$ 表示决策树；$\Theta_m$ 为决策树的参数；$M$ 为树的个数。提升树中树之间没有权重，或者说它们的权重都是一样的，树之间是独立的，训练样本之间也没有权重的概念，这是提升树和随机森林、AdaBoost之间的区别。</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>提升树算法采用前向分步算法。首先确定初始提升树 $f_0(x)=0$，第 $m$ 步的模型是：</p>
<script type="math/tex; mode=display">
f_m(x)=f_{m-1}(x)+T(x,\Theta_m)</script><p>其中，$f_{m-1}(x)$ 为当前模型，通过经验风险最小化确定下一决策树的参数 $\Theta_m$：</p>
<script type="math/tex; mode=display">
\hat \Theta=\arg \min_{\Theta_m}\sum_{i=1}^NL(y_i,f_{m-1}(x)+T(x_i;\Theta_m))</script><p>最终得到的模型为：</p>
<script type="math/tex; mode=display">
f_M(x)=\sum_{m=1}^MT(x;\Theta_m)</script><p>由于树的线性组合可以很好地拟合训练数据，即使数据中的输入与输出之间关系很复杂也是如此。所以提升树是一个表现很好的学习算法。</p>
<p>不同问题中的提升树学习算法的主要区别在于使用的损失函数不同。例如用平方损失函数的回归问题，用指数损失函数的分类问题，以及用一般损失函数的一般决策问题。</p>
<p><strong>回归问题</strong></p>
<p>回归问题采用平方误差损失函数，损失变为：</p>
<script type="math/tex; mode=display">
\begin{align*}
&L(y_i,f_{m-1}(x_i)+T(x_i;\Theta_m))\\
=&[y_i-f_{m-1}(x_i)-T(x_i;\Theta_m))]^2\\
=&[r_i-T(x_i;\Theta_m)]^2
\end{align*}</script><p>其中，$r_i=y_i-f_{m-1}(x_i)$，是当前模型拟合数据的残差（residual）。所以，对回归问题的提升树算法来说，只需简单地拟合当前模型的残差。</p>
<h4 id="梯度提升树（GBDT）"><a href="#梯度提升树（GBDT）" class="headerlink" title="梯度提升树（GBDT）"></a>梯度提升树（GBDT）</h4><p>梯度提升树，Gradient Boosting，其学习流程与提升树类似，只是不再使用残差作为新的训练数据而是使用最速下降的近似方法，即使用损失函数的梯度作为新的新的训练数据的 $y$ 值，具体的来说就是使用损失函数对 $f(x)$ 求梯度然后带入 $f_{m-1}(x)$ 。$f(x)=f_{m-1}(x)+T(x;\Theta_m)$，损失为：</p>
<script type="math/tex; mode=display">
\begin{align*}
&L(y,f(x))\\
\neq&L(y,f_{m-1}(x))+\left.\frac{\partial L(y,f(x))}{\partial f(x)}\right|_{f(x)=f_{m-1}(x)}\times(f(x)-f_{m-1}(x))
\end{align*}</script><p>负梯度为：</p>
<script type="math/tex; mode=display">
T(x;\Theta)=-\left.\frac{\partial L(y,f(x))}{\partial f(x)}\right|_{f(x)=f_{m-1}(x)}</script><p><strong>GDBT与提升树之间的关系：</strong></p>
<p>提升树模型每一次的提升都是靠上次的预测结果与训练数据的label值差值作为新的训练数据进行重新训练，GDBT则是将残差计算替换成了损失函数的梯度方向，将上一次的预测结果带入梯度中求出本轮的训练数据，也就是说这两种模型在生成新的训练数据时采用了不同的方法。在使用平方误差损失函数和指数损失函数时，提升树的残差求解比较简单，但是在使用一般的损失误差函数时，残差求解起来不是那么容易，所以就使用损失函数的负梯度在当前模型的值作为回归问题中残差的近似值。</p>
<p>上述给出的提升树是损失函数采用平方损失的版本，当采用其他损失函数的时候，可以将其细分为若干类算法。</p>
<p><img src="http://image.rexking6.top/img/clip1557546370.png" alt=""></p>
<h4 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h4><ol>
<li><p>验证集</p>
<p>为了防止过拟合，首先我们可以设置一个验证集，在验证集上调整叶子结点的个数 $J$ 和树的棵数 $M$。寻找最优 $M$ 的过程类似神经网络的早停策略。</p>
</li>
</ol>
<ol>
<li><p>Shrinkage</p>
<p>对加入模型的树加入缩放因子 $v$ 进行缩放：</p>
<script type="math/tex; mode=display">
f_m(x)=f_{m-1}(x)+v\times\sum_{j=1}^Jc_{mj}I\{x\in R_{mj}\}</script><p>这里的缩放因子可以理解为学习率。那么类比学习率对模型的影响，我们不难得出这样的结论：相同的 $M$，较小的 $v$ 导致较大的训练风险；$v$ 较小，需要较大的 $M$ ；$v$ 和 $M$ 共同控制模型的泛化能力。在实际应用中通常采用使用较小的 $v$ ，通过早停选择 $M$。</p>
</li>
</ol>
<ol>
<li><p>Penalty</p>
<p>一种“广泛撒网，重点选拔”的方法，即先训练出大量的树，然后选择好的树放到最终的模型中，</p>
<script type="math/tex; mode=display">
\alpha^\ast(\lambda)=\arg \min_\alpha\left\{\sum_{i=1}^N\left(y_i-\sum_k\alpha_kT_k(x_i)\right)^2+\lambda J(\alpha)\right\}</script><p>其中，正则化项 $J(\alpha)$ 可以选择岭回归或者Lasso。该方法即是在原本的策略中加一个罚项，从而训练并选出泛化能力更好的模型。</p>
</li>
</ol>
<h2 id="模型组合"><a href="#模型组合" class="headerlink" title="模型组合"></a>模型组合</h2><h3 id="得到一组分类器"><a href="#得到一组分类器" class="headerlink" title="得到一组分类器"></a>得到一组分类器</h3><h4 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h4><p>同一个分类器在不同的数据集上训练。</p>
<p><img src="http://image.rexking6.top/img/clip1557553168.png" alt=""></p>
<h4 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h4><p>对训练集进行部分采样。主要目的是为了降低方差。</p>
<p><img src="http://image.rexking6.top/img/clip1557553216.png" alt=""></p>
<p>典型方法为随机森林。</p>
<h3 id="组合分类器"><a href="#组合分类器" class="headerlink" title="组合分类器"></a>组合分类器</h3><h4 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h4><ul>
<li>简单：只需利用已训练好的分类器，无需重新训练</li>
<li>分类器可以学习出分类器之间的相关性，比简单的朴素贝叶斯组合具有更好的效果</li>
<li>方便进行特征组合，比如：目标检测中的部位模型</li>
</ul>
<p><img src="http://image.rexking6.top/img/clip1557553336.png" alt=""></p>
<h4 id="Averaging"><a href="#Averaging" class="headerlink" title="Averaging"></a>Averaging</h4><p>假设有 $h=1,\dots,H$ 个模型，每个模型的先验概率是 $p(h)$，则数据集的分布</p>
<script type="math/tex; mode=display">
p(X)=\sum_{h=1}^Hp(X|h)p(h)</script><p>解释：</p>
<ul>
<li><p>只有一个模型能很好地解释数据；</p>
</li>
<li><p>$p(h)$ 反映了各个模型之间的不确定性；</p>
</li>
<li><p>数据集增大，不确定性减少，$p(X|h)$ 收敛到某个模型。</p>
</li>
</ul>
<h4 id="Boosting-1"><a href="#Boosting-1" class="headerlink" title="Boosting"></a>Boosting</h4><p>综合转载以下文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/3qVioGYf6ucG3vVJlOk8LA">概率图模型(中)</a></li>
<li><a href="">概率图模型(下)</a></li>
</ul>
<h1 id="概率图"><a href="#概率图" class="headerlink" title="概率图"></a>概率图</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>概率图模型就是把概率和模型用图连接起来 ，图是一种数据结构，用来表示变量概率依赖关系的理论，结合概率论与图论的知识，利用图来表示与模型有关的变量的联合概率分布，通过图形化概率分布有助于求解复杂的模型，图还可以帮助人们做推理，表示和推理是图的两大主要功能。</p>
<p>形式有三种：有向图、无向图和混合图。</p>
<h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><p><img src="http://image.rexking6.top/img/clip1559010711.png" alt=""></p>
<p>有向图 又称 贝叶斯网络 又称 信念网络。</p>
<h3 id="例：多项式回归"><a href="#例：多项式回归" class="headerlink" title="例：多项式回归"></a>例：多项式回归</h3><p><img src="http://image.rexking6.top/img/clip1559010824.png" alt=""></p>
<script type="math/tex; mode=display">
D=\{\langle x_n,t_n \rangle\}_{n=1}^t\\
t_n=w^Tx_n+\varepsilon,\varepsilon\sim N(0,1)</script><p>回归模型是有监督的。在上图中，$ε$ 是一个均值为0，方差为1的高斯分布，加上一个常数，所以 $t_n$ 同样满足高斯分布，其中 $w$ 是未知的，为了求解 $w$ 可以使用最大似然估计进行求解，$t_n$ 依赖于 $x_n$ 和 $w$ ，所以高斯分布可以写成如下形式：</p>
<script type="math/tex; mode=display">
p(t_n|x_n,w)=N(t_n|w^Tx_n,1)=\frac{1}{\sqrt{2\pi}}\exp\left\{-\frac{(t_n-w^Tx_n)^2}{2}\right\}</script><p>这样写的好处，w可以理解成在极大似然估计中一个固定的点，当然w也有可能是一个随机变量。为了更好的解析一个模型，通常可以使用三个方法：极大似然估计、最大后验概率估计（正则化）、贝叶斯学习（把参数当成是随机变量）。</p>
<p><img src="http://image.rexking6.top/img/clip1559011189.png" alt=""></p>
<p>每个 $t_n$ 都会和 $w$ 相关，$w$ 满足某一分布，相当于很多个高斯分布叠加在一起，可以表现成如下形式：</p>
<p><img src="http://image.rexking6.top/img/clip1559011196.png" alt=""></p>
<p>对输入变量预测，假设输入值 $x$，得到根据观测数据为条件的对应的 $t$ 的概率分布，对于该问题的概率图模型如下：</p>
<p><img src="http://image.rexking6.top/img/clip1559011442.png" alt=""></p>
<p>它们有一个共同的参数 $α$，$t_n$ 和 $x_n$ 有关，$x_n$ 是一个标量，即一个固定的值，同时还和方差有关，使用空心圆来表示随机变量，确定的参数由小的实心圆表示，可得公式：</p>
<script type="math/tex; mode=display">
p(\textbf t,\textbf w|\textbf x,\alpha,\sigma^2)=p(\textbf w|\alpha)\prod_{n=1}^Np(t_n|\textbf w,x_n,\sigma^2)</script><p><img src="http://image.rexking6.top/img/clip1559011683.png" alt=""></p>
<p>该模型的联合概率密度函数如下：</p>
<script type="math/tex; mode=display">
p(\hat t,\textbf t,\textbf w|\hat x,\textbf x,\alpha,\sigma^2)=\left[\prod_{n=1}^Np(t_n|x_n,\textbf w,\sigma^2)\right]p(\textbf w|\alpha)p(\hat t|\hat x,\textbf w,\sigma^2)</script><h3 id="例：Logistic-Sigmoid函数"><a href="#例：Logistic-Sigmoid函数" class="headerlink" title="例：Logistic Sigmoid函数"></a>例：Logistic Sigmoid函数</h3><p><img src="http://image.rexking6.top/img/clip1559011719.png" alt=""></p>
<p>$x_1,x_2,\dots,x_M$ 都分别表示一个维度，每个维度之间并不相互独立。有：</p>
<script type="math/tex; mode=display">
p(y=1|x_1,\dots,x_M)=\sigma\left(w_0+\sum_{i=1}^Mw_ix_i\right)=\sigma(\textbf w^T\textbf x)</script><p>其中：</p>
<script type="math/tex; mode=display">
\sigma(\textbf w^T\textbf x)=\frac{1}{1+\exp(-\textbf w^T \textbf x)}</script><h3 id="例：多元高斯模型"><a href="#例：多元高斯模型" class="headerlink" title="例：多元高斯模型"></a>例：多元高斯模型</h3><p>结点 $i$ 表示服从高斯分布的一元连续随机变量 $x_i$ ，该分布的均值是结点 $i$ 的父节点 $x_i$ 的状态的线性组合：</p>
<script type="math/tex; mode=display">
p(x_i|\text{pa}_i)=\cal N\left(x_i\left|\sum_{j \in \text{pa}_i}w_{ij}x_j+b_i,v_i\right.\right)</script><p>其中 $w_{ij}$ 和 $b_i$ 是控制均值的参数，$v_i$ 是 $x_i$ 的条件概率分布的方差。联合概率分布的对数为图模型中所有结点的条件分布的乘积的对数：</p>
<script type="math/tex; mode=display">
\begin{align*}
\ln p(\textbf x)&=\sum_{i=1}^D\ln p(x_i|\text{pa}_i)\\
&=-\sum_{i=1}^D\frac{1}{2v_i}\left(x_i-\sum_{j\in\text{pa}_i}w_{ij}x_j-b_i\right)^2+\text{const}
\end{align*}</script><p>随机变量 $x_i$ 的期望：</p>
<script type="math/tex; mode=display">
\mathbb E[x_i]=\sum_{j\in\text{pa}_i}w_{ij}\mathbb E[x_j]+b_i</script><p>它们的均值如下：</p>
<script type="math/tex; mode=display">
\pmb \mu=(b_1,b_2+w_{21}b_1,b_3+w_{32}b_2+w_{32}w_{21}b_1)^T</script><p>用一个图来表示三个高斯变量：</p>
<p><img src="http://image.rexking6.top/img/clip1559013397.png" alt=""></p>
<p>上述三个变量的协方差如下：</p>
<script type="math/tex; mode=display">
\pmb \Sigma=\left(\begin{aligned}&v_1&&w_{21}v_1&&w_{32}w_{21}v_1\\&w_{21}v_1 &&v_2+w_{21}^2v_1 &&w_{32}(v_2+w_{21}^2v_1)\\ &w_{32}w_{21}v_1 &&w_{32}(v_2+w_{21}^2v_1)&&v_3+w_{32}^2(v_2+w_{21}^2v_1) \end{aligned}\right)</script><h3 id="例：Wet"><a href="#例：Wet" class="headerlink" title="例：Wet"></a>例：Wet</h3><p>一天早晨，Tracey离开她的房子，意识到她的草是湿的。是由 于连夜下雨，还是她昨晚忘了关掉洒水器?接着她注意到她邻居杰克的草也湿了。这就在一定程度上解释了洒水喷头已经关掉的可能性，因此她得出结论，可能昨晚下雨。 该模型的变量有 $R$、$S$、$J$、$T$，各自取值情况为{0,1}：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>R=1：昨晚下雨了；</th>
<th>R=0：昨晚没有下雨；</th>
</tr>
</thead>
<tbody>
<tr>
<td>S=1：水洒关掉了；</td>
<td>S=0：水洒没有关掉；</td>
</tr>
<tr>
<td>J=1：Jack家的草坪是湿的；</td>
<td>J=0：Jack家草坪没有湿；</td>
</tr>
<tr>
<td>T=1:Tracey家草坪是湿的；</td>
<td>T=0:Tracey家草坪没有湿；</td>
</tr>
</tbody>
</table>
</div>
<p>保持该模型的联合概率分布一般性，得到分解式：</p>
<script type="math/tex; mode=display">
p(R,S,J,T)=\underbrace{p(T|S,R,J)}_{2^3=8}\underbrace{p(J|S,R)}_{2^2=4}\underbrace{p(R|S)}_2\underbrace{p(S)}_1</script><p>通过条件独立性，减少了对模型的变量的指定数目，使用概率图模型表示如下：</p>
<p><img src="http://image.rexking6.top/img/clip1559024095.png" alt=""></p>
<p>同时给出如下条件概率表：</p>
<p><img src="http://image.rexking6.top/img/clip1559024132.png" alt=""></p>
<p>根据条件概率表，以及相应的概率模型图，可以求解：</p>
<p><img src="http://image.rexking6.top/img/clip1559024159.png" alt=""></p>
<p>同理：</p>
<p><img src="http://image.rexking6.top/img/clip1559024175.png" alt=""></p>
<h3 id="例：混合高斯模型"><a href="#例：混合高斯模型" class="headerlink" title="例：混合高斯模型"></a>例：混合高斯模型</h3><p><img src="http://image.rexking6.top/img/clip1559024206.png" alt=""></p>
<script type="math/tex; mode=display">
p(\textbf z)=\prod_{k=1}^K\pi_k^{z_k}</script><script type="math/tex; mode=display">
p(\textbf x|z_k=1)=\cal N(\textbf x|\pmb \mu_k,\pmb\Sigma_k)</script><script type="math/tex; mode=display">
p(\textbf x|\textbf z)=\prod_{k=1}^K\cal N(\textbf x|\pmb \mu_k,\pmb \Sigma_k)^{z_k}</script><script type="math/tex; mode=display">
p(\textbf x)=\sum_{\textbf z}p(\textbf z)p(\textbf x|\textbf z)=\sum_{k=1}^K\pi_k\cal N(\textbf x|\pmb\mu_k,\pmb\Sigma_k)</script><h3 id="例：隐马尔可夫模型"><a href="#例：隐马尔可夫模型" class="headerlink" title="例：隐马尔可夫模型"></a>例：隐马尔可夫模型</h3><p>把很多个时刻都关联起来，并且各个时刻之间还有相互关联，那么就变成了隐马尔科夫模型。</p>
<p><img src="http://image.rexking6.top/img/clip1554628530.png" alt=""></p>
<ul>
<li>状态序列：$Z_t\in Q=\{q_1,q_2,\dots,q_N\}$</li>
<li><p>观测序列：$X_t\in V=\{v_1,v_2,\dots,v_M\}$</p>
</li>
<li><p>$A$ —状态转移概率矩阵：$A=[a_{ij}]_{N\times N}, a_{ij}=P(Z_{t+1}=q_j|Z_t=q_i)$</p>
</li>
<li>$B$—观测概率矩阵：$B=[b_j(k)]_{N\times M},b_j(k)=P(X_t=v_k|Z_t=q_j)$</li>
<li>$\Pi$—初始状态概率矩阵：$\Pi=(\pi_i)_{1\times N},\pi_i=P(Z_1=q_i)$</li>
</ul>
<p>这个模型的主要功能是进行推理，求其中的隐变量，在语音识别等领域用的比较多。</p>
<h3 id="例：朴素贝叶斯"><a href="#例：朴素贝叶斯" class="headerlink" title="例：朴素贝叶斯"></a>例：朴素贝叶斯</h3><p><img src="http://image.rexking6.top/img/clip1559024830.png" alt=""></p>
<p>朴素贝叶斯假设条件独立性：</p>
<script type="math/tex; mode=display">
p(X_1,\dots,X_n|Y)=\prod_i p(X_i|Y)</script><p>推测接下来的概率：</p>
<script type="math/tex; mode=display">
p(Y=y_k|X_1,\dots,X_n)=\frac{p(Y=y_k)\prod_i p(X_i|Y=y_k)}{\sum_j p(Y=y_j)\prod_i p(X_i|Y=y_j)}</script><p>朴素贝叶斯主要的应用是垃圾邮件的分类等。</p>
<h3 id="例：贝叶斯网络"><a href="#例：贝叶斯网络" class="headerlink" title="例：贝叶斯网络"></a>例：贝叶斯网络</h3><p>不同的概率图可以将联合概率分布展开成不同的形式：</p>
<ol>
<li><p><img src="http://image.rexking6.top/img/clip1559026796.png" alt=""></p>
<script type="math/tex; mode=display">
p(x_1,x_2,x_3,x_4)=p(x_1|x_2,x_3,x_4)p(x_2|x_3,x_4)p(x_3|x_4)p(x_4)</script></li>
<li><p><img src="http://image.rexking6.top/img/clip1559026864.png" alt=""></p>
<script type="math/tex; mode=display">
p(x_1,x_2,x_3,x_4)=p(x_3|x_1,x_2,x_4)p(x_4|x_1,x_2)p(x_1|x_2)p(x_2)</script></li>
</ol>
<p>现在有概率图：</p>
<p><img src="http://image.rexking6.top/img/clip1559026920.png" alt=""></p>
<p>联合概率分布展开为：</p>
<script type="math/tex; mode=display">
p(x_1,x_2,x_3,x_4)=p(x_1|x_4)p(x_2|x_3,x_4)p(x_3)p(x_4)</script><p>证明在给定 $x_4$ 的条件下，考虑 $x_1$ 和 $x_2$ 是否独立：$p(x_1,x_2|x_4)=p(x_1|x_4)p(x_2|x_4)$。</p>
<script type="math/tex; mode=display">
\begin{align*}
p(x_1,x_2|x_4)&=\frac{1}{p(x_4)}\sum_{x_3}p(x_1,x_2,x_3,x_4)\\
&=\frac{1}{p(x_4)}\sum_{x_3}p(x_1|x_4)p(x_2|x_3,x_4)p(x_3)p(x_4)\\
&=p(x_1|x_4)\sum_{x_3}p(x_2|x_3,x_4)p(x_3)
\end{align*}</script><p>现在我们要将 $p(x_2|x_4)$ 转化成 $\sum_{x_3}p(x_2|x_3,x_4)p(x_3)$，得到：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(x_2|x_4)&=\frac{1}{p(x_4)}\sum_{x_1,x_3}p(x_1,x_2,x_3,x_4)\\
&=\frac{1}{p(x_4)}\sum_{x_1,x_3}p(x_1|x_4)p(x_2|x_3,x_4)p(x_3)p(x_4)\\
&=\sum_{x_3}p(x_2|x_3,x_4)p(x_3)
\end{align*}</script><p>分析可知：$p(x_1,x_2|x_4)=p(x_1|x_4)p(x_2|x_4)$，所以给定 $x_4$ 的情况下 $x_1$ 和 $x_2$ 独立。</p>
<h3 id="冲突变量"><a href="#冲突变量" class="headerlink" title="冲突变量"></a>冲突变量</h3><p>定义：给定一个路径，路径上的结点 $x$、$y$ 同时指向邻居结点 $z$，则 $z$ 结点为冲突变量。</p>
<p><img src="http://image.rexking6.top/img/clip1559027416.png" alt=""></p>
<p>上图中，(c)中给定 $z$  时，$x$ 与 $y$ 不独立；(d)中给定 $z$ 时，$x$ 与 $y$ 不独立。</p>
<p>变化的规则：</p>
<ol>
<li>冲突且给定，保留；</li>
<li>不冲突且不给定，保留；</li>
<li>冲突且不给定，删除；</li>
<li>不冲突且给定，删除。</li>
</ol>
<p>几个例子：</p>
<p><img src="http://image.rexking6.top/img/clip1559027923.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1559027941.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1559027957.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1559027976.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1559027988.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1559028014.png" alt=""></p>
<h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>无向图模型（undirected graphical model），即马尔科夫图模型（Markov network），也称为马尔可夫随机场（Markov random field），含一组结点，每个结点都对应着一个变量或一组变量，链接是无向的，即不含有箭头。模型例子如下图所示，</p>
<p><img src="http://image.rexking6.top/img/clip1559028364.png" alt=""></p>
<p>形式上的定义为：它是由变量 $x_1,x_2 \dots,x_n$ 组成的概率分布 $p$，由 无向图 $G$ 定义，其中每个结点都对应着一个变量或一组变量，联合分布为</p>
<script type="math/tex; mode=display">
p(x_1,x_2 \dots,x_n) = \frac{1}{Z} \prod_{c \in C} \phi(\cal X_c)</script><p>其中 $c$ 代表 无向图 $G$ 中的 团块，$\cal X_c$ 代表团块中的变量，乘积包括了图中的所有团， 而团块，通俗来讲，它是无向图中的<strong>完全子图</strong>的集合，$\phi$ 代表势函数，势函数是一个关于参数的<strong>非负函数</strong>，参数的多少并不影响其非负的性质，比如 $\phi(x_1)$ 是关于 $x_1$ 的非负函数，$\phi(x_1,x_2 \dots,x_n)$ 同样也是一个非负函数，可以将势函数理解为输入变量的条件概率的分布的函数，对势函数求积分，理想状态为1，即 $\sum_{c \in C} \phi(x_c) =1$，而 $Z = \sum_{x_1, \dots, x_n} \prod_{c \in C} \phi_c(\cal X_c)$， 它是一个<strong>标准化常数</strong>，确保整个分布合为1。接下来举出一个简单的例子来更好的理解模型的定义。给定一个无向图 $G$ ，如下图。</p>
<p><img src="http://image.rexking6.top/img/clip1559028479.png" alt=""></p>
<p>它的团集合 $ C $ 是 $\{[a,c], [b,c]\}$，它的概率分布 $p(x_1,x_2 \dots,x_n) = \frac{1}{Z}\phi_{ac}(a,c) \phi_{bc}(b,c) $，$Z = \sum_{a,b,c} \phi_{ac}(a,c) \phi_{b,c}(b,c)$。</p>
<p><strong>成对的马尔科夫网络</strong>：马尔可夫网络有一个特例，当每个团块只包含两个节点时，即每一个势函数中的变量只有两个变量，该情况下的马尔科夫网络叫做成对的马尔科夫网络（Pairwise Markov network）。</p>
<p><strong>Gibbs分布</strong>：如果无向图模型能够表示成一系列在 $G$ 的最大团上的非负函数乘积的形式，这个无向图模型的概率分布 $p(X)$ 就称为Gibbs分布。</p>
<h4 id="例：-玻尔兹曼机（Boltzmann-Machine）"><a href="#例：-玻尔兹曼机（Boltzmann-Machine）" class="headerlink" title="例： 玻尔兹曼机（Boltzmann Machine）"></a>例： 玻尔兹曼机（Boltzmann Machine）</h4><p>玻尔兹曼机（BM）是二值的马尔科夫随机场（Markov Random Filed），是一种基于<strong>能量</strong>的模型，其对应的联合概率分布为</p>
<script type="math/tex; mode=display">
p(\textbf x) = \frac{\exp(\frac{-E(\textbf x)}{T})}{Z}</script><p>玻尔兹曼机可以表示为带权重的无向图，</p>
<p><img src="http://image.rexking6.top/img/image-20190523200245851.png" alt=""></p>
<p>配分函数 $Z$ 通常难以计算，一般通过MCMC方法近似，生成一组服从 $p(\textbf x)$ 的样本，BM中的节点值是二值的（非0即1），且BM的节点是成对作用的，连接权重表示假设之间是相互支持还是互相抵消的关系，如果 $x_i$ 和 $x_j$ 的取值都为1，且 $w_{ij}&gt;0$，则能量下降，概率变大，其能量函数为：</p>
<script type="math/tex; mode=display">
\begin{align*}
E(\textbf x) &= E(\textbf X=\textbf x)\\
&= -(\sum_{i<j}w_{ij}x_ix_j + \sum_ib_ix_i)\\
\end{align*}</script><p>解释一下玻尔兹曼机基于能量模型的原因：首先，统计力学的结论表明，任何概率分布都可以转变成基于能量的模型，其次，对于一个给定的数据集，如果不知道其潜在的分布形式，那是非常难学习的，似然函数都写不出来。如果知道是高斯分布或者多项分布，那可以用最大化似然函数来学出需要学习的对应参数，但是如果分布的可能形式都不知道，这个方法就行不通。最后，能量函数能为无监督学习方法提供目标函数与目标解。</p>
<h4 id="例：限制玻尔兹曼机（Restricted-Boltzmann-Machines）"><a href="#例：限制玻尔兹曼机（Restricted-Boltzmann-Machines）" class="headerlink" title="例：限制玻尔兹曼机（Restricted Boltzmann Machines）"></a>例：限制玻尔兹曼机（Restricted Boltzmann Machines）</h4><p>限制玻尔兹曼机（RBM）包含两个层，分别为可见层（visible layer）和隐藏层（hidden layer）。神经元之间的连接具有如下特点：<strong>层内无连接，层间全连接</strong>，RBM对应的图是一个<strong>二部图</strong>。一般来说，可见层单元用来描述观察数据的一个方面或一个特征，而隐藏层单元的意义一般来说并不明确，可以看作特征提取层。RBM和BM的不同之处在于，BM允许层内神经元之间有连接，而RBM则要求层内神经元之间没有连接，它名字中的限制也就是指限制同一层内相互没有连接。</p>
<p>因此RBM的性质为：<strong>当给定可见层神经元的状态时，各隐藏层神经元的激活条件独立；反之当给定隐藏层神经元的状态是，可见层神经元的激活也条件独立</strong>。</p>
<p><img src="http://image.rexking6.top/img/clip1559031117.png" alt=""></p>
<p>其对应的联合概率分布为：</p>
<script type="math/tex; mode=display">
p(\textbf v,\textbf h) = \frac{\exp(-E(\textbf v,\textbf h))}{Z}</script><p>其能量函数为：</p>
<script type="math/tex; mode=display">
\begin{align*}
E(\textbf v,\textbf h) &= -\sum_i a_iv_i - \sum_jb_jh_j - \sum_i\sum_jv_iw_{ij}h_j \\
&=-\textbf a^{\text{T}} \textbf v - \textbf b^{\text{T}}\textbf  h - \textbf v^{\text{T}} W\textbf h 
\end{align*}</script><p>$Z$ 为配分函数，也称归一化因子</p>
<script type="math/tex; mode=display">
Z = \sum_{v,h}\exp(- E(v,h))</script><p>在RBM中，隐层神经元 $h_j$ 被激活的概率为</p>
<script type="math/tex; mode=display">
p(h_j|\textbf v) = \sigma(b_j + \sum_iW_{i,j}v_i)</script><p>由于是双向连接，显层的神经元同样能通过隐层神经元激活</p>
<script type="math/tex; mode=display">
p(v_i|\textbf h) = \sigma(c_i + \sum_jW_{i.j}h_j)</script><p>同一层神经元中具有独立性，得到</p>
<script type="math/tex; mode=display">
p(\textbf h|\textbf v) = \prod^{N_h}_{j=1} p(h_j|v)\\
p(\textbf v|\textbf h) = \prod^{N_h}_{i=1}p(v_i|h)</script><p>独立性推导过见<a target="_blank" rel="noopener" href="https://blog.csdn.net/itplus/article/details/19168989">受限玻尔兹曼机推导</a>。</p>
<h4 id="例：深度置信网络（Deep-Belief-Network）"><a href="#例：深度置信网络（Deep-Belief-Network）" class="headerlink" title="例：深度置信网络（Deep Belief Network）"></a>例：深度置信网络（Deep Belief Network）</h4><p>深度信念网络，也称<strong>DBN</strong>，是神经网络的一种。<strong>既可以用于非监督学习，类似于一个自编码机；也可以用于监督学习，作为分类器来使用。</strong>作为神经网络，神经元自然是其必不可少的组成部分。DBN由若干层神经元构成，组成元件是<strong>限制玻尔兹曼机（RBM）</strong>。训练过程中，需要充分训练完上一层的RBM 之后才能训练当层的RBM，直到最后一层。</p>
<p>具体训练过程如下：分别单独无监督地训练每一层RBM网络，确保特征向量映射到不同特征空间中，尽可能保留特征信息，这个过程中，数据输入到可见层中，生成向量 $v$ 再通过权重 $W$ 传给 隐层 $h$ ，通过隐层激活单元与可是层输入之间的相关性差别作为权重更新的主要依据。</p>
<p><img src="http://image.rexking6.top/img/clip1559031946.png" alt=""></p>
<h4 id="例：条件随机场（Conditional-Random-Field）"><a href="#例：条件随机场（Conditional-Random-Field）" class="headerlink" title="例：条件随机场（Conditional Random Field）"></a>例：条件随机场（Conditional Random Field）</h4><p>条件随机场是条件概率分布模型 $ p(Y|X)$， 表示的是给定一组输入随机变量X条件下，另一组输出随机变量 Y的马尔可夫随机场，CRF的特点是<strong>假设输出随机变量构成马尔可夫随机场</strong>，下图所示的是线性链条件随机场的模型</p>
<p><img src="http://image.rexking6.top/img/clip1559032200.png" alt=""></p>
<p>设 $X=(x_1,\dots x_n), Y = (y_1, \dots, y_n)$ 均为线性链表示的随机变量序列，在给定随机变量序列 $X$ 的条件下，随机变量序列 $Y$ 的条件概率分布 $p(Y|X)$ 构成条件随机场，同时满足：</p>
<script type="math/tex; mode=display">
p(y_i|X,y_1,\dots,y_{i-1}, y_{i+1},\dots, y_n) = p(y_i|X,y_{i-1},y_{i+1})</script><p>则称 $p(Y|X)$ 为线性链条件随机场。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="条件独立性"><a href="#条件独立性" class="headerlink" title="条件独立性"></a>条件独立性</h4><p>条件独立性</p>
<p>如果变量 $x, y$ 由<strong>未观测变量的路径连接</strong>，那么它们是相关的。但如果 $x$ 的邻居都被观测到，那么 $x$ 与其他变量无关。举个例子，下图中，在给定条件 $C$ 的情况下，$A, B$ 无关。</p>
<p><img src="http://image.rexking6.top/img/clip1559032337.png" alt=""></p>
<p>可得公式：</p>
<script type="math/tex; mode=display">
p(a,b|c) = p(a|c)p(b|c)</script><p>这与有向图模型中的 $A\rightarrow C\leftarrow B$ 相反。在有向图模型中，给定条件 $C$ 并且 $C$ 是一个冲突变量的情况下，$A$ 和 $B$ 不独立。</p>
<h4 id="以点集为对象的马尔可夫性质（Global-Markov-Property）"><a href="#以点集为对象的马尔可夫性质（Global-Markov-Property）" class="headerlink" title="以点集为对象的马尔可夫性质（Global Markov Property）"></a>以点集为对象的马尔可夫性质（Global Markov Property）</h4><p>给定三个互斥的变量集 $(A,B,S)$ ，如果 $S$ 将 $A$ 与 $B$ 分开，那么在给定条件 $S$ 的情况下，$A$ 与 $B$ 独立。</p>
<p><img src="http://image.rexking6.top/img/clip1559032457.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1559032466.png" alt=""></p>
<p>换个说法，所有由 $A$ 点集中的任何一个点和 $B$ 点集中的任何一个点之间的路径都需要经过 $S$ 点集中的一个点，则称 $S$ 隔离了 $A$ 和 $B$，即给定条件 $S$ 的情况下，$A$ 和 $B$ 是独立的。</p>
<h4 id="以点为对象的马尔可夫性质（Local-Markov-Property）"><a href="#以点为对象的马尔可夫性质（Local-Markov-Property）" class="headerlink" title="以点为对象的马尔可夫性质（Local Markov Property）"></a>以点为对象的马尔可夫性质（Local Markov Property）</h4><p>在马尔可夫网络中，对于给定邻居结点的条件下，其条件概率的值等于给定除 $x$ 外所有结点条件下的条件概率的值， 即公式如下</p>
<script type="math/tex; mode=display">
p(x|\cal X \setminus  x) = p(x |\text{ne} (x))</script><p>定义如下：$v$ 为无向图 $G$上的一个结点，$W$ 是与 $v$ 相连的所有结点，$O$ 为除 $W, v$ 以外的结点，则有：</p>
<script type="math/tex; mode=display">
p(v,O|W) = p(v|W)p(O|W)</script><p>给出一个小例子：</p>
<p><img src="http://image.rexking6.top/img/clip1559032652.png" alt=""></p>
<p><img src="http://image.rexking6.top/img/clip1559032660.png" alt=""></p>
<p>以节点4的所有邻居 $\{2,3,5,6\}$ 为条件，节点4与节点1，节点7相互独立。也就是说 $p(x_4| x_2,x_3,x_5,x_6)=p(x_4|x_1,x_2,x_3,x_5,x_6,x_7)$。</p>
<h4 id="以对为对象的马尔可夫网络性质（Pairwise-Markov-Property）"><a href="#以对为对象的马尔可夫网络性质（Pairwise-Markov-Property）" class="headerlink" title="以对为对象的马尔可夫网络性质（Pairwise Markov Property）"></a>以对为对象的马尔可夫网络性质（Pairwise Markov Property）</h4><p>设 $x,y$ 为无向图 $G$ 上任意两个不相连的结点，其他所有的结点为 $X \setminus  \{x,y\}$，则有以下公式</p>
<script type="math/tex; mode=display">
p(x,y| X \setminus  \{x,y\}) = P(x|X \setminus  \{x,y\})p(y|X \setminus  \{x,y\})</script><p><img src="http://image.rexking6.top/img/image-20190525192227609.png" alt=""></p>
<p>对于非负的势函数，局部、成对、以及全局的马尔可夫性质都是<strong>等价</strong>的。</p>
<h4 id="马尔可夫随机场与贝叶斯网络对比"><a href="#马尔可夫随机场与贝叶斯网络对比" class="headerlink" title="马尔可夫随机场与贝叶斯网络对比"></a>马尔可夫随机场与贝叶斯网络对比</h4><p>马尔可夫随机场与贝叶斯网络相比有几个优点：</p>
<ul>
<li><p>它们可以应用于更广泛的问题，其中没有和变量依赖相关的天然方向性。</p>
</li>
<li><p>无向图可以简洁地表达某些依赖关系，贝叶斯网络不容易描述它们（尽管反过来也是如此）。</p>
</li>
</ul>
<p>它们也有几个重要的缺点：</p>
<ul>
<li>计算归一化常数 $Z$ 需要对可能为指数数量的赋值进行求和。 在一般情况下，我们会看到这将是NP难的；因此许多无向模型是棘手的并需要近似技术。</li>
<li>马尔可夫随机场可能难以解释。</li>
<li>从贝叶斯网络生成数据要容易得多，这在某些应用中很重要。 </li>
</ul>
<p>不难看出，贝叶斯网络是马尔可夫随机场的特例，带有非常特定类型的团聚因子（对应于条件概率分布并且暗示图中的有向非循环结构）和归一化常数 1。 特别是，如果我们取一个有向图 $G$，并向给定节点的所有父节点添加侧边（并消除它们的方向性），那么贝叶斯网络（看做变量及其祖先的因子）可以在生成的无向图上因式分解。 由此产生的过程被称为规范化（Moralization）。</p>
<p><img src="http://image.rexking6.top/img/image-20190524154828076.png" alt=""></p>
<h3 id="Hammersley-clifford-Theorem"><a href="#Hammersley-clifford-Theorem" class="headerlink" title="Hammersley-clifford Theorem"></a>Hammersley-clifford Theorem</h3><p>Hammersley-Clifford定理指出：马尔科夫随机场和Gibbs分布是一致的。回顾一下马尔可夫随机场与Gibbs分布的概念：</p>
<ul>
<li><p><strong>马尔可夫随机场</strong>：对于一个无向图模型 $G$，对于其中的任意节点 $x_ i$，<strong>以除了它以外的所有点为条件的条件概率</strong>和<strong>以它的邻居节点为条件的条件概率</strong>相等，也就是满足以下公式，那么这个无向图就是马尔可夫随机场。</p>
<script type="math/tex; mode=display">
p(x_i|X\setminus x_i) = p(x_i|\text{ne}(x_i))</script></li>
<li><p><strong>Gibbs分布</strong>：如果无向图模型能够表示成一系列在G的最大团（们）上的非负函数乘积的形式，也就是满足以下公式，这个无向图模型的概率分布 $ p(X)$ 就称为Gibbs分布。</p>
<script type="math/tex; mode=display">
p(X) = \frac{1}{Z} \prod_{c \in C} \phi(\cal X_c)</script></li>
</ul>
<p>以下例子，将马尔可夫随机场表示为多个势函数相乘的函数</p>
<p><img src="http://image.rexking6.top/img/clip1559033297.png" alt=""></p>
<p>从结点1开始：</p>
<script type="math/tex; mode=display">
p(x_1,\dots x_7) = p(x_1|x_2,x_3)p(x_2,x_3,x_4,x_5,x_6,x_7)</script><p>根据 $p(x| \cal X \setminus x) = p(x|\text{ne}(x))$可得</p>
<script type="math/tex; mode=display">
\begin{align*}
p(x_1,x_2,x_3|x_4,x_5,x_6,x_7) &=p(x_1,x_2,x_3|x_4)\\
\Rightarrow \quad p(x_2,x_3|x_4,x_5,x_6,x_7) &= p(x_2,x_3|x_4) 
\end{align*}</script><p>可得：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(x_1,\dots x_7) &= p(x_1|x_2,x_3)p(x_2,x_3|x_4)p(x_4,x_5,x_6,x_7)\\
&= p(x_1|x_2,x_3)p(x_2,x_3|x_4)p(x_4|x_5,x_6)p(x_5,x_6| x_5)p(x_7)\\
\end{align*}</script><p>即得到的势函数（每个最大团块区域内变量）相乘的函数形式为：</p>
<script type="math/tex; mode=display">
p(x_1,\dots x_7) = \frac{1}{Z}\phi(x_1,x_2,x_3)\phi(x_2,x_3,x_4)\phi(x_4,x_5,x_6)\phi(x_5,x_6,x_7)</script><p>马尔可夫网络的分布是可表示的，它是在图中团块上定义的势函数的乘积，简单来说，马尔可夫网络与Gibbs分布的相互转换可以按以下形式理解，$G$ 表示马尔可夫网络，$F$ 为Gibbs分布。</p>
<ul>
<li>$G \Rightarrow F$：$F$ 表示一个连乘的式子，这些连乘的因子是由在定义在 $G$ 中的最大团块的势函数；</li>
<li>$F \Rightarrow G$：给定一个由势函数组合的式子，通过对该分解式可得到马尔科夫网络。</li>
</ul>
<p>证明Hammersley-Clifford定理的过程比较繁琐，就不再展开，详情可见<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dd27249b8c4a">Hammersley-Clifford定理证明</a>。</p>
<h4 id="条件独立判断"><a href="#条件独立判断" class="headerlink" title="条件独立判断"></a>条件独立判断</h4><blockquote>
<p>Ancestral Graph：Identify the ancestors $A$ of the nodes $X \cup Y \cup Z$. Retain the nodes $X \cup Y \cup Z$ but remove all other nodes which are not in $A$, together with any edges in or out of such nodes</p>
<p>Moralisation：Add  link between any two remaining nodes which have a common child, but are not already connected by an arrow. Then remove remaining arrow heads.</p>
<p>Separation：Remove links neighbouring $Z$. In the undirected graph so constructed, look for a path which joins a node in $X$ to one in $Y$.</p>
</blockquote>
<p>举个例子：</p>
<p><img src="http://image.rexking6.top/img/image-20190524155618363.png" alt=""></p>
<p>根据给定模型图，判断给定条件 $i,d$ 情况下，$a$ 和 $b$ 是否独立：</p>
<p>这个例子中，$X$ 为结点 $a$，$Y$ 为结点 $b$，$Z$ 为结点 $i, d$。(a)图像给定一个初始的BN图模型。首先根据Ancestral Graph，去掉无关结点，得到图(b)，然后根据Moralisation的规则去掉 $e$ 和 $f$ 分别到 $i$ 的有向连接，将 $e$ 和 $f$ 用无向线连接起来得到无向图(c)，最后通过图(c)，可以观察到在给定 $i,d$ 的条件下，$a$ 和 $b$ 是相互独立的。</p>
<h4 id="Lattice-Model（格子图模型）"><a href="#Lattice-Model（格子图模型）" class="headerlink" title="Lattice Model（格子图模型）"></a>Lattice Model（格子图模型）</h4><p><img src="http://image.rexking6.top/img/clip1559034317.png" alt=""></p>
<p>设计一个模型，模型中的每个变量取值只有两种 $\{-1,1\}$。一共有9个变量 {$x_1,\dots, x_9$}，均匀分布的在模型中，相邻的变量是同样的状态，</p>
<script type="math/tex; mode=display">
p(x_1,x_2 \dots,x_n) = \frac{1}{Z} \prod_{i,j} \phi(x_i,x_j)</script><h5 id="例：Ising-Models（伊辛模型）"><a href="#例：Ising-Models（伊辛模型）" class="headerlink" title="例：Ising Models（伊辛模型）"></a>例：Ising Models（伊辛模型）</h5><p>Ising模型根据定义势函数，其图模型同样是Lattice图模型，势函数定义如下：</p>
<script type="math/tex; mode=display">
\phi_{i,j}(x_i,x_j) = \exp(-\frac{1}{2T}(x_i-x_j)^2)</script><p>Ising模型是对应着物理学中的铁磁性物体的相变性质得到的，许多小铁磁性物质排成一列组成一维的Ising模型，随着温度增大，小磁性的物质之间的磁力就越小，此时没有出现全局磁化现象，比较该磁场相对不稳定；当T值减小则，小磁性的物质之间的磁力就越大，此时全部的小磁性物质稳定排列，出现全局磁化的现象。产生更大的磁力。考虑到二维的情况下，即Lattice模型下，将给定一个 $T$ 值，居里温度设为 $T(c)\sim2.269$，该温度下，Ising模型中的变量之间相互依赖，排列整齐，当温度增大或减少在一定程度上破坏了初始的稳定状态，假设变量 $M = |\sum^N_{i=1}x_i|/N$，该变量表明变量的平均整齐排列的值，通过改变 $T$ 值，$M$ 的曲线图像如下：</p>
<p><img src="http://image.rexking6.top/img/clip1559034436.png" alt=""></p>
<p>通过改变局部变量之间的关系从而对全部的变量产生影响。</p>
<h5 id="例：图像去噪"><a href="#例：图像去噪" class="headerlink" title="例：图像去噪"></a>例：图像去噪</h5><p><img src="http://image.rexking6.top/img/clip1559034475.png" alt=""></p>
<p>上图中，左图为原始图片，中间是受到噪声污染的图像，我们的目标是从噪声污染的图片中恢复图像，如右图所示。</p>
<p>将图像的像素值标为 $\{+1,-1\}$，原始图像的第 $i$ 个像素记为 $x_i$，受到污染的噪声图像的第 $i$ 个像素记为 $y_i$，由于噪声等级比较小，因此 $x_i $ 和 $y_i$ 之间有着强烈的相关性。我们还知道图像中相邻像素 $x _i $ 和 $x_ j $ 的相关性很强。这种先验知识可以使用马尔可夫随机场模型进行描述，它的无向图如下图所示。</p>
<p><img src="http://image.rexking6.top/img/clip1559034534.png" alt=""></p>
<p>这个图中有两种类型的团块，每一种团块包含两个变量。形如 $\{x_i, y_i\}$ 的团块有一个关联的能量函数，表达了这些变量之间的相关性。对于这些团块，我们选择一个非常简单的能量函数 $−\beta x_iy_i$，其中 $\beta $ 是一个正的常数。这个能量函数的效果是：当 $x_i$ 和 $y_i$ 符号相同时，能量函数会给出一个较低的能量（即较高的概率），而当 $x_i$ 和 $y_i$ 符号相反时，能量函数会给出 一个较高的能量。</p>
<p>剩余的团块由变量 {$x_i,x_j$} 组成，其中 $i$ 和 $j$ 是相邻像素的下标。与之前一样，我们希望当两个像素符号相同时能量较低，当两个像素符号相反时能量较高，因此我们选择能量函数 $−\alpha x_i x_j$，其中 $\alpha$ 是一个正的常数。</p>
<p>由于势函数是最大团块上的一个任意的非负的函数，因此我们可以将势函数与团块的子集上的任意非负函数相乘，或者等价地，我们可以加上对应的能量。</p>
<p>模型的完整的能量函数的形式为：</p>
<script type="math/tex; mode=display">
E(\cal X,\cal Y) = - \alpha \sum_{i,j}x_ix_j - \beta \sum_ix_iy_i</script><p>联合概率分布形式为：</p>
<script type="math/tex; mode=display">
\begin{align*}
p(\cal X,\cal Y) &= \frac{1}{Z}\exp(-E(\cal X,\cal Y)) \\
&= \frac{1}{Z}\exp(\alpha\sum_{i,j}x_ix_j + \beta\sum_ix_iy_i)
\end{align*}</script><p>去噪的过程可以解释为给定被噪声污染的图像 $\cal Y$，求解隐变量 $\cal X $ ，这与MAP相似，于是有</p>
<script type="math/tex; mode=display">
\begin{align*}
\cal X^* &= \underset{\cal X}{ \text{argmax}}\, p(\cal X|\cal Y) \\
&= \underset{\cal X}{\text{argmax}} \, \ln p(\cal X,\cal Y)\\
&= \underset{\cal X}{\text{argmax}} \, (\alpha\sum_{i,j}x_ix_j + \beta \sum_ix_iy_i)
\end{align*}</script><p>以两个像素点为例，假设估计值 $\alpha$ =8, $\beta = 10$，观测值 $y_1=+1,y_2=-1$，则当 $x_1=+1,x_2=+1$ 时，$ \ln p(X,Y) = \alpha\sum_{i,j}x_ix_j + \beta\sum_ix_iy_i = 8$， 类似计算，当 $x_1=+1,x_2=-1$ 时，$ \ln p(X,Y) =12$， 当$x_1=-1,x_2=+1$ 时，$ \ln p(X,Y) =-28$，当 $x_1=-1,x_2=-1$ 时，$ \ln p(X,Y) =8$，可知，原始图像的像素值最可能为 $(+1,-1)$。</p>
<h2 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h2><p>基于概率图模型定义的联合概率分布，我们能够对目标变量的边缘分布或条件分布进行计算，这一过程被成为推理。</p>
<p>对于概率图模型，还需要确定具体分布的参数，通常使用极大似然估计或最大后验概率估计求解。但如果将参数视为待推理的变量，则参数估计和推理十分相似，可以“吸收”到推理问题中。</p>
<p>概率图模型的推理方法可分为两类，一类是精确推理，能够计算出目标变量的边缘分布或条件分布的精确值；另一类是近似推理，可以在较低的时间复杂度下得到近似解。</p>
<h3 id="精确推理"><a href="#精确推理" class="headerlink" title="精确推理"></a>精确推理</h3><h4 id="因子图"><a href="#因子图" class="headerlink" title="因子图"></a>因子图</h4><p>引用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Factor_graph">wiki</a>里对因子图的定义，将一个具有多个变量的全局函数因子分解，得到局部函数乘积，由此得到的双向图就是因子图（Factor Graph）。可以将因子图表示为三元组 $ G = (X,F,E)$， $X = x_1,\dots, x_n$ 为变量结点，$F = f_1,\dots, f_n$ 为因子结点， $E$ 为边的集合。设有一个全局函数 $p(x_1,\dots,x_n)$，分解完毕之后就可以将其表示为如下公式</p>
<script type="math/tex; mode=display">
p(x_1,\dots,x_n) = \prod^m_{j=1} f_j(S_j)</script><p>其中 $S_j \sube X $，其对应的因子图 $G =(X,F,E)$，因子节点 $F=\{f_{1},f_{2},\dots ,f_{n}\}$。因子图用圆圈表示概率分布中的每个变量，用正方形表示联合概率分布中的每个因子$f_s(S_j)$，各函数表述的是变量之间的关系，比如在有向图中，就是条件概率，而在马尔可夫随机场中就是势函数。在每个因子结点和因子所依赖的变量结点之间引入无向链接。简单理解一下因子图就是在有向图、无向图的基础上，引入了额外的结点来表示函数本身。下图就是一个因子图。</p>
<p><img src="http://image.rexking6.top/img/clip1559035051.png" alt=""></p>
<p>当联合概率分布是由无向图表示时，我们可以直接由无向图推出因子图。因子图的变量结点与无向图对应，然后构造额外的因子结点，对应于最大团，因子与最大团的势函数相等，如图所示。注意，不同的因子图可能对应相同的无向图。</p>
<p><img src="http://image.rexking6.top/img/clip1559035122.png" alt=""></p>
<p>类似的，对于有向图，先构造对应的变量结点，然后构造对应于条件分布的因子结点，最后添加上合适的连接，如下所示</p>
<p><img src="http://image.rexking6.top/img/image-20190525185749515.png" alt=""></p>
<p>以上三个都是 $p(x_1)p(x_2)p(x_3|x_1,x_2)$。</p>
<p>而同一个因子图可以转换为有向图也可以转换为无向图，如图所示</p>
<p><img src="http://image.rexking6.top/img/image-20190525190356901.png" alt=""></p>
<p>图(a)是因子图，而图(b)图(c)分别是无向图与有向图。</p>
<h4 id="sum-product算法"><a href="#sum-product算法" class="headerlink" title="sum-product算法"></a>sum-product算法</h4><p>在概率图中，求某个变量的边缘分布是常见的问题。这问题有很多求解方法，其中之一就是把贝叶斯网络或马尔科夫随机场转换成因子图，然后用sum-product算法求解。换言之，sum-product算法就是一个<strong>计算边缘概率</strong>的<strong>低复杂度</strong>的算法，求边缘分布需要大量的累加运算，而sum-product算法将大量的累加运算分配到乘积项内，从而降低复杂度。</p>
<p>sum-product算法可以使用信息的传递进行表示，我们将变量节点 $x$向因子结点$f$传递消息的过程记为 $u_{x \Rightarrow f}(x)$，因子结点$f$向变量结点 $x$ 传递消息记为 $u_{f \Rightarrow x}(x)$，变量的边缘分布于它接受的所有消息的乘积成正比，即</p>
<script type="math/tex; mode=display">
p(x) \propto \prod_{f \in ns(x)}u_{f \Rightarrow x}(x)</script><p>于是我们只要选择一个根结点，从所有叶子结点向根结点传递一次信息，根结点从叶子结点传递一次信息，就可以计算出所有变量的边缘分布。信息的传递分为四种情况：</p>
<ol>
<li><p>叶子结点为因子结点，传递的信息为：</p>
<p><img src="http://image.rexking6.top/img/clip1559038122.png" alt=""></p>
</li>
<li><p>叶子结点为变量结点，传递的信息为：</p>
<p><img src="http://image.rexking6.top/img/clip1559038143.png" alt=""></p>
</li>
<li><p>非叶子变量结点传递信息给因子结点时，传递的信息为：</p>
<p><img src="http://image.rexking6.top/img/clip1559038229.png" alt=""></p>
</li>
<li><p>非叶子因子结点传递信息给变量结点时，传递的信息为 ：</p>
<p><img src="http://image.rexking6.top/img/clip1559038272.png" alt=""></p>
<p>其中 $\chi_f$ 指的是 {$y_1,y_2,y_3, x$}， $ \sum_{\chi_f  \setminus x}\phi_f(\chi_f)= \sum{y_1,y_2,y_3}f(y_1,y_2,y_3,x) $。</p>
</li>
</ol>
<p>变量的边缘分布就可以通过这样的方式得到：</p>
<p><img src="http://image.rexking6.top/img/clip1559038525.png" alt=""></p>
<p>举一个例子，给定如下的因子图，现在欲求解 $x_2$ 的边缘分布。</p>
<p><img src="http://image.rexking6.top/img/clip1559038557.png" alt=""></p>
<p>本题中 $ x_2 $ 边缘分布的定义为联合概率分布对其他变量求和，即：</p>
<script type="math/tex; mode=display">
\tilde{p}(x_2) = \sum_{x_1}\sum_{x_3}\sum_{x_4} \tilde{p}(X)</script><p>此时，整个图未归一化的联合概率分布为：</p>
<script type="math/tex; mode=display">
\tilde{p}(X) = f_a(x_1,x_2)f_b(x_2,x_3)f_c(x_2,x_4)</script><p>使用sum-product算法对 $ x_ 2 $ 的边缘分布进行计算：</p>
<script type="math/tex; mode=display">
\begin{align*}
\tilde{p}(x_2) &=u_{f_a \Rightarrow x_2}(x_2) * u_{f_b \Rightarrow x_2}(x_2) *u_{f_c \Rightarrow x_2}(x_2)\\
&=\sum_{x_1}f_a(x_1,x_2) \sum_{x_3}f_b(x_3,x_2) \sum_{x_4}f_a(x_4,x_2)\\
&= \sum_{x_1}\sum_{x_3}\sum_{x_4} \tilde{p}(X)
\end{align*}</script><p>这与边缘分布的定义一致。求的如果是 $x_3$ 的边缘分布，那么</p>
<script type="math/tex; mode=display">
\begin{align*}
\tilde{p}(x_3) &=u_{f_b \Rightarrow x_3}(x_3) \\
&= \sum_{x_2}f_b(x_2,x_3) u_{x_2 \Rightarrow f_b} \\
&= \sum_{x_2}f_b(x_2,x_3) u_{a \Rightarrow x_2} u_{c \Rightarrow x_2} \\
&= \sum_{x_2}f_b(x_2,x_3) \sum_{x_1}f_a(x_1,x_2)\sum_{x_4}f_c(x_2,x_4)
\end{align*}</script><p>归一化因子的计算方法如下：</p>
<script type="math/tex; mode=display">
Z = \sum_x \prod_{f\in \text{ne}(x)}u_{f \Rightarrow x}(x)</script><p>关于更多sum-product算法的例子可见<a target="_blank" rel="noopener" href="http://heathcliff.me/图模型与和积算法/">sum-product例子</a>。</p>
<p>由于 $\tilde p(X)$ 是未归一化的，上面得到的 $\tilde p(x_2)$ 也是未归一化的，归一化因子的计算方法如下：</p>
<script type="math/tex; mode=display">
Z=\sum_x\prod_{f\in\text{ne}(x)}\mu_{f\rightarrow x}(x)</script><p>如果图比较大，概率连乘可能会变得非常小，使得难以精确计算。一种处理方法是使用对数，</p>
<script type="math/tex; mode=display">
\lambda = \log \mu</script><p>相应的有：</p>
<script type="math/tex; mode=display">
\log p(x)=\sum_{f \in \text{ne}(x)}\lambda_{f\rightarrow x}(x)</script><p>非叶子变量结点向因子结点传递消息修改为：</p>
<script type="math/tex; mode=display">
\lambda_{x\rightarrow f}(x)=\sum_{g\in \{\text{ne}(x)\setminus f\}}\lambda_{g\rightarrow x}(x)</script><p>非叶子因子结点向变量结点传递消息修改为：</p>
<script type="math/tex; mode=display">
\lambda_{f\rightarrow x}(x)=\log\left(\sum_{\cal X_f\setminus x}\phi_f(\cal X_f)\exp\left(\sum_{y\in \{\text{ne}(f)\setminus x\}}\lambda_{y\rightarrow f}(y)\right)\right)</script><p>这里，对数结果的幂运算可能会发生数值上涨，解决方法是在指数中减去一个常数。我们令：</p>
<script type="math/tex; mode=display">
\lambda_{y\rightarrow f}^\ast=\max_{y\in\{ne(f)\setminus x\}}\lambda_{y\rightarrow f}(y)</script><p>则非叶子因子结点向变量结点传递消息修改为：</p>
<script type="math/tex; mode=display">
\lambda_{f\rightarrow x}(x)=\lambda_{y\rightarrow f}^\ast+\log\left(\sum_{\cal X_f\setminus x}\phi_f(\cal X_f)\exp\left(\sum_{y\in \{\text{ne}(f)\setminus x\}}\lambda_{y\rightarrow f}(y)-\lambda_{y\rightarrow f}^\ast\right)\right)</script><p>即可避免这个问题。</p>
<h3 id="近似推理"><a href="#近似推理" class="headerlink" title="近似推理"></a>近似推理</h3><p>见<a href="http://blog.rexking6.top/2019/05/30/%E5%8F%98%E5%88%86%E6%8E%A8%E7%90%86/">另外一篇博客</a>。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2018\10\29\《多媒体技术》\" rel="bookmark">《多媒体技术》</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2018\09\27\《视频分析前沿》一\" rel="bookmark">《视频分析前沿》一</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2019\01\06\《计算智能》（二）概率\" rel="bookmark">《计算智能》（二）概率</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div>一分一毛，也是心意。</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Run-Qing Chen 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Run-Qing Chen 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Run-Qing Chen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://blog.rexking6.top/2019/02/28/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B/" title="《机器学习》">https://blog.rexking6.top/2019/02/28/《机器学习》/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%A1%95%E5%A3%AB%E8%AF%BE%E7%A8%8B/" rel="tag"># 硕士课程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/02/17/%E3%80%8ATime-series-Extreme-Event-Forecasting-with-Neural-Networks-at-Uber%E3%80%8B%E7%AC%94%E8%AE%B0/" rel="prev" title="《Time-series Extreme Event Forecasting with Neural Networks at Uber》笔记">
      <i class="fa fa-chevron-left"></i> 《Time-series Extreme Event Forecasting with Neural Networks at Uber》笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/03/03/%E3%80%8ADetecting-Spacecraf-Anomalies-Using-LSTMs-and-Nonparametric-Dynamic-Thresholding%E3%80%8B%E7%AC%94%E8%AE%B0/" rel="next" title="《Detecting Spacecraf Anomalies Using LSTMs and Nonparametric Dynamic Thresholding》笔记">
      《Detecting Spacecraf Anomalies Using LSTMs and Nonparametric Dynamic Thresholding》笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

    <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9B%B2%E7%BA%BF%E6%8B%9F%E5%90%88%EF%BC%88%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">曲线拟合（线性回归）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E8%A7%92%E5%BA%A6%E7%9C%8B%E8%A7%A3%E6%9E%90%E8%A7%A3"><span class="nav-number">2.1.</span> <span class="nav-text">不同角度看解析解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8"><span class="nav-number">2.1.1.</span> <span class="nav-text">核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4"><span class="nav-number">2.1.2.</span> <span class="nav-text">空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1"><span class="nav-number">2.1.3.</span> <span class="nav-text">最大似然估计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87%EF%BC%8C%E5%BC%95%E5%85%A5%E6%AD%A3%E5%88%99%E5%8C%96"><span class="nav-number">2.1.4.</span> <span class="nav-text">最大后验概率，引入正则化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%84%9F%E7%9F%A5%E6%9C%BA%EF%BC%88%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">感知机（线性分类）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E7%9A%84%E9%98%B6%E8%B7%83%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text">[-1,1]的阶跃函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Logistic%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.</span> <span class="nav-text">Logistic函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM"><span class="nav-number">4.</span> <span class="nav-text">支持向量机SVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%8F%AF%E5%88%86"><span class="nav-number">4.1.1.</span> <span class="nav-text">线性可分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%B4%E9%9A%94%E6%9C%80%E5%A4%A7"><span class="nav-number">4.1.2.</span> <span class="nav-text">间隔最大</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%97%B4%E9%9A%94%E4%B8%8E%E5%87%A0%E4%BD%95%E9%97%B4%E9%9A%94"><span class="nav-number">4.1.3.</span> <span class="nav-text">函数间隔与几何间隔</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%B4%E9%9A%94%E6%9C%80%E5%A4%A7%E5%8C%96"><span class="nav-number">4.1.4.</span> <span class="nav-text">间隔最大化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E9%97%B4%E9%9A%94%E6%9C%80%E5%A4%A7%E5%8C%96"><span class="nav-number">4.2.</span> <span class="nav-text">硬间隔最大化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98"><span class="nav-number">4.2.1.</span> <span class="nav-text">对偶问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E5%88%B0%E5%8E%9F%E9%97%AE%E9%A2%98"><span class="nav-number">4.2.2.</span> <span class="nav-text">回到原问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E9%97%B4%E9%9A%94%E6%9C%80%E5%A4%A7%E5%8C%96"><span class="nav-number">4.3.</span> <span class="nav-text">软间隔最大化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E6%9C%80%E5%B0%8F%E6%9C%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.</span> <span class="nav-text">序列最小最优化算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SVM%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="nav-number">4.5.</span> <span class="nav-text">SVM的损失函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%87%BD%E6%95%B0"><span class="nav-number">4.6.</span> <span class="nav-text">核函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Logistic%E5%9B%9E%E5%BD%92%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">Logistic回归分类模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">梯度下降法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%9B%E9%A1%BF%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">牛顿法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">5.3.</span> <span class="nav-text">引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E5%BC%8F%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.</span> <span class="nav-text">产生式模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF"><span class="nav-number">6.1.</span> <span class="nav-text">朴素贝叶斯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%96%E7%95%A5"><span class="nav-number">6.1.1.</span> <span class="nav-text">策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E6%96%AF%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90"><span class="nav-number">6.1.2.</span> <span class="nav-text">高斯判别分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.2.</span> <span class="nav-text">隐马尔可夫模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E7%90%86%EF%BC%88%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97%EF%BC%89%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.1.</span> <span class="nav-text">推理（概率计算）问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%9B%B4%E6%8E%A5%E8%AE%A1%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">1.直接计算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%89%8D%E5%90%91%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.1.2.</span> <span class="nav-text">2.前向算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%90%8E%E5%90%91%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.1.3.</span> <span class="nav-text">3.后向算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%89%8D%E5%90%91-%E5%90%8E%E5%90%91"><span class="nav-number">6.2.1.4.</span> <span class="nav-text">4.前向-后向</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E6%B5%8B%EF%BC%88%E8%A7%A3%E7%A0%81%EF%BC%89%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.2.</span> <span class="nav-text">预测（解码）问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.2.1.</span> <span class="nav-text">近似算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Viterbi%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.2.2.</span> <span class="nav-text">Viterbi算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%AD%A6%E4%B9%A0%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.3.</span> <span class="nav-text">参数学习问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AD%A6%E4%B9%A0"><span class="nav-number">7.</span> <span class="nav-text">贝叶斯学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MLE"><span class="nav-number">7.1.</span> <span class="nav-text">MLE</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A%E4%BC%AF%E5%8A%AA%E5%88%A9%E5%88%86%E5%B8%83"><span class="nav-number">7.1.1.</span> <span class="nav-text">举例：伯努利分布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%88%86%E5%B8%83"><span class="nav-number">7.1.2.</span> <span class="nav-text">举例：多项式分布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83"><span class="nav-number">7.1.3.</span> <span class="nav-text">举例：高斯分布</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MAP"><span class="nav-number">7.2.</span> <span class="nav-text">MAP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A%E5%8D%95%E5%8F%98%E9%87%8F%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84%E5%9D%87%E5%80%BC"><span class="nav-number">7.2.1.</span> <span class="nav-text">举例：单变量高斯分布的均值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.2.2.</span> <span class="nav-text">举例：回归模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%BC%B0%E8%AE%A1"><span class="nav-number">7.3.</span> <span class="nav-text">贝叶斯估计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A%E4%BC%B0%E8%AE%A1%E5%88%86%E5%B8%83%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%9A%E7%A6%BB%E6%95%A3%E5%8F%98%E9%87%8F%EF%BC%88%E5%A4%9A%E5%80%BC%EF%BC%89"><span class="nav-number">7.3.1.</span> <span class="nav-text">举例：估计分布的参数：离散变量（多值）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dirichlet%E5%88%86%E5%B8%83"><span class="nav-number">7.3.1.1.</span> <span class="nav-text">Dirichlet分布</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A%E4%BC%B0%E8%AE%A1%E5%88%86%E5%B8%83%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%9A%E7%A6%BB%E6%95%A3%E5%8F%98%E9%87%8F%EF%BC%88%E4%BA%8C%E5%80%BC%EF%BC%89"><span class="nav-number">7.3.2.</span> <span class="nav-text">举例：估计分布的参数：离散变量（二值）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E9%A1%B9%E5%88%86%E5%B8%83%E7%9A%84MLE-MAP-%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%BC%B0%E8%AE%A1%E4%B8%89%E8%80%85%E6%AF%94%E8%BE%83"><span class="nav-number">7.3.3.</span> <span class="nav-text">二项分布的MLE&#x2F;MAP&#x2F;贝叶斯估计三者比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%B0%E8%AE%A1%E5%88%86%E5%B8%83%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%9A%E5%8D%95%E5%8F%98%E9%87%8F%E9%AB%98%E6%96%AF%EF%BC%8C%E6%96%B9%E5%B7%AE%E5%B7%B2%E7%9F%A5"><span class="nav-number">7.3.4.</span> <span class="nav-text">估计分布的参数：单变量高斯，方差已知</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%B0%E8%AE%A1%E5%88%86%E5%B8%83%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%9A%E5%8D%95%E5%8F%98%E9%87%8F%E9%AB%98%E6%96%AF%EF%BC%8C%E6%96%B9%E5%B7%AE%E6%9C%AA%E7%9F%A5"><span class="nav-number">7.3.5.</span> <span class="nav-text">估计分布的参数：单变量高斯，方差未知</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%B0%E8%AE%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%9A%E5%9B%9E%E5%BD%92"><span class="nav-number">7.3.6.</span> <span class="nav-text">估计模型的参数：回归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%B0%E8%AE%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%9A%E5%88%86%E7%B1%BB"><span class="nav-number">7.3.7.</span> <span class="nav-text">估计模型的参数：分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%B0%E8%AE%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%9A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%9A%84%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%BC%B0%E8%AE%A1"><span class="nav-number">7.3.8.</span> <span class="nav-text">估计模型的参数：朴素贝叶斯的贝叶斯估计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">7.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EM"><span class="nav-number">8.</span> <span class="nav-text">EM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%85%A5"><span class="nav-number">8.1.</span> <span class="nav-text">引入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B%E4%B8%8EEM"><span class="nav-number">8.2.</span> <span class="nav-text">混合高斯模型与EM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GMM%E7%9A%84%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%90%86%E8%A7%A3"><span class="nav-number">8.2.1.</span> <span class="nav-text">GMM的贝叶斯理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%A4%87%E6%95%B0%E6%8D%AE"><span class="nav-number">8.2.2.</span> <span class="nav-text">完备数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%AE%8C%E5%A4%87%E6%95%B0%E6%8D%AE"><span class="nav-number">8.2.3.</span> <span class="nav-text">非完备数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E4%BC%B0%E8%AE%A1%E4%B8%8EEM"><span class="nav-number">8.3.</span> <span class="nav-text">最大后验估计与EM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#k-means%E4%B8%8EEM"><span class="nav-number">8.4.</span> <span class="nav-text">k-means与EM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC%EF%BC%88%E6%94%B6%E6%95%9B%E6%80%A7%EF%BC%89"><span class="nav-number">8.5.</span> <span class="nav-text">算法推导（收敛性）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E5%B8%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">8.6.</span> <span class="nav-text">硬币模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%ABHMM%E4%B8%8EEM"><span class="nav-number">8.7.</span> <span class="nav-text">隐马尔可夫HMM与EM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E4%BC%AF%E5%8A%AA%E5%88%A9%E6%A8%A1%E5%9E%8B%E4%B8%8EEM"><span class="nav-number">8.8.</span> <span class="nav-text">混合伯努利模型与EM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89EM%E7%AE%97%E6%B3%95%EF%BC%88GEM%EF%BC%89"><span class="nav-number">8.9.</span> <span class="nav-text">广义EM算法（GEM）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VBEM"><span class="nav-number">8.10.</span> <span class="nav-text">VBEM</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0"><span class="nav-number">9.</span> <span class="nav-text">集成学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%B3%E7%AD%96%E6%A0%91"><span class="nav-number">9.1.</span> <span class="nav-text">决策树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CART%E6%A1%86%E6%9E%B6"><span class="nav-number">9.1.1.</span> <span class="nav-text">CART框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B"><span class="nav-number">9.1.2.</span> <span class="nav-text">模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">9.1.2.1.</span> <span class="nav-text">优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9"><span class="nav-number">9.1.3.</span> <span class="nav-text">特征选择</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A-%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A%E7%8E%87%EF%BC%88ID3-C4-5%EF%BC%89"><span class="nav-number">9.1.3.1.</span> <span class="nav-text">信息增益&#x2F;信息增益率（ID3&#x2F;C4.5）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Gini%E5%9F%BA%E5%B0%BC%E6%8C%87%E6%95%B0%EF%BC%88CART%EF%BC%89"><span class="nav-number">9.1.3.2.</span> <span class="nav-text">Gini基尼指数（CART）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%B7%AE"><span class="nav-number">9.1.3.3.</span> <span class="nav-text">方差</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E7%94%9F%E6%88%90"><span class="nav-number">9.1.4.</span> <span class="nav-text">树的生成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E7%82%B9%E7%9A%84%E5%8F%96%E5%80%BC%E6%83%85%E5%86%B5%EF%BC%9F"><span class="nav-number">9.1.4.1.</span> <span class="nav-text">结点的取值情况？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%87%E7%94%A8%E5%93%AA%E4%B8%AA%E5%B1%9E%E6%80%A7%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%EF%BC%9F"><span class="nav-number">9.1.4.2.</span> <span class="nav-text">采用哪个属性进行测试？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.1.4.3.</span> <span class="nav-text">属性值类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%B1%9E%E6%80%A7vs%E5%A4%9A%E5%B1%9E%E6%80%A7"><span class="nav-number">9.1.4.4.</span> <span class="nav-text">单属性vs多属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%B8%BA%E5%8F%B6%E7%BB%93%E7%82%B9"><span class="nav-number">9.1.4.5.</span> <span class="nav-text">何时为叶结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%B1%9E%E6%80%A7%E5%80%BC%E4%B8%A2%E5%A4%B1%E7%BB%93%E7%82%B9"><span class="nav-number">9.1.4.6.</span> <span class="nav-text">处理属性值丢失结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="nav-number">9.1.4.7.</span> <span class="nav-text">模型选择</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97"><span class="nav-number">9.2.</span> <span class="nav-text">随机森林</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Randomized-Decision-Trees"><span class="nav-number">9.2.1.</span> <span class="nav-text">Randomized Decision Trees</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Random-Forest"><span class="nav-number">9.2.2.</span> <span class="nav-text">Random Forest</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Extremely-Randomized-trees"><span class="nav-number">9.2.3.</span> <span class="nav-text">Extremely Randomized trees</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ferns"><span class="nav-number">9.2.4.</span> <span class="nav-text">Ferns</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Boosting"><span class="nav-number">9.3.</span> <span class="nav-text">Boosting</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AdaBoost"><span class="nav-number">9.3.1.</span> <span class="nav-text">AdaBoost</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="nav-number">9.3.1.1.</span> <span class="nav-text">算法流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">9.3.1.2.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E4%BA%8E%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B"><span class="nav-number">9.3.1.3.</span> <span class="nav-text">应用于目标检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E8%B5%84%E6%BA%90"><span class="nav-number">9.3.1.4.</span> <span class="nav-text">软件资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%96%E7%95%A5-1"><span class="nav-number">9.3.1.5.</span> <span class="nav-text">策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%9B%9E%E9%A1%BE"><span class="nav-number">9.3.1.6.</span> <span class="nav-text">损失函数回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%90%86%E6%83%B3%E7%9A%840-1%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="nav-number">9.3.1.6.1.</span> <span class="nav-text">理想的0-1损失函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">9.3.1.6.2.</span> <span class="nav-text">基于最小二乘法的分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SVM%E7%9A%84Hinge%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="nav-number">9.3.1.6.3.</span> <span class="nav-text">SVM的Hinge损失函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AdaBoost%E7%9A%84%E6%8C%87%E6%95%B0%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="nav-number">9.3.1.6.4.</span> <span class="nav-text">AdaBoost的指数损失函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Logistic%E5%9B%9E%E5%BD%92%E7%9A%84%E6%8C%87%E6%95%B0%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="nav-number">9.3.1.6.5.</span> <span class="nav-text">Logistic回归的指数损失函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E5%8D%87%E6%A0%91%EF%BC%88Boosting-Trees%EF%BC%89"><span class="nav-number">9.3.2.</span> <span class="nav-text">提升树（Boosting Trees）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B-1"><span class="nav-number">9.3.2.1.</span> <span class="nav-text">模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">9.3.2.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A2%AF%E5%BA%A6%E6%8F%90%E5%8D%87%E6%A0%91%EF%BC%88GBDT%EF%BC%89"><span class="nav-number">9.3.2.3.</span> <span class="nav-text">梯度提升树（GBDT）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E5%8C%96"><span class="nav-number">9.3.2.4.</span> <span class="nav-text">正则化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E7%BB%84%E5%90%88"><span class="nav-number">9.4.</span> <span class="nav-text">模型组合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%97%E5%88%B0%E4%B8%80%E7%BB%84%E5%88%86%E7%B1%BB%E5%99%A8"><span class="nav-number">9.4.1.</span> <span class="nav-text">得到一组分类器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81"><span class="nav-number">9.4.1.1.</span> <span class="nav-text">交叉验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bagging"><span class="nav-number">9.4.1.2.</span> <span class="nav-text">Bagging</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%88%86%E7%B1%BB%E5%99%A8"><span class="nav-number">9.4.2.</span> <span class="nav-text">组合分类器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Stacking"><span class="nav-number">9.4.2.1.</span> <span class="nav-text">Stacking</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Averaging"><span class="nav-number">9.4.2.2.</span> <span class="nav-text">Averaging</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Boosting-1"><span class="nav-number">9.4.2.3.</span> <span class="nav-text">Boosting</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E7%8E%87%E5%9B%BE"><span class="nav-number">10.</span> <span class="nav-text">概率图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">10.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE"><span class="nav-number">10.2.</span> <span class="nav-text">有向图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%EF%BC%9A%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92"><span class="nav-number">10.2.1.</span> <span class="nav-text">例：多项式回归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%EF%BC%9ALogistic-Sigmoid%E5%87%BD%E6%95%B0"><span class="nav-number">10.2.2.</span> <span class="nav-text">例：Logistic Sigmoid函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%EF%BC%9A%E5%A4%9A%E5%85%83%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B"><span class="nav-number">10.2.3.</span> <span class="nav-text">例：多元高斯模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%EF%BC%9AWet"><span class="nav-number">10.2.4.</span> <span class="nav-text">例：Wet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%EF%BC%9A%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B"><span class="nav-number">10.2.5.</span> <span class="nav-text">例：混合高斯模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%EF%BC%9A%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B"><span class="nav-number">10.2.6.</span> <span class="nav-text">例：隐马尔可夫模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%EF%BC%9A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF"><span class="nav-number">10.2.7.</span> <span class="nav-text">例：朴素贝叶斯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%EF%BC%9A%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C"><span class="nav-number">10.2.8.</span> <span class="nav-text">例：贝叶斯网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%B2%E7%AA%81%E5%8F%98%E9%87%8F"><span class="nav-number">10.2.9.</span> <span class="nav-text">冲突变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE"><span class="nav-number">10.3.</span> <span class="nav-text">无向图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-number">10.3.1.</span> <span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%EF%BC%9A-%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA%EF%BC%88Boltzmann-Machine%EF%BC%89"><span class="nav-number">10.3.1.1.</span> <span class="nav-text">例： 玻尔兹曼机（Boltzmann Machine）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%EF%BC%9A%E9%99%90%E5%88%B6%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA%EF%BC%88Restricted-Boltzmann-Machines%EF%BC%89"><span class="nav-number">10.3.1.2.</span> <span class="nav-text">例：限制玻尔兹曼机（Restricted Boltzmann Machines）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%EF%BC%9A%E6%B7%B1%E5%BA%A6%E7%BD%AE%E4%BF%A1%E7%BD%91%E7%BB%9C%EF%BC%88Deep-Belief-Network%EF%BC%89"><span class="nav-number">10.3.1.3.</span> <span class="nav-text">例：深度置信网络（Deep Belief Network）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%EF%BC%9A%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA%EF%BC%88Conditional-Random-Field%EF%BC%89"><span class="nav-number">10.3.1.4.</span> <span class="nav-text">例：条件随机场（Conditional Random Field）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">10.3.2.</span> <span class="nav-text">特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="nav-number">10.3.2.1.</span> <span class="nav-text">条件独立性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E7%82%B9%E9%9B%86%E4%B8%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%80%A7%E8%B4%A8%EF%BC%88Global-Markov-Property%EF%BC%89"><span class="nav-number">10.3.2.2.</span> <span class="nav-text">以点集为对象的马尔可夫性质（Global Markov Property）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E7%82%B9%E4%B8%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%80%A7%E8%B4%A8%EF%BC%88Local-Markov-Property%EF%BC%89"><span class="nav-number">10.3.2.3.</span> <span class="nav-text">以点为对象的马尔可夫性质（Local Markov Property）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E5%AF%B9%E4%B8%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E7%BD%91%E7%BB%9C%E6%80%A7%E8%B4%A8%EF%BC%88Pairwise-Markov-Property%EF%BC%89"><span class="nav-number">10.3.2.4.</span> <span class="nav-text">以对为对象的马尔可夫网络性质（Pairwise Markov Property）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%9A%8F%E6%9C%BA%E5%9C%BA%E4%B8%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C%E5%AF%B9%E6%AF%94"><span class="nav-number">10.3.2.5.</span> <span class="nav-text">马尔可夫随机场与贝叶斯网络对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hammersley-clifford-Theorem"><span class="nav-number">10.3.3.</span> <span class="nav-text">Hammersley-clifford Theorem</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%8B%AC%E7%AB%8B%E5%88%A4%E6%96%AD"><span class="nav-number">10.3.3.1.</span> <span class="nav-text">条件独立判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lattice-Model%EF%BC%88%E6%A0%BC%E5%AD%90%E5%9B%BE%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="nav-number">10.3.3.2.</span> <span class="nav-text">Lattice Model（格子图模型）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%8B%EF%BC%9AIsing-Models%EF%BC%88%E4%BC%8A%E8%BE%9B%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="nav-number">10.3.3.2.1.</span> <span class="nav-text">例：Ising Models（伊辛模型）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%8B%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%8E%BB%E5%99%AA"><span class="nav-number">10.3.3.2.2.</span> <span class="nav-text">例：图像去噪</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E7%90%86"><span class="nav-number">10.4.</span> <span class="nav-text">推理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B2%BE%E7%A1%AE%E6%8E%A8%E7%90%86"><span class="nav-number">10.4.1.</span> <span class="nav-text">精确推理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%A0%E5%AD%90%E5%9B%BE"><span class="nav-number">10.4.1.1.</span> <span class="nav-text">因子图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sum-product%E7%AE%97%E6%B3%95"><span class="nav-number">10.4.1.2.</span> <span class="nav-text">sum-product算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%91%E4%BC%BC%E6%8E%A8%E7%90%86"><span class="nav-number">10.4.2.</span> <span class="nav-text">近似推理</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Run-Qing Chen"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Run-Qing Chen</p>
  <div class="site-description" itemprop="description">覆苍天以为衾，卧大地以为庐。</div>
</div>


   <div class="feed-link motion-element">
     <a href="/atom.xml" rel="alternate">
       <i class="fa fa-rss"></i>
       RSS
     </a>
   </div>
 
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">183</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RexKing6" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RexKing6" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1010026261@qq.com" title="E-Mail → mailto:1010026261@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.zxpblog.cn/" title="https:&#x2F;&#x2F;www.zxpblog.cn&#x2F;" rel="noopener" target="_blank">赵小平</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://whitepuffer.github.io/" title="https:&#x2F;&#x2F;whitepuffer.github.io&#x2F;" rel="noopener" target="_blank">江斓</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kexue.fm/" title="https:&#x2F;&#x2F;kexue.fm&#x2F;" rel="noopener" target="_blank">科学空间</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yongyuan.name/" title="https:&#x2F;&#x2F;yongyuan.name&#x2F;" rel="noopener" target="_blank">袁勇</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/abcjennifer" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;abcjennifer" rel="noopener" target="_blank">Rachel Zhang</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://dmkf.xyz/" title="http:&#x2F;&#x2F;dmkf.xyz&#x2F;" rel="noopener" target="_blank">代码咖啡</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://wuxiaolong.me/" title="http:&#x2F;&#x2F;wuxiaolong.me&#x2F;" rel="noopener" target="_blank">吴小龙同学</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.tennfy.com/" title="http:&#x2F;&#x2F;www.tennfy.com&#x2F;" rel="noopener" target="_blank">TENNFY WU</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fab fa-accessible-icon"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Run-Qing Chen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">3.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">47:56</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"6XDsO3aHIjDk3nV6eLJCufbl-MdYXbMMI","app_key":"YK4qOc0TpkazN6exhuqsnwmB","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
